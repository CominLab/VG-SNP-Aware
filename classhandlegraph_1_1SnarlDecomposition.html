<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: handlegraph::SnarlDecomposition Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehandlegraph.html">handlegraph</a></li><li class="navelem"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html">SnarlDecomposition</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classhandlegraph_1_1SnarlDecomposition-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">handlegraph::SnarlDecomposition Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;snarl_decomposition.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for handlegraph::SnarlDecomposition:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classhandlegraph_1_1SnarlDecomposition.png" usemap="#handlegraph::SnarlDecomposition_map" alt=""/>
  <map id="handlegraph::SnarlDecomposition_map" name="handlegraph::SnarlDecomposition_map">
<area href="classhandlegraph_1_1BuildableSnarlDecomposition.html" alt="handlegraph::BuildableSnarlDecomposition" shape="rect" coords="0,56,253,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a17b276026a2c6d99be0f63ffbc92ccd3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a17b276026a2c6d99be0f63ffbc92ccd3">endpoint_t</a> { <a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a17b276026a2c6d99be0f63ffbc92ccd3ab5854c3018055ccefae586f717850711">START</a>, 
<a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a17b276026a2c6d99be0f63ffbc92ccd3aa14d92884083adfe371667c2ce1d70a5">END</a>, 
<a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a17b276026a2c6d99be0f63ffbc92ccd3a41062278414d99cdb309732619f1ce5f">TIP</a>
 }</td></tr>
<tr class="separator:a17b276026a2c6d99be0f63ffbc92ccd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad5055e48b8816d5785052da55e6da996"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#ad5055e48b8816d5785052da55e6da996">~SnarlDecomposition</a> ()=default</td></tr>
<tr class="separator:ad5055e48b8816d5785052da55e6da996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53f4ad10c14ac326d242e6068a53f27"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#aa53f4ad10c14ac326d242e6068a53f27">get_root</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;net) const =0</td></tr>
<tr class="separator:aa53f4ad10c14ac326d242e6068a53f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef6c85a6564d6d3ec65bfb245e1f38c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#afef6c85a6564d6d3ec65bfb245e1f38c">is_root</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;net) const =0</td></tr>
<tr class="separator:afef6c85a6564d6d3ec65bfb245e1f38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b29fc153b3a355cae8b15008ec8c1b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a32b29fc153b3a355cae8b15008ec8c1b">is_snarl</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;net) const =0</td></tr>
<tr class="separator:a32b29fc153b3a355cae8b15008ec8c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad383774992bf6a3acc5fd34dc8cd9770"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#ad383774992bf6a3acc5fd34dc8cd9770">is_chain</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;net) const =0</td></tr>
<tr class="separator:ad383774992bf6a3acc5fd34dc8cd9770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f410ac594c7ed44a7cc9b6e44077900"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a6f410ac594c7ed44a7cc9b6e44077900">is_node</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;net) const =0</td></tr>
<tr class="separator:a6f410ac594c7ed44a7cc9b6e44077900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ce2079f249448a8c8a829daedd1678"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#af3ce2079f249448a8c8a829daedd1678">is_sentinel</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;net) const =0</td></tr>
<tr class="separator:af3ce2079f249448a8c8a829daedd1678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b7111bd54f4e95180fffbb32a4fd51"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a07b7111bd54f4e95180fffbb32a4fd51">get_net</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const =0</td></tr>
<tr class="separator:a07b7111bd54f4e95180fffbb32a4fd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab330ba2460721cdc04e76160627d5bec"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#ab330ba2460721cdc04e76160627d5bec">get_handle</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;net) const =0</td></tr>
<tr class="separator:ab330ba2460721cdc04e76160627d5bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb665da6af9e2ccfc10e6e667254b91d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#afb665da6af9e2ccfc10e6e667254b91d">get_parent</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;child) const =0</td></tr>
<tr class="separator:afb665da6af9e2ccfc10e6e667254b91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabee8d2ebb1971ecfd5c4647b84081f2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#aabee8d2ebb1971ecfd5c4647b84081f2">get_bound</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;snarl, bool get_end, bool face_in) const =0</td></tr>
<tr class="separator:aabee8d2ebb1971ecfd5c4647b84081f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a5d5c52aa8622f53f0ef642b6e8649"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#af1a5d5c52aa8622f53f0ef642b6e8649">flip</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;net) const</td></tr>
<tr class="separator:af1a5d5c52aa8622f53f0ef642b6e8649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d44e22e924886450b5fa6eefa58f244"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a4d44e22e924886450b5fa6eefa58f244">canonical</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;net) const</td></tr>
<tr class="separator:a4d44e22e924886450b5fa6eefa58f244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bb78bc95acfd353ff8d6c44915e524"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a17b276026a2c6d99be0f63ffbc92ccd3">endpoint_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#ac6bb78bc95acfd353ff8d6c44915e524">starts_at</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;traversal) const =0</td></tr>
<tr class="separator:ac6bb78bc95acfd353ff8d6c44915e524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f345867fbee2cbcd283e5c0ed4f5920"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a17b276026a2c6d99be0f63ffbc92ccd3">endpoint_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a4f345867fbee2cbcd283e5c0ed4f5920">ends_at</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;traversal) const =0</td></tr>
<tr class="separator:a4f345867fbee2cbcd283e5c0ed4f5920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4790373e0405cc715b0116142aefc42e"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a4790373e0405cc715b0116142aefc42e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a4790373e0405cc715b0116142aefc42e">for_each_child</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;parent, const Iteratee &amp;iteratee) const</td></tr>
<tr class="separator:a4790373e0405cc715b0116142aefc42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64144f35a85a36bb472044663bd3a618"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a64144f35a85a36bb472044663bd3a618"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a64144f35a85a36bb472044663bd3a618">for_each_traversal</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;item, const Iteratee &amp;iteratee) const</td></tr>
<tr class="separator:a64144f35a85a36bb472044663bd3a618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8bfd4be88714e10cf1556fb933e474"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a3e8bfd4be88714e10cf1556fb933e474"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a3e8bfd4be88714e10cf1556fb933e474">follow_net_edges</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;here, bool go_left, const Iteratee &amp;iteratee) const</td></tr>
<tr class="separator:a3e8bfd4be88714e10cf1556fb933e474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28fd7719d52d2148443d31617ae8a3c"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:ac28fd7719d52d2148443d31617ae8a3c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#ac28fd7719d52d2148443d31617ae8a3c">for_each_tippy_child</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;parent, const Iteratee &amp;iteratee) const</td></tr>
<tr class="separator:ac28fd7719d52d2148443d31617ae8a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d73854a9c32d12ee3f4dd2ccefcfd2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a12d73854a9c32d12ee3f4dd2ccefcfd2">get_parent_traversal</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;traversal_start, const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;traversal_end) const</td></tr>
<tr class="separator:a12d73854a9c32d12ee3f4dd2ccefcfd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccdbfddf02159200884e27ae34af0a8"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a0ccdbfddf02159200884e27ae34af0a8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a0ccdbfddf02159200884e27ae34af0a8">for_each_traversal_start</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;traversal, const Iteratee &amp;) const</td></tr>
<tr class="separator:a0ccdbfddf02159200884e27ae34af0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ccef73cd4793c0f303b951352b954b"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:ac7ccef73cd4793c0f303b951352b954b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#ac7ccef73cd4793c0f303b951352b954b">for_each_traversal_end</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;traversal, const Iteratee &amp;) const</td></tr>
<tr class="separator:ac7ccef73cd4793c0f303b951352b954b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63eea99ca9840f16ef358ee664ecda23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a63eea99ca9840f16ef358ee664ecda23">get_start_bound</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;parent) const</td></tr>
<tr class="separator:a63eea99ca9840f16ef358ee664ecda23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c500f039a8740ff6e771ddf4bf693ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a4c500f039a8740ff6e771ddf4bf693ad">get_end_bound</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;parent) const</td></tr>
<tr class="separator:a4c500f039a8740ff6e771ddf4bf693ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1c7cccea8188c8e24a4e53c34117bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#adb1c7cccea8188c8e24a4e53c34117bb">starts_at_start</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;net) const</td></tr>
<tr class="separator:adb1c7cccea8188c8e24a4e53c34117bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab710270e1997f22d1b09a4fd40a3eaf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#aab710270e1997f22d1b09a4fd40a3eaf">starts_at_end</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;net) const</td></tr>
<tr class="separator:aab710270e1997f22d1b09a4fd40a3eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47bc288b1c0303d3356e953de4878e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#ac47bc288b1c0303d3356e953de4878e2">starts_at_tip</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;net) const</td></tr>
<tr class="separator:ac47bc288b1c0303d3356e953de4878e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e795bd9764b2b793472d46069cecab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a63e795bd9764b2b793472d46069cecab">ends_at_start</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;net) const</td></tr>
<tr class="separator:a63e795bd9764b2b793472d46069cecab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f13d153fedcd2e24575fb69672650cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a5f13d153fedcd2e24575fb69672650cd">ends_at_end</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;net) const</td></tr>
<tr class="separator:a5f13d153fedcd2e24575fb69672650cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae397ce26e9c979cf64c18f56546e490c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#ae397ce26e9c979cf64c18f56546e490c">ends_at_tip</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;net) const</td></tr>
<tr class="separator:ae397ce26e9c979cf64c18f56546e490c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8dcbdccb1422d034b16da6ff31412d5a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a8dcbdccb1422d034b16da6ff31412d5a">for_each_child_impl</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;traversal, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;)&gt; &amp;iteratee) const =0</td></tr>
<tr class="separator:a8dcbdccb1422d034b16da6ff31412d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ea5843f70f1550afe868a8fa1bf2ae"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#ac5ea5843f70f1550afe868a8fa1bf2ae">for_each_traversal_impl</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;item, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;)&gt; &amp;iteratee) const =0</td></tr>
<tr class="separator:ac5ea5843f70f1550afe868a8fa1bf2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4565744c6e1db8e5d5d59cedddf67627"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a4565744c6e1db8e5d5d59cedddf67627">follow_net_edges_impl</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;here, bool go_left, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;)&gt; &amp;iteratee) const</td></tr>
<tr class="separator:a4565744c6e1db8e5d5d59cedddf67627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f14086d5470e4a95955e9bc3787574a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a0f14086d5470e4a95955e9bc3787574a">for_each_tippy_child_impl</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;parent, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;)&gt; &amp;iteratee) const</td></tr>
<tr class="separator:a0f14086d5470e4a95955e9bc3787574a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688f4614f5dd84aa01734c5eaf5d0400"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a688f4614f5dd84aa01734c5eaf5d0400">for_each_traversal_start_impl</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;traversal, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;)&gt; &amp;iteratee) const</td></tr>
<tr class="separator:a688f4614f5dd84aa01734c5eaf5d0400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7c6809f7636d1afae03c34e4747179"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a5d7c6809f7636d1afae03c34e4747179">for_each_traversal_end_impl</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;traversal, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;)&gt; &amp;iteratee) const</td></tr>
<tr class="separator:a5d7c6809f7636d1afae03c34e4747179"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a17b276026a2c6d99be0f63ffbc92ccd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b276026a2c6d99be0f63ffbc92ccd3">&#9670;&nbsp;</a></span>endpoint_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a17b276026a2c6d99be0f63ffbc92ccd3">handlegraph::SnarlDecomposition::endpoint_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents a place that a traversal can start or end. Traversals can start or end at the start, end, or an internal tip of the thing they traverse. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a17b276026a2c6d99be0f63ffbc92ccd3ab5854c3018055ccefae586f717850711"></a>START&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a17b276026a2c6d99be0f63ffbc92ccd3aa14d92884083adfe371667c2ce1d70a5"></a>END&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a17b276026a2c6d99be0f63ffbc92ccd3a41062278414d99cdb309732619f1ce5f"></a>TIP&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad5055e48b8816d5785052da55e6da996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5055e48b8816d5785052da55e6da996">&#9670;&nbsp;</a></span>~SnarlDecomposition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual handlegraph::SnarlDecomposition::~SnarlDecomposition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4d44e22e924886450b5fa6eefa58f244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d44e22e924886450b5fa6eefa58f244">&#9670;&nbsp;</a></span>canonical()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> handlegraph::SnarlDecomposition::canonical </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>net</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a canonical traversal handle from any net handle. All handles to the same net graph element have the same canonical traversal. That canonical traversal must be realizable, and might not always be start-to-end or even consistently be the same kind of traversal for different snarls, chains, or nodes. Mostly useful to normalize for equality comparisons. </p>

</div>
</div>
<a id="a4f345867fbee2cbcd283e5c0ed4f5920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f345867fbee2cbcd283e5c0ed4f5920">&#9670;&nbsp;</a></span>ends_at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a17b276026a2c6d99be0f63ffbc92ccd3">endpoint_t</a> handlegraph::SnarlDecomposition::ends_at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>traversal</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the kind of location at which the given traversal ends. </p>

</div>
</div>
<a id="a5f13d153fedcd2e24575fb69672650cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f13d153fedcd2e24575fb69672650cd">&#9670;&nbsp;</a></span>ends_at_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool handlegraph::SnarlDecomposition::ends_at_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>net</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the given net handle describes a category of traversal that ends at the local end of the snarl/chain/node. </p>

</div>
</div>
<a id="a63e795bd9764b2b793472d46069cecab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e795bd9764b2b793472d46069cecab">&#9670;&nbsp;</a></span>ends_at_start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool handlegraph::SnarlDecomposition::ends_at_start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>net</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the given net handle describes a category of traversal that ends at the local start of the snarl/chain/node. </p>

</div>
</div>
<a id="ae397ce26e9c979cf64c18f56546e490c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae397ce26e9c979cf64c18f56546e490c">&#9670;&nbsp;</a></span>ends_at_tip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool handlegraph::SnarlDecomposition::ends_at_tip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>net</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the given net handle describes a category of traversal that ends at the an internal tip in the snarl/chain. Never true for nodes. </p>

</div>
</div>
<a id="af1a5d5c52aa8622f53f0ef642b6e8649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a5d5c52aa8622f53f0ef642b6e8649">&#9670;&nbsp;</a></span>flip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> handlegraph::SnarlDecomposition::flip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>net</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a net handle to the same snarl/chain/node in the opposite orientation. No effect on tip-to-tip, start-to-start, or end-to-end net handles. Flips all the others. </p>

</div>
</div>
<a id="a3e8bfd4be88714e10cf1556fb933e474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e8bfd4be88714e10cf1556fb933e474">&#9670;&nbsp;</a></span>follow_net_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iteratee &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool handlegraph::SnarlDecomposition::follow_net_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>here</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>go_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iteratee &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a net handle to a traversal of a snarl, chain, or node, iterate over all kinds of traversals of all snarls, chains, or nodes that are reachable by going either left or right from the given traversal.</p>
<p>Does not check to see if the given traversal is possible given the internal connectivity of a snarl or chain being traversed.</p>
<p>Does not leave a chain; looking form a node traversal out the end of its chain will produce nothing.</p>
<p>Produces and accepts snarl start and end sentinels, and does not leave a snarl.</p>
<p>If you do want to leave a snarl or a chain, jump up to the parent with <a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a12d73854a9c32d12ee3f4dd2ccefcfd2">get_parent_traversal()</a>. </p>

</div>
</div>
<a id="a4565744c6e1db8e5d5d59cedddf67627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4565744c6e1db8e5d5d59cedddf67627">&#9670;&nbsp;</a></span>follow_net_edges_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handlegraph::SnarlDecomposition::follow_net_edges_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>here</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>go_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal implementation for follow_net_edges. </p>

</div>
</div>
<a id="a4790373e0405cc715b0116142aefc42e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4790373e0405cc715b0116142aefc42e">&#9670;&nbsp;</a></span>for_each_child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iteratee &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool handlegraph::SnarlDecomposition::for_each_child </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iteratee &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loop over the child snarls and nodes of a chain, or the child chains of a snarl. If the parent is a chain and is in start-to-end or end-to-start order, children are produced in the order and orientation they are encountered when viewing the chain that way. Otherwise, children are produced in arbitrary order and start-to-end orientation, even if that is not actually a realizable traversal of a snarl or chain.</p>
<p>Return false from the iteratee to stop, or void or true to keep going. Returns false if iteration was stopped early, and true otherwise. </p>

</div>
</div>
<a id="a8dcbdccb1422d034b16da6ff31412d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dcbdccb1422d034b16da6ff31412d5a">&#9670;&nbsp;</a></span>for_each_child_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handlegraph::SnarlDecomposition::for_each_child_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>traversal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal implementation for for_each_child. </p>

</div>
</div>
<a id="ac28fd7719d52d2148443d31617ae8a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28fd7719d52d2148443d31617ae8a3c">&#9670;&nbsp;</a></span>for_each_tippy_child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iteratee &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool handlegraph::SnarlDecomposition::for_each_tippy_child </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iteratee &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Execute a function on each realizable traversal of a child of the given snarl or chain that begins with an internal tip. Traversals that end with tips are obtained by flipping the results.</p>
<p>TODO: allow to be restricted to those that can e.g. reach the start or end of the parent, or another internal tip. </p>

</div>
</div>
<a id="a0f14086d5470e4a95955e9bc3787574a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f14086d5470e4a95955e9bc3787574a">&#9670;&nbsp;</a></span>for_each_tippy_child_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool handlegraph::SnarlDecomposition::for_each_tippy_child_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal implementation for for_each_tippy_child. </p>

</div>
</div>
<a id="a64144f35a85a36bb472044663bd3a618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64144f35a85a36bb472044663bd3a618">&#9670;&nbsp;</a></span>for_each_traversal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iteratee &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool handlegraph::SnarlDecomposition::for_each_traversal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iteratee &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a net handle to any type of traversal of a snarl, chain, or node, loop over only the types of traversals that are possible. Produces a net handle to the same snarl, chain, or node for each possible combination of traversal starts and ends (start, end, or internal tip) that is permitted by the internal connectivity of the snarl, chain, or node.</p>
<p>Return false from the iteratee to stop, or void or true to keep going. Returns false if iteration was stopped early, and true otherwise. </p>

</div>
</div>
<a id="ac7ccef73cd4793c0f303b951352b954b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ccef73cd4793c0f303b951352b954b">&#9670;&nbsp;</a></span>for_each_traversal_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iteratee &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool handlegraph::SnarlDecomposition::for_each_traversal_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>traversal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iteratee &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loop over all the child net graph item traversals that could potentially end the given traversal. For traversals ending at tips, no guarantee is made that there is a path to the yielded traversals from the overall traversal's initial position. </p>

</div>
</div>
<a id="a5d7c6809f7636d1afae03c34e4747179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7c6809f7636d1afae03c34e4747179">&#9670;&nbsp;</a></span>for_each_traversal_end_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool handlegraph::SnarlDecomposition::for_each_traversal_end_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>traversal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal implementation for for_each_traversal_end. </p>

</div>
</div>
<a id="ac5ea5843f70f1550afe868a8fa1bf2ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ea5843f70f1550afe868a8fa1bf2ae">&#9670;&nbsp;</a></span>for_each_traversal_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handlegraph::SnarlDecomposition::for_each_traversal_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal implementation for for_each_traversal. </p>

</div>
</div>
<a id="a0ccdbfddf02159200884e27ae34af0a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ccdbfddf02159200884e27ae34af0a8">&#9670;&nbsp;</a></span>for_each_traversal_start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iteratee &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool handlegraph::SnarlDecomposition::for_each_traversal_start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>traversal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iteratee &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loop over all the child net graph item traversals that could potentially start the given traversal. For traversals starting at tips, no guarantee is made that there is a path from the yielded traversals to the overall traversal's final destination. </p>

</div>
</div>
<a id="a688f4614f5dd84aa01734c5eaf5d0400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688f4614f5dd84aa01734c5eaf5d0400">&#9670;&nbsp;</a></span>for_each_traversal_start_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool handlegraph::SnarlDecomposition::for_each_traversal_start_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>traversal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal implementation for for_each_traversal_start. </p>

</div>
</div>
<a id="aabee8d2ebb1971ecfd5c4647b84081f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabee8d2ebb1971ecfd5c4647b84081f2">&#9670;&nbsp;</a></span>get_bound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> handlegraph::SnarlDecomposition::get_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>get_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>face_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the bounding handle for the snarl or chain referenced by the given net handle, getting the start or end facing in or out as appropriate.</p>
<p>For snarls, returns the bounding sentinel net handles. For chains, returns net handles for traversals of the bounding nodes of the chain.</p>
<p>Ignores traversal type.</p>
<p>May not be called on traversals of individual nodes. </p>

</div>
</div>
<a id="a4c500f039a8740ff6e771ddf4bf693ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c500f039a8740ff6e771ddf4bf693ad">&#9670;&nbsp;</a></span>get_end_bound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> handlegraph::SnarlDecomposition::get_end_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a handle to the outward-facing traversal of the last node in a chain or the end boundary in a snarl.</p>
<p>This isn't necessarily where the traversal specified by the given handle actually ends (it may be start to start or tip to tip, for example). </p>

</div>
</div>
<a id="ab330ba2460721cdc04e76160627d5bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab330ba2460721cdc04e76160627d5bec">&#9670;&nbsp;</a></span>get_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> handlegraph::SnarlDecomposition::get_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>net</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For a net handle to a traversal of a single node, get the handle for that node in the orientation it is traversed. May not be called for other net handles. </p>

</div>
</div>
<a id="a07b7111bd54f4e95180fffbb32a4fd51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b7111bd54f4e95180fffbb32a4fd51">&#9670;&nbsp;</a></span>get_net()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> handlegraph::SnarlDecomposition::get_net </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Turn a handle to an oriented node into a net handle for a start-to-end or end-to-start traversal of the node, as appropriate. </p>

</div>
</div>
<a id="afb665da6af9e2ccfc10e6e667254b91d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb665da6af9e2ccfc10e6e667254b91d">&#9670;&nbsp;</a></span>get_parent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> handlegraph::SnarlDecomposition::get_parent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the parent snarl of a chain, or the parent chain of a snarl or node. If the child is start-to-end or end-to-start, and the parent is a chain, the chain comes out facing the same way, accounting for the relative orientation of the child snarl or node in the chain. Otherwise, everything is produced as start-to-end, even if that is not actually a realizable traversal of a snarl or chain. May not be called on the root snarl.</p>
<p>Also works on snarl boundary sentinels. </p>

</div>
</div>
<a id="a12d73854a9c32d12ee3f4dd2ccefcfd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d73854a9c32d12ee3f4dd2ccefcfd2">&#9670;&nbsp;</a></span>get_parent_traversal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> handlegraph::SnarlDecomposition::get_parent_traversal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>traversal_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>traversal_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a net handle for traversals of a the snarl or chain that contains the given oriented bounding node traversals or sentinels. Given two sentinels for a snarl, produces a net handle to a start-to-end, end-to-end, end-to-start, or start-to-start traversal of that snarl. Given handles to traversals of the bounding nodes of a chain, similarly produces a net handle to a traversal of the chain.</p>
<p>For a chain, either or both handles can also be a snarl containing tips, for a tip-to-start, tip-to-end, start-to-tip, end-to-tip, or tip-to-tip traversal. Similarly, for a snarl, either or both handles can be a chain in the snarl that contains internal tips, or that has no edges on the appropriate end.</p>
<p>May only be called if a path actually exists between the given start and end. </p>

</div>
</div>
<a id="aa53f4ad10c14ac326d242e6068a53f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53f4ad10c14ac326d242e6068a53f27">&#9670;&nbsp;</a></span>get_root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handlegraph::SnarlDecomposition::get_root </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>net</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a net handle referring to a tip-to-tip traversal of the contents of the root snarl. TODO: Special handling for circular things in the root snarl? Circular traversal type? </p>

</div>
</div>
<a id="a63eea99ca9840f16ef358ee664ecda23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63eea99ca9840f16ef358ee664ecda23">&#9670;&nbsp;</a></span>get_start_bound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> handlegraph::SnarlDecomposition::get_start_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a handle to the inward-facing traversal of the first node in a chain or the start boundary in a snarl.</p>
<p>This isn't necessarily where the traversal specified by the given handle actually starts (it may be end to end or tip to tip, for example). </p>

</div>
</div>
<a id="ad383774992bf6a3acc5fd34dc8cd9770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad383774992bf6a3acc5fd34dc8cd9770">&#9670;&nbsp;</a></span>is_chain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handlegraph::SnarlDecomposition::is_chain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>net</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the given net handle refers to (a traversal of) a chain. </p>

</div>
</div>
<a id="a6f410ac594c7ed44a7cc9b6e44077900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f410ac594c7ed44a7cc9b6e44077900">&#9670;&nbsp;</a></span>is_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handlegraph::SnarlDecomposition::is_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>net</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the given net handle refers to (a traversal of) a single node, and thus has a corresponding <a class="el" href="structhandlegraph_1_1handle__t.html" title="Represents a traversal of a node in a graph in a particular direction.">handle_t</a>. </p>

</div>
</div>
<a id="afef6c85a6564d6d3ec65bfb245e1f38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef6c85a6564d6d3ec65bfb245e1f38c">&#9670;&nbsp;</a></span>is_root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handlegraph::SnarlDecomposition::is_root </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>net</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the given handle refers to (a traversal of) the root snarl, and false otherwise. </p>

</div>
</div>
<a id="af3ce2079f249448a8c8a829daedd1678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ce2079f249448a8c8a829daedd1678">&#9670;&nbsp;</a></span>is_sentinel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handlegraph::SnarlDecomposition::is_sentinel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>net</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the given net handle is a snarl bound sentinel (in either inward or outward orientation), and false otherwise. </p>

</div>
</div>
<a id="a32b29fc153b3a355cae8b15008ec8c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b29fc153b3a355cae8b15008ec8c1b">&#9670;&nbsp;</a></span>is_snarl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handlegraph::SnarlDecomposition::is_snarl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>net</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the given net handle refers to (a traversal of) a snarl. </p>

</div>
</div>
<a id="ac6bb78bc95acfd353ff8d6c44915e524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6bb78bc95acfd353ff8d6c44915e524">&#9670;&nbsp;</a></span>starts_at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classhandlegraph_1_1SnarlDecomposition.html#a17b276026a2c6d99be0f63ffbc92ccd3">endpoint_t</a> handlegraph::SnarlDecomposition::starts_at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>traversal</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the kind of location at which the given traversal starts. </p>

</div>
</div>
<a id="aab710270e1997f22d1b09a4fd40a3eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab710270e1997f22d1b09a4fd40a3eaf">&#9670;&nbsp;</a></span>starts_at_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool handlegraph::SnarlDecomposition::starts_at_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>net</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the given net handle describes a category of traversal that starts at the local end of the snarl/chain/node. </p>

</div>
</div>
<a id="adb1c7cccea8188c8e24a4e53c34117bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb1c7cccea8188c8e24a4e53c34117bb">&#9670;&nbsp;</a></span>starts_at_start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool handlegraph::SnarlDecomposition::starts_at_start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>net</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the given net handle describes a category of traversal that starts at the local start of the snarl/chain/node. </p>

</div>
</div>
<a id="ac47bc288b1c0303d3356e953de4878e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47bc288b1c0303d3356e953de4878e2">&#9670;&nbsp;</a></span>starts_at_tip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool handlegraph::SnarlDecomposition::starts_at_tip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>net</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the given net handle describes a category of traversal that starts at an internal tip in the snarl/chain. Never true for nodes. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>deps/libhandlegraph/src/include/handlegraph/<a class="el" href="snarl__decomposition_8hpp.html">snarl_decomposition.hpp</a></li>
<li>deps/libhandlegraph/src/<a class="el" href="snarl__decomposition_8cpp.html">snarl_decomposition.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
