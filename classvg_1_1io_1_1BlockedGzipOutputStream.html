<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::io::BlockedGzipOutputStream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="namespacevg_1_1io.html">io</a></li><li class="navelem"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classvg_1_1io_1_1BlockedGzipOutputStream-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::io::BlockedGzipOutputStream Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;blocked_gzip_output_stream.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vg::io::BlockedGzipOutputStream:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvg_1_1io_1_1BlockedGzipOutputStream.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2277edf73df28a4da63b44157ef4a904"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#a2277edf73df28a4da63b44157ef4a904">BlockedGzipOutputStream</a> (BGZF *bgzf_handle)</td></tr>
<tr class="separator:a2277edf73df28a4da63b44157ef4a904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861f784237f0656f67956acd6e55022b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#a861f784237f0656f67956acd6e55022b">BlockedGzipOutputStream</a> (std::ostream &amp;stream)</td></tr>
<tr class="separator:a861f784237f0656f67956acd6e55022b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac9002de6d983cb46a36b44620448bb"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#aaac9002de6d983cb46a36b44620448bb">~BlockedGzipOutputStream</a> ()</td></tr>
<tr class="memdesc:aaac9002de6d983cb46a36b44620448bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the stream, finishing all writes if necessary.  <a href="classvg_1_1io_1_1BlockedGzipOutputStream.html#aaac9002de6d983cb46a36b44620448bb">More...</a><br /></td></tr>
<tr class="separator:aaac9002de6d983cb46a36b44620448bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c69ba0487ee2cd5e6da92b7225d01f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#a2c69ba0487ee2cd5e6da92b7225d01f0">BlockedGzipOutputStream</a> (const <a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a> &amp;other)=delete</td></tr>
<tr class="separator:a2c69ba0487ee2cd5e6da92b7225d01f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26746003c36d4c51964fe291412c48a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#a26746003c36d4c51964fe291412c48a0">operator=</a> (const <a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a> &amp;other)=delete</td></tr>
<tr class="separator:a26746003c36d4c51964fe291412c48a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68648f5c06ce291e3daafb993c9b71c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#ae68648f5c06ce291e3daafb993c9b71c">BlockedGzipOutputStream</a> (<a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a> &amp;&amp;other)=delete</td></tr>
<tr class="separator:ae68648f5c06ce291e3daafb993c9b71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54f16684d6a1f7ea66cf57ab0a481f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#ae54f16684d6a1f7ea66cf57ab0a481f9">operator=</a> (<a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a> &amp;&amp;other)=delete</td></tr>
<tr class="separator:ae54f16684d6a1f7ea66cf57ab0a481f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3e80161a999b884abf3965dd0a5a39"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#a0c3e80161a999b884abf3965dd0a5a39">Next</a> (void **data, int *size)</td></tr>
<tr class="separator:a0c3e80161a999b884abf3965dd0a5a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a333a1aed4a53ff6d1619f2a48be0de"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#a2a333a1aed4a53ff6d1619f2a48be0de">BackUp</a> (int count)</td></tr>
<tr class="separator:a2a333a1aed4a53ff6d1619f2a48be0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35058523e5b100a0c55af4f4371544a7"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#a35058523e5b100a0c55af4f4371544a7">ByteCount</a> () const</td></tr>
<tr class="memdesc:a35058523e5b100a0c55af4f4371544a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes written since the stream was constructed.  <a href="classvg_1_1io_1_1BlockedGzipOutputStream.html#a35058523e5b100a0c55af4f4371544a7">More...</a><br /></td></tr>
<tr class="separator:a35058523e5b100a0c55af4f4371544a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d9e1ca69d7bad9e2941b7ecec08a42"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#a85d9e1ca69d7bad9e2941b7ecec08a42">WriteAliasedRaw</a> (const void *data, int size)</td></tr>
<tr class="separator:a85d9e1ca69d7bad9e2941b7ecec08a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30901e7d779acdfef65858e98baaf3f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#ac30901e7d779acdfef65858e98baaf3f">AllowsAliasing</a> () const</td></tr>
<tr class="memdesc:ac30901e7d779acdfef65858e98baaf3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#a85d9e1ca69d7bad9e2941b7ecec08a42">WriteAliasedRaw()</a> is actually available, and false otherwise.  <a href="classvg_1_1io_1_1BlockedGzipOutputStream.html#ac30901e7d779acdfef65858e98baaf3f">More...</a><br /></td></tr>
<tr class="separator:ac30901e7d779acdfef65858e98baaf3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bb042b0a5df4ecbdadb3852fa04f91"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#a84bb042b0a5df4ecbdadb3852fa04f91">Tell</a> ()</td></tr>
<tr class="separator:a84bb042b0a5df4ecbdadb3852fa04f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf788a0a0553f9cc0c531fecb941f228"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#aaf788a0a0553f9cc0c531fecb941f228">StartFile</a> ()</td></tr>
<tr class="separator:aaf788a0a0553f9cc0c531fecb941f228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6cf204591880e126bacc2d01799f3e6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#aa6cf204591880e126bacc2d01799f3e6">EndFile</a> ()</td></tr>
<tr class="separator:aa6cf204591880e126bacc2d01799f3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2d51e5f860d576390722d3f80e6417"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#a9e2d51e5f860d576390722d3f80e6417">Flush</a> ()</td></tr>
<tr class="separator:a9e2d51e5f860d576390722d3f80e6417"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad9f92e40584b24a5f1ff20750826bfe7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#ad9f92e40584b24a5f1ff20750826bfe7">flush_self</a> ()</td></tr>
<tr class="separator:ad9f92e40584b24a5f1ff20750826bfe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac677874552857f22f89ee9571eb183db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#ac677874552857f22f89ee9571eb183db">force_close</a> ()</td></tr>
<tr class="separator:ac677874552857f22f89ee9571eb183db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a726e457d2e98e4ca6ffa742a4378949f"><td class="memItemLeft" align="right" valign="top">BGZF *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#a726e457d2e98e4ca6ffa742a4378949f">handle</a></td></tr>
<tr class="memdesc:a726e457d2e98e4ca6ffa742a4378949f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The open BGZF handle being written to.  <a href="classvg_1_1io_1_1BlockedGzipOutputStream.html#a726e457d2e98e4ca6ffa742a4378949f">More...</a><br /></td></tr>
<tr class="separator:a726e457d2e98e4ca6ffa742a4378949f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d9a1a0917016a7af46f2960608d302"><td class="memItemLeft" align="right" valign="top">hFILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#a14d9a1a0917016a7af46f2960608d302">wrapped_ostream</a></td></tr>
<tr class="separator:a14d9a1a0917016a7af46f2960608d302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5cfa13ff5e0449e105a0d9117aa38f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#aab5cfa13ff5e0449e105a0d9117aa38f">buffer</a></td></tr>
<tr class="memdesc:aab5cfa13ff5e0449e105a0d9117aa38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This vector will own the memory we use as our void* buffer.  <a href="classvg_1_1io_1_1BlockedGzipOutputStream.html#aab5cfa13ff5e0449e105a0d9117aa38f">More...</a><br /></td></tr>
<tr class="separator:aab5cfa13ff5e0449e105a0d9117aa38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a0e513c0dbdb75df3eccd7171f7126"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#a29a0e513c0dbdb75df3eccd7171f7126">backed_up</a></td></tr>
<tr class="memdesc:a29a0e513c0dbdb75df3eccd7171f7126"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of characters that have been backed up from the end of the buffer.  <a href="classvg_1_1io_1_1BlockedGzipOutputStream.html#a29a0e513c0dbdb75df3eccd7171f7126">More...</a><br /></td></tr>
<tr class="separator:a29a0e513c0dbdb75df3eccd7171f7126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745da931cd84709a1a8b8f64e357d2fb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#a745da931cd84709a1a8b8f64e357d2fb">byte_count</a></td></tr>
<tr class="memdesc:a745da931cd84709a1a8b8f64e357d2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The counter to back ByteCount.  <a href="classvg_1_1io_1_1BlockedGzipOutputStream.html#a745da931cd84709a1a8b8f64e357d2fb">More...</a><br /></td></tr>
<tr class="separator:a745da931cd84709a1a8b8f64e357d2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88df3ee23df1392e53453f82b1859e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#ae88df3ee23df1392e53453f82b1859e2">know_offset</a></td></tr>
<tr class="memdesc:ae88df3ee23df1392e53453f82b1859e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for whether our backing stream is tellable.  <a href="classvg_1_1io_1_1BlockedGzipOutputStream.html#ae88df3ee23df1392e53453f82b1859e2">More...</a><br /></td></tr>
<tr class="separator:ae88df3ee23df1392e53453f82b1859e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31df557e0da72dbd81c865855454e25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#ad31df557e0da72dbd81c865855454e25">end_file</a></td></tr>
<tr class="memdesc:ad31df557e0da72dbd81c865855454e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for whether we are supposed to close out the BGZF file.  <a href="classvg_1_1io_1_1BlockedGzipOutputStream.html#ad31df557e0da72dbd81c865855454e25">More...</a><br /></td></tr>
<tr class="separator:ad31df557e0da72dbd81c865855454e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Protobuf-style ZeroCopyOutputStream that writes data in blocked gzip format, and allows interacting with virtual offsets. Does NOT emit the BGZF end-of-file marker unless told to, because we don't want an empty block after every vg <a class="el" href="namespacevg_1_1io.html#a1b6b275aeefcf193d8d25a6b3b7b8f11">io::write</a> call. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2277edf73df28a4da63b44157ef4a904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2277edf73df28a4da63b44157ef4a904">&#9670;&nbsp;</a></span>BlockedGzipOutputStream() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::io::BlockedGzipOutputStream::BlockedGzipOutputStream </td>
          <td>(</td>
          <td class="paramtype">BGZF *&#160;</td>
          <td class="paramname"><em>bgzf_handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a new stream outputting to the given open BGZF file handle. The stream will own the BGZF file and close it when destructed. Note that with this constructor we have no access to the backing hFILE*, so <a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#a9e2d51e5f860d576390722d3f80e6417">Flush()</a> will not be able to flush it. </p>

</div>
</div>
<a id="a861f784237f0656f67956acd6e55022b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861f784237f0656f67956acd6e55022b">&#9670;&nbsp;</a></span>BlockedGzipOutputStream() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::io::BlockedGzipOutputStream::BlockedGzipOutputStream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a new stream outputting to the given C++ std::ostream, wrapping it in a BGZF. </p>

</div>
</div>
<a id="aaac9002de6d983cb46a36b44620448bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac9002de6d983cb46a36b44620448bb">&#9670;&nbsp;</a></span>~BlockedGzipOutputStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::io::BlockedGzipOutputStream::~BlockedGzipOutputStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the stream, finishing all writes if necessary. </p>

</div>
</div>
<a id="a2c69ba0487ee2cd5e6da92b7225d01f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c69ba0487ee2cd5e6da92b7225d01f0">&#9670;&nbsp;</a></span>BlockedGzipOutputStream() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::io::BlockedGzipOutputStream::BlockedGzipOutputStream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae68648f5c06ce291e3daafb993c9b71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68648f5c06ce291e3daafb993c9b71c">&#9670;&nbsp;</a></span>BlockedGzipOutputStream() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::io::BlockedGzipOutputStream::BlockedGzipOutputStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac30901e7d779acdfef65858e98baaf3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30901e7d779acdfef65858e98baaf3f">&#9670;&nbsp;</a></span>AllowsAliasing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::BlockedGzipOutputStream::AllowsAliasing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if <a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#a85d9e1ca69d7bad9e2941b7ecec08a42">WriteAliasedRaw()</a> is actually available, and false otherwise. </p>

</div>
</div>
<a id="a2a333a1aed4a53ff6d1619f2a48be0de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a333a1aed4a53ff6d1619f2a48be0de">&#9670;&nbsp;</a></span>BackUp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::BlockedGzipOutputStream::BackUp </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When called after <a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#a0c3e80161a999b884abf3965dd0a5a39">Next()</a>, mark the last count bytes of the buffer that <a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#a0c3e80161a999b884abf3965dd0a5a39">Next()</a> produced as not to be written to the output. The user must not have touched those bytes. </p>

</div>
</div>
<a id="a35058523e5b100a0c55af4f4371544a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35058523e5b100a0c55af4f4371544a7">&#9670;&nbsp;</a></span>ByteCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::io::BlockedGzipOutputStream::ByteCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of bytes written since the stream was constructed. </p>

</div>
</div>
<a id="aa6cf204591880e126bacc2d01799f3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6cf204591880e126bacc2d01799f3e6">&#9670;&nbsp;</a></span>EndFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::BlockedGzipOutputStream::EndFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make this <a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a> write the BGZF-required empty end of file block, when it finishes writing to the BGZF. These blocks are permitted in the interior of files, but we don't want to add them all the time because they're superfluous and they are supposed to be EOF indicators while we are supposed to be able to append data to a file in progress. </p>

</div>
</div>
<a id="a9e2d51e5f860d576390722d3f80e6417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e2d51e5f860d576390722d3f80e6417">&#9670;&nbsp;</a></span>Flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::BlockedGzipOutputStream::Flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Throws on failure. On success, the object used to construct this stream (i.e. the backing BGZF or ostream) will have all data previously written to this stream in its buffers. Flushes backing BGZFs but not backing ostreams. Flushes any intermediate streams we created. </p>

</div>
</div>
<a id="ad9f92e40584b24a5f1ff20750826bfe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f92e40584b24a5f1ff20750826bfe7">&#9670;&nbsp;</a></span>flush_self()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::BlockedGzipOutputStream::flush_self </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Actually dump the buffer data to the BGZF, if needed. Sadly, we can't really be zero-copy because the BGZF library isn't. Does <em>NOT</em> make the BGZF flush and finish its block. </p>

</div>
</div>
<a id="ac677874552857f22f89ee9571eb183db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac677874552857f22f89ee9571eb183db">&#9670;&nbsp;</a></span>force_close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::BlockedGzipOutputStream::force_close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Force the BGZF handle closed without letting the library write its EOF marker. TODO: This is necessarily a hack that depends strongly on htslib internals. Should not be called unless data has been flushed into the BGZF. </p>

</div>
</div>
<a id="a0c3e80161a999b884abf3965dd0a5a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c3e80161a999b884abf3965dd0a5a39">&#9670;&nbsp;</a></span>Next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::BlockedGzipOutputStream::Next </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a buffer to write to. Saves the address of the buffer where data points, and the size of the buffer where size points. Returns false on an unrecoverable error, and true if a buffer was gotten. The stream is responsible for making sure data in the buffer makes it into the output. The data pointer must be valid until the next write call or until the stream is destroyed. </p>

</div>
</div>
<a id="ae54f16684d6a1f7ea66cf57ab0a481f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae54f16684d6a1f7ea66cf57ab0a481f9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a>&amp; vg::io::BlockedGzipOutputStream::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a26746003c36d4c51964fe291412c48a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26746003c36d4c51964fe291412c48a0">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a>&amp; vg::io::BlockedGzipOutputStream::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf788a0a0553f9cc0c531fecb941f228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf788a0a0553f9cc0c531fecb941f228">&#9670;&nbsp;</a></span>StartFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::BlockedGzipOutputStream::StartFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tell this <a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a> that it is at the beginning of a file, when the backing stream is unseekable. Must be called before anything has been written. Enables <a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#a84bb042b0a5df4ecbdadb3852fa04f91">Tell()</a> and sets the current virtual offset to 0. </p>

</div>
</div>
<a id="a84bb042b0a5df4ecbdadb3852fa04f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84bb042b0a5df4ecbdadb3852fa04f91">&#9670;&nbsp;</a></span>Tell()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::io::BlockedGzipOutputStream::Tell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the blocked gzip virtual offset at which the next buffer returned by <a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#a0c3e80161a999b884abf3965dd0a5a39">Next()</a> will start, or -1 if operating on an untellable stream like standard output. Note that this will only get you the position of the next write if anything you are writing through is fully backed up to the next actually-unwritten byte. See Protobuf's CodedOutputStream::Trim(). Not const because buffered data may need to be sent to the compressor to get the virtual offset. </p>

</div>
</div>
<a id="a85d9e1ca69d7bad9e2941b7ecec08a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d9e1ca69d7bad9e2941b7ecec08a42">&#9670;&nbsp;</a></span>WriteAliasedRaw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::BlockedGzipOutputStream::WriteAliasedRaw </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Take the given data at the given address into the stream as written. Only works if <a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html#ac30901e7d779acdfef65858e98baaf3f" title="Return true if WriteAliasedRaw() is actually available, and false otherwise.">AllowsAliasing()</a> returns true. Returns true on success, and false on an unrecoverable error. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a29a0e513c0dbdb75df3eccd7171f7126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a0e513c0dbdb75df3eccd7171f7126">&#9670;&nbsp;</a></span>backed_up</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::io::BlockedGzipOutputStream::backed_up</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of characters that have been backed up from the end of the buffer. </p>

</div>
</div>
<a id="aab5cfa13ff5e0449e105a0d9117aa38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5cfa13ff5e0449e105a0d9117aa38f">&#9670;&nbsp;</a></span>buffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;char&gt; vg::io::BlockedGzipOutputStream::buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This vector will own the memory we use as our void* buffer. </p>

</div>
</div>
<a id="a745da931cd84709a1a8b8f64e357d2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745da931cd84709a1a8b8f64e357d2fb">&#9670;&nbsp;</a></span>byte_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::io::BlockedGzipOutputStream::byte_count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The counter to back ByteCount. </p>

</div>
</div>
<a id="ad31df557e0da72dbd81c865855454e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31df557e0da72dbd81c865855454e25">&#9670;&nbsp;</a></span>end_file</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::BlockedGzipOutputStream::end_file</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag for whether we are supposed to close out the BGZF file. </p>

</div>
</div>
<a id="a726e457d2e98e4ca6ffa742a4378949f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726e457d2e98e4ca6ffa742a4378949f">&#9670;&nbsp;</a></span>handle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BGZF* vg::io::BlockedGzipOutputStream::handle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The open BGZF handle being written to. </p>

</div>
</div>
<a id="ae88df3ee23df1392e53453f82b1859e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88df3ee23df1392e53453f82b1859e2">&#9670;&nbsp;</a></span>know_offset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::BlockedGzipOutputStream::know_offset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag for whether our backing stream is tellable. </p>

</div>
</div>
<a id="a14d9a1a0917016a7af46f2960608d302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d9a1a0917016a7af46f2960608d302">&#9670;&nbsp;</a></span>wrapped_ostream</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hFILE* vg::io::BlockedGzipOutputStream::wrapped_ostream</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The hFILE* created to connect the BGZF to the ostream, if we are based on an ostream. Really owned by the BGZF, we just need to be able to flush it since the BGZF's flush doesn't do that. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>deps/libvgio/include/vg/io/<a class="el" href="blocked__gzip__output__stream_8hpp.html">blocked_gzip_output_stream.hpp</a></li>
<li>deps/libvgio/src/<a class="el" href="blocked__gzip__output__stream_8cpp.html">blocked_gzip_output_stream.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
