<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::PathIndex Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="structvg_1_1PathIndex.html">PathIndex</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="structvg_1_1PathIndex-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::PathIndex Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;path_index.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0a0f36c0f57cc92dfb70f05eb4e5c482"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#a0a0f36c0f57cc92dfb70f05eb4e5c482">iterator</a> = map&lt; size_t, <a class="el" href="classvg_1_1NodeSide.html">vg::NodeSide</a> &gt;::const_iterator</td></tr>
<tr class="memdesc:a0a0f36c0f57cc92dfb70f05eb4e5c482"><td class="mdescLeft">&#160;</td><td class="mdescRight">We keep iterators to node occurrences along the ref path.  <a href="structvg_1_1PathIndex.html#a0a0f36c0f57cc92dfb70f05eb4e5c482">More...</a><br /></td></tr>
<tr class="separator:a0a0f36c0f57cc92dfb70f05eb4e5c482"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac9bdc9df55bcad668ab35b713c366994"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#ac9bdc9df55bcad668ab35b713c366994">PathIndex</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="memdesc:ac9bdc9df55bcad668ab35b713c366994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index just a path.  <a href="structvg_1_1PathIndex.html#ac9bdc9df55bcad668ab35b713c366994">More...</a><br /></td></tr>
<tr class="separator:ac9bdc9df55bcad668ab35b713c366994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99878fd10f43e040987e334a70d22d87"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#a99878fd10f43e040987e334a70d22d87">PathIndex</a> (const list&lt; <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &gt; &amp;mappings)</td></tr>
<tr class="memdesc:a99878fd10f43e040987e334a70d22d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index just a list of mappings.  <a href="structvg_1_1PathIndex.html#a99878fd10f43e040987e334a70d22d87">More...</a><br /></td></tr>
<tr class="separator:a99878fd10f43e040987e334a70d22d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e9971a2ddb597ea1c229659b9c9b93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#a91e9971a2ddb597ea1c229659b9c9b93">PathIndex</a> (const list&lt; <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &gt; &amp;mappings, <a class="el" href="classvg_1_1VG.html">VG</a> &amp;vg)</td></tr>
<tr class="separator:a91e9971a2ddb597ea1c229659b9c9b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ba06ae7c3fed7abba0cbe2dd6cac88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#a72ba06ae7c3fed7abba0cbe2dd6cac88">PathIndex</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph)</td></tr>
<tr class="memdesc:a72ba06ae7c3fed7abba0cbe2dd6cac88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index a path and pull sequence from a graph.  <a href="structvg_1_1PathIndex.html#a72ba06ae7c3fed7abba0cbe2dd6cac88">More...</a><br /></td></tr>
<tr class="separator:a72ba06ae7c3fed7abba0cbe2dd6cac88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b82679a8d5040f0160edc008d8b348d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#a9b82679a8d5040f0160edc008d8b348d">PathIndex</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;vg, const string &amp;path_name, bool extract_sequence=false)</td></tr>
<tr class="memdesc:a9b82679a8d5040f0160edc008d8b348d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="structvg_1_1PathIndex.html">PathIndex</a> from a path in a graph.  <a href="structvg_1_1PathIndex.html#a9b82679a8d5040f0160edc008d8b348d">More...</a><br /></td></tr>
<tr class="separator:a9b82679a8d5040f0160edc008d8b348d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a67933e88510cd99800348eb40aa57"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#a88a67933e88510cd99800348eb40aa57">PathIndex</a> (const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;graph, const string &amp;path_name, bool extract_sequence=false)</td></tr>
<tr class="memdesc:a88a67933e88510cd99800348eb40aa57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="structvg_1_1PathIndex.html">PathIndex</a> from a path in an indexed graph.  <a href="structvg_1_1PathIndex.html#a88a67933e88510cd99800348eb40aa57">More...</a><br /></td></tr>
<tr class="separator:a88a67933e88510cd99800348eb40aa57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783b7aafb86a509a3434c10b5ae9355f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#a783b7aafb86a509a3434c10b5ae9355f">update_mapping_positions</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;vg, const string &amp;path_name)</td></tr>
<tr class="separator:a783b7aafb86a509a3434c10b5ae9355f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1c5d586bdef0e4cdc31ed7531eee7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#aab1c5d586bdef0e4cdc31ed7531eee7c">at_position</a> (size_t position) const</td></tr>
<tr class="separator:aab1c5d586bdef0e4cdc31ed7531eee7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bb8b7aec345a4b59242287ae1693c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#ab1bb8b7aec345a4b59242287ae1693c7">path_contains_node</a> (int64_t node_id) const</td></tr>
<tr class="memdesc:ab1bb8b7aec345a4b59242287ae1693c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a node is on the reference path.  <a href="structvg_1_1PathIndex.html#ab1bb8b7aec345a4b59242287ae1693c7">More...</a><br /></td></tr>
<tr class="separator:ab1bb8b7aec345a4b59242287ae1693c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dbda80790b6d81aa0f9d83ac21f85a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#a0dbda80790b6d81aa0f9d83ac21f85a3">path_contains_node_in_orientation</a> (int64_t node_id, bool is_reverse) const</td></tr>
<tr class="memdesc:a0dbda80790b6d81aa0f9d83ac21f85a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a node is on the reference path in a given path-relative orientation.  <a href="structvg_1_1PathIndex.html#a0dbda80790b6d81aa0f9d83ac21f85a3">More...</a><br /></td></tr>
<tr class="separator:a0dbda80790b6d81aa0f9d83ac21f85a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7f7bbcd256a2ed34a58b8abefff712"><td class="memItemLeft" align="right" valign="top">pair&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#a6a7f7bbcd256a2ed34a58b8abefff712">get_contained_orientations</a> (int64_t node_id) const</td></tr>
<tr class="separator:a6a7f7bbcd256a2ed34a58b8abefff712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae448ae2af8e4073b9db8b678e3b97e00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1PathIndex.html#a0a0f36c0f57cc92dfb70f05eb4e5c482">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#ae448ae2af8e4073b9db8b678e3b97e00">find_in_orientation</a> (int64_t node_id, bool is_reverse) const</td></tr>
<tr class="memdesc:ae448ae2af8e4073b9db8b678e3b97e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first occurrence of the given node in the given orientation.  <a href="structvg_1_1PathIndex.html#ae448ae2af8e4073b9db8b678e3b97e00">More...</a><br /></td></tr>
<tr class="separator:ae448ae2af8e4073b9db8b678e3b97e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad239d0a2fb9bbbddce753a6c3cf639ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1PathIndex.html#a0a0f36c0f57cc92dfb70f05eb4e5c482">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#ad239d0a2fb9bbbddce753a6c3cf639ed">begin</a> () const</td></tr>
<tr class="memdesc:ad239d0a2fb9bbbddce753a6c3cf639ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the iterator to the first node occurrence on the indexed path.  <a href="structvg_1_1PathIndex.html#ad239d0a2fb9bbbddce753a6c3cf639ed">More...</a><br /></td></tr>
<tr class="separator:ad239d0a2fb9bbbddce753a6c3cf639ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3ccf7b77f16b46373ff5bb19fdbc11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1PathIndex.html#a0a0f36c0f57cc92dfb70f05eb4e5c482">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#ada3ccf7b77f16b46373ff5bb19fdbc11">end</a> () const</td></tr>
<tr class="memdesc:ada3ccf7b77f16b46373ff5bb19fdbc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the iterator to the last node occurrence on the indexed path.  <a href="structvg_1_1PathIndex.html#ada3ccf7b77f16b46373ff5bb19fdbc11">More...</a><br /></td></tr>
<tr class="separator:ada3ccf7b77f16b46373ff5bb19fdbc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377bc15c246c708fe4a0264cb05588af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1PathIndex.html#a0a0f36c0f57cc92dfb70f05eb4e5c482">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#a377bc15c246c708fe4a0264cb05588af">find_position</a> (size_t position) const</td></tr>
<tr class="separator:a377bc15c246c708fe4a0264cb05588af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398380d0a0f4b4fefc15eef8b37cd2f3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#a398380d0a0f4b4fefc15eef8b37cd2f3">node_length</a> (const <a class="el" href="structvg_1_1PathIndex.html#a0a0f36c0f57cc92dfb70f05eb4e5c482">iterator</a> &amp;here) const</td></tr>
<tr class="separator:a398380d0a0f4b4fefc15eef8b37cd2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02dd3e22c5b29670ef48b6f725a9797"><td class="memItemLeft" align="right" valign="top">pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#ac02dd3e22c5b29670ef48b6f725a9797">round_outward</a> (size_t start, size_t past_end) const</td></tr>
<tr class="separator:ac02dd3e22c5b29670ef48b6f725a9797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827ae5af1330e03a23c35351d3152f03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#a827ae5af1330e03a23c35351d3152f03">apply_translation</a> (const <a class="el" href="structvg_1_1Translation.html">Translation</a> &amp;translation)</td></tr>
<tr class="separator:a827ae5af1330e03a23c35351d3152f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aeebd524dc064af4cdda9fd84de2a4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#a8aeebd524dc064af4cdda9fd84de2a4a">apply_translations</a> (const vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt; &amp;translations)</td></tr>
<tr class="separator:a8aeebd524dc064af4cdda9fd84de2a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a3f5697a5db586a467dc4923e2cccbfe1"><td class="memItemLeft" align="right" valign="top">map&lt; int64_t, pair&lt; size_t, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#a3f5697a5db586a467dc4923e2cccbfe1">by_id</a></td></tr>
<tr class="separator:a3f5697a5db586a467dc4923e2cccbfe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55cb6181f7b4b80016aaf2fefbb402c2"><td class="memItemLeft" align="right" valign="top">map&lt; size_t, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#a55cb6181f7b4b80016aaf2fefbb402c2">by_start</a></td></tr>
<tr class="separator:a55cb6181f7b4b80016aaf2fefbb402c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b807b5252299d9b0f1c9168079a591f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#a0b807b5252299d9b0f1c9168079a591f">sequence</a></td></tr>
<tr class="memdesc:a0b807b5252299d9b0f1c9168079a591f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual sequence of the path, if desired.  <a href="structvg_1_1PathIndex.html#a0b807b5252299d9b0f1c9168079a591f">More...</a><br /></td></tr>
<tr class="separator:a0b807b5252299d9b0f1c9168079a591f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0b1da5ad0b4f428ceb623a4d3f806f"><td class="memItemLeft" align="right" valign="top">map&lt; const <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> *, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#acc0b1da5ad0b4f428ceb623a4d3f806f">mapping_positions</a></td></tr>
<tr class="separator:acc0b1da5ad0b4f428ceb623a4d3f806f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa5272234ddb7686f1ae88881ebf99a61"><td class="memItemLeft" align="right" valign="top">map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, vector&lt; <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#aa5272234ddb7686f1ae88881ebf99a61">parse_translation</a> (const <a class="el" href="structvg_1_1Translation.html">Translation</a> &amp;translation)</td></tr>
<tr class="separator:aa5272234ddb7686f1ae88881ebf99a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8806eb31bcd8b8f9305180fea7b746f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#ae8806eb31bcd8b8f9305180fea7b746f">replace_occurrence</a> (<a class="el" href="structvg_1_1PathIndex.html#a0a0f36c0f57cc92dfb70f05eb4e5c482">iterator</a> to_replace, const vector&lt; <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &gt; &amp;replacements)</td></tr>
<tr class="separator:ae8806eb31bcd8b8f9305180fea7b746f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ac64a3532df12093eeccf3201184ea4d9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#ac64a3532df12093eeccf3201184ea4d9">last_node_length</a></td></tr>
<tr class="separator:ac64a3532df12093eeccf3201184ea4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057c79ab3b7c3d4a2827af2e7698b1f1"><td class="memItemLeft" align="right" valign="top">map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, vector&lt; <a class="el" href="structvg_1_1PathIndex.html#a0a0f36c0f57cc92dfb70f05eb4e5c482">iterator</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html#a057c79ab3b7c3d4a2827af2e7698b1f1">node_occurrences</a></td></tr>
<tr class="separator:a057c79ab3b7c3d4a2827af2e7698b1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Holds indexes of the reference in a graph: position to node, node to position and orientation, and the full reference string. Also knows about the lengths of nodes on the path, and lets you iterate back and forth over it. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a0a0f36c0f57cc92dfb70f05eb4e5c482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a0f36c0f57cc92dfb70f05eb4e5c482">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structvg_1_1PathIndex.html#a0a0f36c0f57cc92dfb70f05eb4e5c482">vg::PathIndex::iterator</a> =  map&lt;size_t, <a class="el" href="classvg_1_1NodeSide.html">vg::NodeSide</a>&gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We keep iterators to node occurrences along the ref path. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac9bdc9df55bcad668ab35b713c366994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9bdc9df55bcad668ab35b713c366994">&#9670;&nbsp;</a></span>PathIndex() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::PathIndex::PathIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index just a path. </p>

</div>
</div>
<a id="a99878fd10f43e040987e334a70d22d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99878fd10f43e040987e334a70d22d87">&#9670;&nbsp;</a></span>PathIndex() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::PathIndex::PathIndex </td>
          <td>(</td>
          <td class="paramtype">const list&lt; <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index just a list of mappings. </p>

</div>
</div>
<a id="a91e9971a2ddb597ea1c229659b9c9b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e9971a2ddb597ea1c229659b9c9b93">&#9670;&nbsp;</a></span>PathIndex() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::PathIndex::PathIndex </td>
          <td>(</td>
          <td class="paramtype">const list&lt; <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>vg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Index a list of mappings embedded in the given vg's <a class="el" href="classvg_1_1Paths.html">Paths</a> object, and pull sequence from the given vg. </p>

</div>
</div>
<a id="a72ba06ae7c3fed7abba0cbe2dd6cac88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ba06ae7c3fed7abba0cbe2dd6cac88">&#9670;&nbsp;</a></span>PathIndex() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::PathIndex::PathIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index a path and pull sequence from a graph. </p>

</div>
</div>
<a id="a9b82679a8d5040f0160edc008d8b348d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b82679a8d5040f0160edc008d8b348d">&#9670;&nbsp;</a></span>PathIndex() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::PathIndex::PathIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>vg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>extract_sequence</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a <a class="el" href="structvg_1_1PathIndex.html">PathIndex</a> from a path in a graph. </p>

</div>
</div>
<a id="a88a67933e88510cd99800348eb40aa57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a67933e88510cd99800348eb40aa57">&#9670;&nbsp;</a></span>PathIndex() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::PathIndex::PathIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>extract_sequence</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a <a class="el" href="structvg_1_1PathIndex.html">PathIndex</a> from a path in an indexed graph. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a827ae5af1330e03a23c35351d3152f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827ae5af1330e03a23c35351d3152f03">&#9670;&nbsp;</a></span>apply_translation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PathIndex::apply_translation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Translation.html">Translation</a> &amp;&#160;</td>
          <td class="paramname"><em>translation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the index to reflect the changes described by a <a class="el" href="structvg_1_1Translation.html">Translation</a>. References to nodes along the "from" path are changed to references to nodes along the "to" path. The translation must contain two paths of equal length, containing only matches. The translation must only divide nodes; it may not join nodes together. The translation must fully account for each old node that it touches (it can't translate only part of a node). The translation may not re-use the ID from one original node for a piece of a different original node. All the Mappings in the <a class="el" href="structvg_1_1Translation.html">Translation</a> must have Edits. </p>

</div>
</div>
<a id="a8aeebd524dc064af4cdda9fd84de2a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aeebd524dc064af4cdda9fd84de2a4a">&#9670;&nbsp;</a></span>apply_translations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PathIndex::apply_translations </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>translations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the index to reflect the changes described by the given collection of Translations. These translations are expected to be in the format produced by <a class="el" href="classvg_1_1VG.html#a5962aa939727f27cb7c62b2ce2706fe9">VG::edit()</a> which is one to <a class="el" href="structvg_1_1Mapping.html">Mapping</a> per translation. The vector may include both forward and reverse versions of each to node, and may also include translations mapping nodes that did not change to themselves. </p>

</div>
</div>
<a id="aab1c5d586bdef0e4cdc31ed7531eee7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1c5d586bdef0e4cdc31ed7531eee7c">&#9670;&nbsp;</a></span>at_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> vg::PathIndex::at_position </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find what node and orientation covers a position. The position must not be greater than the path length. </p>

</div>
</div>
<a id="ad239d0a2fb9bbbddce753a6c3cf639ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad239d0a2fb9bbbddce753a6c3cf639ed">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1PathIndex.html#a0a0f36c0f57cc92dfb70f05eb4e5c482">PathIndex::iterator</a> vg::PathIndex::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the iterator to the first node occurrence on the indexed path. </p>

</div>
</div>
<a id="ada3ccf7b77f16b46373ff5bb19fdbc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3ccf7b77f16b46373ff5bb19fdbc11">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1PathIndex.html#a0a0f36c0f57cc92dfb70f05eb4e5c482">PathIndex::iterator</a> vg::PathIndex::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the iterator to the last node occurrence on the indexed path. </p>

</div>
</div>
<a id="ae448ae2af8e4073b9db8b678e3b97e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae448ae2af8e4073b9db8b678e3b97e00">&#9670;&nbsp;</a></span>find_in_orientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1PathIndex.html#a0a0f36c0f57cc92dfb70f05eb4e5c482">PathIndex::iterator</a> vg::PathIndex::find_in_orientation </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first occurrence of the given node in the given orientation. </p>

</div>
</div>
<a id="a377bc15c246c708fe4a0264cb05588af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a377bc15c246c708fe4a0264cb05588af">&#9670;&nbsp;</a></span>find_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1PathIndex.html#a0a0f36c0f57cc92dfb70f05eb4e5c482">PathIndex::iterator</a> vg::PathIndex::find_position </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the iterator at the given position along the ref path. The position must not be greater than the path length. </p>

</div>
</div>
<a id="a6a7f7bbcd256a2ed34a58b8abefff712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7f7bbcd256a2ed34a58b8abefff712">&#9670;&nbsp;</a></span>get_contained_orientations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; bool, bool &gt; vg::PathIndex::get_contained_orientations </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>node_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return two flags for if the path contains the given node in forward and reverse orientation. </p>

</div>
</div>
<a id="a398380d0a0f4b4fefc15eef8b37cd2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398380d0a0f4b4fefc15eef8b37cd2f3">&#9670;&nbsp;</a></span>node_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::PathIndex::node_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1PathIndex.html#a0a0f36c0f57cc92dfb70f05eb4e5c482">iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>here</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the length of the node occurrence on the path represented by this iterator. </p>

</div>
</div>
<a id="aa5272234ddb7686f1ae88881ebf99a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5272234ddb7686f1ae88881ebf99a61">&#9670;&nbsp;</a></span>parse_translation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, vector&lt; <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &gt; &gt; vg::PathIndex::parse_translation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Translation.html">Translation</a> &amp;&#160;</td>
          <td class="paramname"><em>translation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a <a class="el" href="structvg_1_1Translation.html">Translation</a> that partitions old nodes into a map from old node ID to the Mappings that replace it in its forward orientation. </p>

</div>
</div>
<a id="ab1bb8b7aec345a4b59242287ae1693c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1bb8b7aec345a4b59242287ae1693c7">&#9670;&nbsp;</a></span>path_contains_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::PathIndex::path_contains_node </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>node_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a node is on the reference path. </p>

</div>
</div>
<a id="a0dbda80790b6d81aa0f9d83ac21f85a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dbda80790b6d81aa0f9d83ac21f85a3">&#9670;&nbsp;</a></span>path_contains_node_in_orientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::PathIndex::path_contains_node_in_orientation </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a node is on the reference path in a given path-relative orientation. </p>

</div>
</div>
<a id="ae8806eb31bcd8b8f9305180fea7b746f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8806eb31bcd8b8f9305180fea7b746f">&#9670;&nbsp;</a></span>replace_occurrence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PathIndex::replace_occurrence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1PathIndex.html#a0a0f36c0f57cc92dfb70f05eb4e5c482">iterator</a>&#160;</td>
          <td class="paramname"><em>to_replace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given an iterator into by_start, replace the occurrence of the node there with occurrences of the nodes given in the vector of mappings, which partition the forward strand of the node being replaced. </p>

</div>
</div>
<a id="ac02dd3e22c5b29670ef48b6f725a9797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02dd3e22c5b29670ef48b6f725a9797">&#9670;&nbsp;</a></span>round_outward()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; size_t, size_t &gt; vg::PathIndex::round_outward </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>past_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an end-exclusive range on the path, round outward to the nearest node boundary positions. </p>

</div>
</div>
<a id="a783b7aafb86a509a3434c10b5ae9355f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783b7aafb86a509a3434c10b5ae9355f">&#9670;&nbsp;</a></span>update_mapping_positions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::PathIndex::update_mapping_positions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>vg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rebuild the mapping positions map by tracing all the paths in the given graph. TODO: We ought to move this functionality to the <a class="el" href="classvg_1_1Paths.html">Paths</a> object and make it use a good datastructure instead of brute force. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3f5697a5db586a467dc4923e2cccbfe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5697a5db586a467dc4923e2cccbfe1">&#9670;&nbsp;</a></span>by_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;int64_t, pair&lt;size_t, bool&gt; &gt; vg::PathIndex::by_id</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Index from node ID to first position on the reference string and orientation it occurs there. </p>

</div>
</div>
<a id="a55cb6181f7b4b80016aaf2fefbb402c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55cb6181f7b4b80016aaf2fefbb402c2">&#9670;&nbsp;</a></span>by_start</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;size_t, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&gt; vg::PathIndex::by_start</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Index from start position on the reference to the side of the node that begins there. If it is a right side, the node occurs on the path in a reverse orientation. </p>

</div>
</div>
<a id="ac64a3532df12093eeccf3201184ea4d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64a3532df12093eeccf3201184ea4d9">&#9670;&nbsp;</a></span>last_node_length</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::PathIndex::last_node_length</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This, combined with by_start, gets us the length of every node on the indexed path. </p>

</div>
</div>
<a id="acc0b1da5ad0b4f428ceb623a4d3f806f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc0b1da5ad0b4f428ceb623a4d3f806f">&#9670;&nbsp;</a></span>mapping_positions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;const <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a>*, size_t&gt; vg::PathIndex::mapping_positions</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Index from <a class="el" href="structvg_1_1Mapping.html">Mapping</a> pointers in a <a class="el" href="classvg_1_1VG.html">VG</a> <a class="el" href="classvg_1_1Paths.html">Paths</a> object to their actual positions along their paths. Pointers may dangle if the vg graph changes the path. </p>

</div>
</div>
<a id="a057c79ab3b7c3d4a2827af2e7698b1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a057c79ab3b7c3d4a2827af2e7698b1f1">&#9670;&nbsp;</a></span>node_occurrences</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, vector&lt;<a class="el" href="structvg_1_1PathIndex.html#a0a0f36c0f57cc92dfb70f05eb4e5c482">iterator</a>&gt; &gt; vg::PathIndex::node_occurrences</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This holds all the places that a particular node occurs, in order. TODO: use this to replace by_id </p>

</div>
</div>
<a id="a0b807b5252299d9b0f1c9168079a591f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b807b5252299d9b0f1c9168079a591f">&#9670;&nbsp;</a></span>sequence</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string vg::PathIndex::sequence</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The actual sequence of the path, if desired. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>src/<a class="el" href="path__index_8hpp.html">path_index.hpp</a></li>
<li>src/<a class="el" href="path__index_8cpp.html">path_index.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
