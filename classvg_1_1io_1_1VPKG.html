<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::io::VPKG Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="namespacevg_1_1io.html">io</a></li><li class="navelem"><a class="el" href="classvg_1_1io_1_1VPKG.html">VPKG</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="classvg_1_1io_1_1VPKG-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::io::VPKG Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;vpkg.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a58ed1c37748fed4b15d4e611659ce4c3"><td class="memTemplParams" colspan="2">template&lt;typename... Wanted&gt; </td></tr>
<tr class="memitem:a58ed1c37748fed4b15d4e611659ce4c3"><td class="memTemplItemLeft" align="right" valign="top">static tuple&lt; unique_ptr&lt; Wanted &gt;... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1VPKG.html#a58ed1c37748fed4b15d4e611659ce4c3">try_load_first</a> (istream &amp;in, const string &amp;filename=&quot;&quot;)</td></tr>
<tr class="separator:a58ed1c37748fed4b15d4e611659ce4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504e965a2a019ce27267ea85c106a91b"><td class="memTemplParams" colspan="2">template&lt;typename... Wanted&gt; </td></tr>
<tr class="memitem:a504e965a2a019ce27267ea85c106a91b"><td class="memTemplItemLeft" align="right" valign="top">static tuple&lt; unique_ptr&lt; Wanted &gt;... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1VPKG.html#a504e965a2a019ce27267ea85c106a91b">try_load_first</a> (const string &amp;filename)</td></tr>
<tr class="separator:a504e965a2a019ce27267ea85c106a91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7f96d4dd7fe5b1fe47b330ca617623"><td class="memTemplParams" colspan="2">template&lt;typename Wanted &gt; </td></tr>
<tr class="memitem:a0d7f96d4dd7fe5b1fe47b330ca617623"><td class="memTemplItemLeft" align="right" valign="top">static unique_ptr&lt; Wanted &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1VPKG.html#a0d7f96d4dd7fe5b1fe47b330ca617623">try_load_one</a> (istream &amp;in, const string &amp;filename=&quot;&quot;)</td></tr>
<tr class="separator:a0d7f96d4dd7fe5b1fe47b330ca617623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a2026ac79ee1539271ba1791108c66"><td class="memTemplParams" colspan="2">template&lt;typename Wanted &gt; </td></tr>
<tr class="memitem:ab3a2026ac79ee1539271ba1791108c66"><td class="memTemplItemLeft" align="right" valign="top">static unique_ptr&lt; Wanted &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1VPKG.html#ab3a2026ac79ee1539271ba1791108c66">try_load_one</a> (const string &amp;filename)</td></tr>
<tr class="separator:ab3a2026ac79ee1539271ba1791108c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd67a72df658a50228c6cae7efe7753"><td class="memTemplParams" colspan="2">template&lt;typename Wanted &gt; </td></tr>
<tr class="memitem:affd67a72df658a50228c6cae7efe7753"><td class="memTemplItemLeft" align="right" valign="top">static unique_ptr&lt; Wanted &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1VPKG.html#affd67a72df658a50228c6cae7efe7753">load_one</a> (istream &amp;in, const string &amp;filename=&quot;&quot;)</td></tr>
<tr class="separator:affd67a72df658a50228c6cae7efe7753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60cacf98de761eab29ed168ee56e8e39"><td class="memTemplParams" colspan="2">template&lt;typename Wanted &gt; </td></tr>
<tr class="memitem:a60cacf98de761eab29ed168ee56e8e39"><td class="memTemplItemLeft" align="right" valign="top">static unique_ptr&lt; Wanted &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1VPKG.html#a60cacf98de761eab29ed168ee56e8e39">load_one</a> (const string &amp;filename)</td></tr>
<tr class="separator:a60cacf98de761eab29ed168ee56e8e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80551b46351f1e8d47e8b3ebaf028847"><td class="memTemplParams" colspan="2">template&lt;typename Have &gt; </td></tr>
<tr class="memitem:a80551b46351f1e8d47e8b3ebaf028847"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1VPKG.html#a80551b46351f1e8d47e8b3ebaf028847">save</a> (const Have &amp;have, ostream &amp;out)</td></tr>
<tr class="separator:a80551b46351f1e8d47e8b3ebaf028847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0472c51ab91f4b8663a56a150e0e0f12"><td class="memTemplParams" colspan="2">template&lt;typename Have &gt; </td></tr>
<tr class="memitem:a0472c51ab91f4b8663a56a150e0e0f12"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1VPKG.html#a0472c51ab91f4b8663a56a150e0e0f12">save</a> (const Have &amp;have, const string &amp;filename)</td></tr>
<tr class="separator:a0472c51ab91f4b8663a56a150e0e0f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030910ec652e742dbf98a845b95943a5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1VPKG.html#a030910ec652e742dbf98a845b95943a5">with_save_stream</a> (ostream &amp;to, const string &amp;tag, const function&lt; void(ostream &amp;)&gt; &amp;use_stream)</td></tr>
<tr class="separator:a030910ec652e742dbf98a845b95943a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:acfc929254f523522f369c4a17c8f0941"><td class="memTemplParams" colspan="2">template&lt;typename FirstPriority , typename SecondPriority , typename... Rest&gt; </td></tr>
<tr class="memitem:acfc929254f523522f369c4a17c8f0941"><td class="memTemplItemLeft" align="right" valign="top">static tuple&lt; unique_ptr&lt; FirstPriority &gt;, unique_ptr&lt; SecondPriority &gt;, unique_ptr&lt; Rest &gt;... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1VPKG.html#acfc929254f523522f369c4a17c8f0941">try_load_first_bare</a> (istream &amp;in, const string &amp;filename, bool &amp;found)</td></tr>
<tr class="separator:acfc929254f523522f369c4a17c8f0941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2707edbb6b28a6623ea8ae11e607c861"><td class="memTemplParams" colspan="2">template&lt;typename Only &gt; </td></tr>
<tr class="memitem:a2707edbb6b28a6623ea8ae11e607c861"><td class="memTemplItemLeft" align="right" valign="top">static tuple&lt; unique_ptr&lt; Only &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1VPKG.html#a2707edbb6b28a6623ea8ae11e607c861">try_load_first_bare</a> (istream &amp;in, const string &amp;filename, bool &amp;found)</td></tr>
<tr class="separator:a2707edbb6b28a6623ea8ae11e607c861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f9922d4b17194d248dc3f19a449f60"><td class="memTemplParams" colspan="2">template&lt;typename FirstPriority , typename SecondPriority , typename... Rest&gt; </td></tr>
<tr class="memitem:a12f9922d4b17194d248dc3f19a449f60"><td class="memTemplItemLeft" align="right" valign="top">static tuple&lt; unique_ptr&lt; FirstPriority &gt;, unique_ptr&lt; SecondPriority &gt;, unique_ptr&lt; Rest &gt;... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1VPKG.html#a12f9922d4b17194d248dc3f19a449f60">try_load_first_encapsulated</a> (<a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a> &amp;it, bool &amp;found)</td></tr>
<tr class="separator:a12f9922d4b17194d248dc3f19a449f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186f277ebf475632f1b4d1eac4c48139"><td class="memTemplParams" colspan="2">template&lt;typename Only &gt; </td></tr>
<tr class="memitem:a186f277ebf475632f1b4d1eac4c48139"><td class="memTemplItemLeft" align="right" valign="top">static tuple&lt; unique_ptr&lt; Only &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1VPKG.html#a186f277ebf475632f1b4d1eac4c48139">try_load_first_encapsulated</a> (<a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a> &amp;it, bool &amp;found)</td></tr>
<tr class="separator:a186f277ebf475632f1b4d1eac4c48139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d2bad9c95479a3f1520c5fadcba1b2"><td class="memTemplParams" colspan="2">template&lt;typename Wanted &gt; </td></tr>
<tr class="memitem:ad5d2bad9c95479a3f1520c5fadcba1b2"><td class="memTemplItemLeft" align="right" valign="top">static unique_ptr&lt; Wanted &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1VPKG.html#ad5d2bad9c95479a3f1520c5fadcba1b2">try_load_bare</a> (istream &amp;in, const string &amp;filename=&quot;&quot;)</td></tr>
<tr class="separator:ad5d2bad9c95479a3f1520c5fadcba1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695e5a53bfbc9a5b36c5ea2306f253db"><td class="memTemplParams" colspan="2">template&lt;typename Wanted &gt; </td></tr>
<tr class="memitem:a695e5a53bfbc9a5b36c5ea2306f253db"><td class="memTemplItemLeft" align="right" valign="top">static unique_ptr&lt; Wanted &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1VPKG.html#a695e5a53bfbc9a5b36c5ea2306f253db">try_load_encapsulated</a> (istream &amp;in)</td></tr>
<tr class="separator:a695e5a53bfbc9a5b36c5ea2306f253db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860f50291f4b5a6be232e5312eb884ab"><td class="memTemplParams" colspan="2">template&lt;typename Wanted &gt; </td></tr>
<tr class="memitem:a860f50291f4b5a6be232e5312eb884ab"><td class="memTemplItemLeft" align="right" valign="top">static unique_ptr&lt; Wanted &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1VPKG.html#a860f50291f4b5a6be232e5312eb884ab">try_load_encapsulated</a> (<a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a> &amp;it)</td></tr>
<tr class="separator:a860f50291f4b5a6be232e5312eb884ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcbb5a28413d3599a642cd5f22d93be"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1VPKG.html#a0bcbb5a28413d3599a642cd5f22d93be">with_putback</a> (istream &amp;in, const function&lt; void(istream &amp;)&gt; &amp;callback)</td></tr>
<tr class="separator:a0bcbb5a28413d3599a642cd5f22d93be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08bb9c650bfbbf15521ca1a215d0939"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af08bb9c650bfbbf15521ca1a215d0939"><td class="memTemplItemLeft" align="right" valign="top">static string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1VPKG.html#af08bb9c650bfbbf15521ca1a215d0939">describe</a> ()</td></tr>
<tr class="separator:af08bb9c650bfbbf15521ca1a215d0939"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface for reading/writing files.</p>
<p>Originally designed for Protobuf-based type-tagged files with optional BGZIP compression.</p>
<p>Now mostly used for files identified by prefixes or sniffing functions.</p>
<p>Allows you to load e.g. a HandleGraph from a file with the implementation being auto-selected based on what is in the file. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af08bb9c650bfbbf15521ca1a215d0939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08bb9c650bfbbf15521ca1a215d0939">&#9670;&nbsp;</a></span>describe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static string vg::io::VPKG::describe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a string to represent the given type. Should be demangled and human-readable. </p>

</div>
</div>
<a id="a60cacf98de761eab29ed168ee56e8e39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60cacf98de761eab29ed168ee56e8e39">&#9670;&nbsp;</a></span>load_one() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Wanted &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unique_ptr&lt;Wanted&gt; vg::io::VPKG::load_one </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load an object of the given type from a file by name. The stream may be <a class="el" href="classvg_1_1io_1_1VPKG.html">VPKG</a> with the appropriate tag, or a bare non-VPKG stream understood by the loader. Tagged messages that can't be used to load the thing we are looking for are skipped. Ends the program with an error if the object could not be found in the file. Supports "-" for standard input. </p>

</div>
</div>
<a id="affd67a72df658a50228c6cae7efe7753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd67a72df658a50228c6cae7efe7753">&#9670;&nbsp;</a></span>load_one() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Wanted &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unique_ptr&lt;Wanted&gt; vg::io::VPKG::load_one </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load an object of the given type from a stream. The stream may be <a class="el" href="classvg_1_1io_1_1VPKG.html">VPKG</a> with the appropriate tag, or a bare non-VPKG stream understood by the loader. Tagged messages that can't be used to load the thing we are looking for are skipped. Ends the program with an error if the object could not be found in the stream.</p>
<p>May consume trailing data from the stream. </p>

</div>
</div>
<a id="a0472c51ab91f4b8663a56a150e0e0f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0472c51ab91f4b8663a56a150e0e0f12">&#9670;&nbsp;</a></span>save() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Have &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vg::io::VPKG::save </td>
          <td>(</td>
          <td class="paramtype">const Have &amp;&#160;</td>
          <td class="paramname"><em>have</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a80551b46351f1e8d47e8b3ebaf028847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80551b46351f1e8d47e8b3ebaf028847">&#9670;&nbsp;</a></span>save() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Have &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vg::io::VPKG::save </td>
          <td>(</td>
          <td class="paramtype">const Have &amp;&#160;</td>
          <td class="paramname"><em>have</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save an object to the given stream, using the appropriate saver. </p>

</div>
</div>
<a id="ad5d2bad9c95479a3f1520c5fadcba1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d2bad9c95479a3f1520c5fadcba1b2">&#9670;&nbsp;</a></span>try_load_bare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Wanted &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unique_ptr&lt;Wanted&gt; vg::io::VPKG::try_load_bare </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load an object of the given type from a stream. The stream has to be a bare non-VPKG stream understood by the loader. Returns the loaded object, or null if no loader liked the input.</p>
<p>filename is optional, and can be used by callback code that may, for some reason, want to link the stream back to a path (cough cough GFA loader cough cough). </p>

</div>
</div>
<a id="a695e5a53bfbc9a5b36c5ea2306f253db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695e5a53bfbc9a5b36c5ea2306f253db">&#9670;&nbsp;</a></span>try_load_encapsulated() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Wanted &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unique_ptr&lt;Wanted&gt; vg::io::VPKG::try_load_encapsulated </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load an object of the given type from a stream. The stream has to be a <a class="el" href="classvg_1_1io_1_1VPKG.html">VPKG</a> type-tagged message stream. Returns the loaded object, or null if the messages have incompatible type tags. If the messages have incompatible tags, some may be consumed from the stream. Throws an exception if the input is not a <a class="el" href="classvg_1_1io_1_1VPKG.html">VPKG</a> type-tagged message stream. </p>

</div>
</div>
<a id="a860f50291f4b5a6be232e5312eb884ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860f50291f4b5a6be232e5312eb884ab">&#9670;&nbsp;</a></span>try_load_encapsulated() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Wanted &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unique_ptr&lt;Wanted&gt; vg::io::VPKG::try_load_encapsulated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load an object of the given type from an iterator of type-tagged messages. Returns the loaded object, or null if the messages have incompatible type tags. If the messages have incompatible tags, the iterator will not be advanced. </p>

</div>
</div>
<a id="a504e965a2a019ce27267ea85c106a91b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504e965a2a019ce27267ea85c106a91b">&#9670;&nbsp;</a></span>try_load_first() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Wanted&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static tuple&lt;unique_ptr&lt;Wanted&gt;...&gt; vg::io::VPKG::try_load_first </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocate and load the first available type from the given stream. Returns a tuple where at most one item is filled, and that item is the first type we could successfully load out of the template parameters.</p>
<p>If any type is to be loaded from type-tagged messages, it must come first, or its type-tagged messages may be skipped when looking for higher-priority types. </p>

</div>
</div>
<a id="a58ed1c37748fed4b15d4e611659ce4c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ed1c37748fed4b15d4e611659ce4c3">&#9670;&nbsp;</a></span>try_load_first() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Wanted&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static tuple&lt;unique_ptr&lt;Wanted&gt;...&gt; vg::io::VPKG::try_load_first </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocate and load an available type from the given stream. Returns a tuple where at most one item is filled, and that item is the first type we could successfully load out of the template parameters, except that bare loaders are prioritized over encapsulated ones.</p>
<p>filename is optional, and can be used by callback code that may, for some reason, want to link the stream back to a path (cough cough GFA loader cough cough) </p>

</div>
</div>
<a id="acfc929254f523522f369c4a17c8f0941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc929254f523522f369c4a17c8f0941">&#9670;&nbsp;</a></span>try_load_first_bare() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FirstPriority , typename SecondPriority , typename... Rest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static tuple&lt;unique_ptr&lt;FirstPriority&gt;, unique_ptr&lt;SecondPriority&gt;, unique_ptr&lt;Rest&gt;...&gt; vg::io::VPKG::try_load_first_bare </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocate and load the first available type from the given stream, using a bare loader. Returns a tuple where at most one item is filled, and that item is the first type we could successfully load out of the template parameters. Sets found to true if anything is successfully loaded.</p>
<p>filename is optional, and can be used by callback code that may, for some reason, want to link the stream back to a path (cough cough GFA loader cough cough) </p>

</div>
</div>
<a id="a2707edbb6b28a6623ea8ae11e607c861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2707edbb6b28a6623ea8ae11e607c861">&#9670;&nbsp;</a></span>try_load_first_bare() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Only &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static tuple&lt;unique_ptr&lt;Only&gt; &gt; vg::io::VPKG::try_load_first_bare </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocate and load the first available type from the given stream, using a bare loader. Returns a tuple where at most one item is filled, and that item is the first type we could successfully load out of the template parameters. Sets found to true if anything is successfully loaded.</p>
<p>filename is optional, and can be used by callback code that may, for some reason, want to link the stream back to a path (cough cough GFA loader cough cough) </p>

</div>
</div>
<a id="a12f9922d4b17194d248dc3f19a449f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f9922d4b17194d248dc3f19a449f60">&#9670;&nbsp;</a></span>try_load_first_encapsulated() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FirstPriority , typename SecondPriority , typename... Rest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static tuple&lt;unique_ptr&lt;FirstPriority&gt;, unique_ptr&lt;SecondPriority&gt;, unique_ptr&lt;Rest&gt;...&gt; vg::io::VPKG::try_load_first_encapsulated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocate and load the first available type from the given iterator, using a bare loader. Returns a tuple where at most one item is filled, and that item is the first type we could successfully load out of the template parameters. Sets found to true if anything is successfully loaded. </p>

</div>
</div>
<a id="a186f277ebf475632f1b4d1eac4c48139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186f277ebf475632f1b4d1eac4c48139">&#9670;&nbsp;</a></span>try_load_first_encapsulated() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Only &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static tuple&lt;unique_ptr&lt;Only&gt; &gt; vg::io::VPKG::try_load_first_encapsulated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocate and load the first available type from the given iterator, using a VPKG-encapsulated loader. Returns a tuple where at most one item is filled, and that item is the first type we could successfully load out of the template parameters. Sets found to true if anything is successfully loaded. </p>

</div>
</div>
<a id="ab3a2026ac79ee1539271ba1791108c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a2026ac79ee1539271ba1791108c66">&#9670;&nbsp;</a></span>try_load_one() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Wanted &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unique_ptr&lt;Wanted&gt; vg::io::VPKG::try_load_one </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load an object of the given type from a file by name. The stream may be <a class="el" href="classvg_1_1io_1_1VPKG.html">VPKG</a> with the appropriate tag, or a bare non-VPKG stream understood by the loader. Returns null if the object could not be found in the file. Supports "-" for standard input. </p>

</div>
</div>
<a id="a0d7f96d4dd7fe5b1fe47b330ca617623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7f96d4dd7fe5b1fe47b330ca617623">&#9670;&nbsp;</a></span>try_load_one() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Wanted &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unique_ptr&lt;Wanted&gt; vg::io::VPKG::try_load_one </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load an object of the given type from a file. The stream may be <a class="el" href="classvg_1_1io_1_1VPKG.html">VPKG</a> with the appropriate tag, or a bare non-VPKG stream understood by the loader.</p>
<p>Tagged messages that can't be used to load the thing we are looking for may or may not be consumed, so you should not call this function in a loop over types on the same stream.</p>
<p>filename is optional, and can be used by callback code that may, for some reason, want to link the stream back to a path (cough cough GFA loader cough cough) </p>

</div>
</div>
<a id="a0bcbb5a28413d3599a642cd5f22d93be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bcbb5a28413d3599a642cd5f22d93be">&#9670;&nbsp;</a></span>with_putback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vg::io::VPKG::with_putback </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(istream &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Run the given callback with a version of the given stream that allows putback. </p>

</div>
</div>
<a id="a030910ec652e742dbf98a845b95943a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a030910ec652e742dbf98a845b95943a5">&#9670;&nbsp;</a></span>with_save_stream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::VPKG::with_save_stream </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(ostream &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>use_stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lower-level function used to get direct access to a stream tagged with the given tag, in the given type-tagged message output file. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>deps/libvgio/include/vg/io/<a class="el" href="vpkg_8hpp.html">vpkg.hpp</a></li>
<li>deps/libvgio/src/<a class="el" href="vpkg_8cpp.html">vpkg.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
