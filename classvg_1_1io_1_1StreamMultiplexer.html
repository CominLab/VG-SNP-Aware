<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::io::StreamMultiplexer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="namespacevg_1_1io.html">io</a></li><li class="navelem"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html">StreamMultiplexer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classvg_1_1io_1_1StreamMultiplexer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::io::StreamMultiplexer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;stream_multiplexer.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae72f4179a6cb14beb1b6460603d88233"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#ae72f4179a6cb14beb1b6460603d88233">StreamMultiplexer</a> (ostream &amp;backing, size_t max_threads)</td></tr>
<tr class="separator:ae72f4179a6cb14beb1b6460603d88233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59b05564e82666f5213863cb2d0af19"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#ab59b05564e82666f5213863cb2d0af19">~StreamMultiplexer</a> ()</td></tr>
<tr class="separator:ab59b05564e82666f5213863cb2d0af19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b06aab5797747b1ce3d544be0cc965"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#ad8b06aab5797747b1ce3d544be0cc965">StreamMultiplexer</a> (const <a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html">StreamMultiplexer</a> &amp;other)=delete</td></tr>
<tr class="separator:ad8b06aab5797747b1ce3d544be0cc965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8352f0fcbb63f162734d48d2ec573ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#af8352f0fcbb63f162734d48d2ec573ce">StreamMultiplexer</a> (<a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html">StreamMultiplexer</a> &amp;&amp;other)=delete</td></tr>
<tr class="separator:af8352f0fcbb63f162734d48d2ec573ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af986451d89174a2947be32aaefba6f94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html">StreamMultiplexer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#af986451d89174a2947be32aaefba6f94">operator=</a> (const <a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html">StreamMultiplexer</a> &amp;other)=delete</td></tr>
<tr class="separator:af986451d89174a2947be32aaefba6f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0426a0e605e8375e1716dfb28b6482e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html">StreamMultiplexer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#aa0426a0e605e8375e1716dfb28b6482e">operator=</a> (<a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html">StreamMultiplexer</a> &amp;&amp;other)=delete</td></tr>
<tr class="separator:aa0426a0e605e8375e1716dfb28b6482e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749ab082e0364d470d84978c9757ef76"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#a749ab082e0364d470d84978c9757ef76">get_thread_stream</a> (size_t thread_number)</td></tr>
<tr class="separator:a749ab082e0364d470d84978c9757ef76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562910d0ca3b3fac6b95b0c3ee3c81dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#a562910d0ca3b3fac6b95b0c3ee3c81dd">register_breakpoint</a> (size_t thread_number)</td></tr>
<tr class="separator:a562910d0ca3b3fac6b95b0c3ee3c81dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0698f3b6387ce47f4e9d5b2929d6cf4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#ac0698f3b6387ce47f4e9d5b2929d6cf4">want_breakpoint</a> (size_t thread_number)</td></tr>
<tr class="separator:ac0698f3b6387ce47f4e9d5b2929d6cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb05844bf345313fc1710db7f3610ac5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#acb05844bf345313fc1710db7f3610ac5">register_barrier</a> (size_t thread_number)</td></tr>
<tr class="separator:acb05844bf345313fc1710db7f3610ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6107af83d4ce5347df10459d0f57e399"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#a6107af83d4ce5347df10459d0f57e399">discard_to_breakpoint</a> (size_t thread_number)</td></tr>
<tr class="separator:a6107af83d4ce5347df10459d0f57e399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25792444fb888296deead30a520f7b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#af25792444fb888296deead30a520f7b3">discard_bytes</a> (size_t thread_number, size_t count)</td></tr>
<tr class="separator:af25792444fb888296deead30a520f7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a0d671fb79357a83af6c5becfa890a6f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#a0d671fb79357a83af6c5becfa890a6f2">ring_buffer_full</a> (size_t thread_number) const</td></tr>
<tr class="separator:a0d671fb79357a83af6c5becfa890a6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c3f4f2de80a840aef85574935758ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#a92c3f4f2de80a840aef85574935758ac">ring_buffer_empty</a> (size_t thread_number) const</td></tr>
<tr class="separator:a92c3f4f2de80a840aef85574935758ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925607e24a8c6e905fc45c4b77bbe62c"><td class="memItemLeft" align="right" valign="top">string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#a925607e24a8c6e905fc45c4b77bbe62c">ring_buffer_push</a> (size_t thread_number)</td></tr>
<tr class="separator:a925607e24a8c6e905fc45c4b77bbe62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03a8b8e99c728355ade20923bcb4c2f"><td class="memItemLeft" align="right" valign="top">const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#aa03a8b8e99c728355ade20923bcb4c2f">ring_buffer_peek</a> (size_t thread_number)</td></tr>
<tr class="separator:aa03a8b8e99c728355ade20923bcb4c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f6095e2eb79970075f9b2279e990ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#ac4f6095e2eb79970075f9b2279e990ce">ring_buffer_pop</a> (size_t thread_number)</td></tr>
<tr class="separator:ac4f6095e2eb79970075f9b2279e990ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ba6b97591887c453b0cc112cae41e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#a29ba6b97591887c453b0cc112cae41e4">writer_thread_function</a> ()</td></tr>
<tr class="separator:a29ba6b97591887c453b0cc112cae41e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a465b3bcbc4159b7cf997d35e972d6a03"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#a465b3bcbc4159b7cf997d35e972d6a03">backing_stream</a></td></tr>
<tr class="memdesc:a465b3bcbc4159b7cf997d35e972d6a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remember the backing stream we wrap.  <a href="classvg_1_1io_1_1StreamMultiplexer.html#a465b3bcbc4159b7cf997d35e972d6a03">More...</a><br /></td></tr>
<tr class="separator:a465b3bcbc4159b7cf997d35e972d6a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e75e8ebd9b414f7438dea9b43af3b56"><td class="memItemLeft" align="right" valign="top">vector&lt; stringstream &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#a9e75e8ebd9b414f7438dea9b43af3b56">thread_streams</a></td></tr>
<tr class="separator:a9e75e8ebd9b414f7438dea9b43af3b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836843731535676ddd71a68cd3cd6d7f"><td class="memItemLeft" align="right" valign="top">vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#a836843731535676ddd71a68cd3cd6d7f">thread_breakpoint_cursors</a></td></tr>
<tr class="separator:a836843731535676ddd71a68cd3cd6d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4bc760981467acc3bff684653ffebd5"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#aa4bc760981467acc3bff684653ffebd5">thread_queues</a></td></tr>
<tr class="separator:aa4bc760981467acc3bff684653ffebd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62843d99c1215b3d01109142f2356327"><td class="memItemLeft" align="right" valign="top">vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#a62843d99c1215b3d01109142f2356327">thread_queue_empty_slots</a></td></tr>
<tr class="separator:a62843d99c1215b3d01109142f2356327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34283d480d468d52412bce3daeae5c4"><td class="memItemLeft" align="right" valign="top">vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#ad34283d480d468d52412bce3daeae5c4">thread_queue_filled_slots</a></td></tr>
<tr class="separator:ad34283d480d468d52412bce3daeae5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec3374dee16f6ee0ce853b04a4d6967"><td class="memItemLeft" align="right" valign="top">vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#a9ec3374dee16f6ee0ce853b04a4d6967">thread_queue_byte_counts</a></td></tr>
<tr class="memdesc:a9ec3374dee16f6ee0ce853b04a4d6967"><td class="mdescLeft">&#160;</td><td class="mdescRight">This tracks the number of bytes of data in each thread's queue.  <a href="classvg_1_1io_1_1StreamMultiplexer.html#a9ec3374dee16f6ee0ce853b04a4d6967">More...</a><br /></td></tr>
<tr class="separator:a9ec3374dee16f6ee0ce853b04a4d6967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0404331337813a02b7bafd0fb95e10a"><td class="memItemLeft" align="right" valign="top">vector&lt; mutex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#ae0404331337813a02b7bafd0fb95e10a">thread_queue_mutexes</a></td></tr>
<tr class="separator:ae0404331337813a02b7bafd0fb95e10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51a3ffdfe9ec988bf732e4904dcbf60"><td class="memItemLeft" align="right" valign="top">atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#ae51a3ffdfe9ec988bf732e4904dcbf60">writer_stop</a></td></tr>
<tr class="memdesc:ae51a3ffdfe9ec988bf732e4904dcbf60"><td class="mdescLeft">&#160;</td><td class="mdescRight">When set to true, cause the writer thread to finish writing all queues and terminate.  <a href="classvg_1_1io_1_1StreamMultiplexer.html#ae51a3ffdfe9ec988bf732e4904dcbf60">More...</a><br /></td></tr>
<tr class="separator:ae51a3ffdfe9ec988bf732e4904dcbf60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a9d39b8ccdd13f07e835ad7a967a60"><td class="memItemLeft" align="right" valign="top">thread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#a56a9d39b8ccdd13f07e835ad7a967a60">writer_thread</a></td></tr>
<tr class="separator:a56a9d39b8ccdd13f07e835ad7a967a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:afd60eacdf650f68a3989c91670655146"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#afd60eacdf650f68a3989c91670655146">MIN_QUEUE_ITEM_BYTES</a> = 10 * 64 * 1024</td></tr>
<tr class="memdesc:afd60eacdf650f68a3989c91670655146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Don't deal with anything smaller than a few BGZF blocks.  <a href="classvg_1_1io_1_1StreamMultiplexer.html#afd60eacdf650f68a3989c91670655146">More...</a><br /></td></tr>
<tr class="separator:afd60eacdf650f68a3989c91670655146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4432baab9571a1783b2a793b29905a"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#a6e4432baab9571a1783b2a793b29905a">RING_BUFFER_SIZE</a> = 10</td></tr>
<tr class="memdesc:a6e4432baab9571a1783b2a793b29905a"><td class="mdescLeft">&#160;</td><td class="mdescRight">What is the number of slots in each queue ring buffer?  <a href="classvg_1_1io_1_1StreamMultiplexer.html#a6e4432baab9571a1783b2a793b29905a">More...</a><br /></td></tr>
<tr class="separator:a6e4432baab9571a1783b2a793b29905a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Tool to allow multiple threads to write to streams that are multiplexed into an output stream, by breaking at allowed points.</p>
<p>Assumes an external source of thread numbering. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae72f4179a6cb14beb1b6460603d88233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72f4179a6cb14beb1b6460603d88233">&#9670;&nbsp;</a></span>StreamMultiplexer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::io::StreamMultiplexer::StreamMultiplexer </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>backing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a new <a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html">StreamMultiplexer</a> sending output to the given output stream.</p>
<p>Needs to know the maximum number of threads that will use the multiplexer. </p>

</div>
</div>
<a id="ab59b05564e82666f5213863cb2d0af19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59b05564e82666f5213863cb2d0af19">&#9670;&nbsp;</a></span>~StreamMultiplexer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::io::StreamMultiplexer::~StreamMultiplexer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clean up and flush a <a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html">StreamMultiplexer</a>.</p>
<p>Assumes a final breakpoint on all streams. </p>

</div>
</div>
<a id="ad8b06aab5797747b1ce3d544be0cc965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b06aab5797747b1ce3d544be0cc965">&#9670;&nbsp;</a></span>StreamMultiplexer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::io::StreamMultiplexer::StreamMultiplexer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html">StreamMultiplexer</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af8352f0fcbb63f162734d48d2ec573ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8352f0fcbb63f162734d48d2ec573ce">&#9670;&nbsp;</a></span>StreamMultiplexer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::io::StreamMultiplexer::StreamMultiplexer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html">StreamMultiplexer</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af25792444fb888296deead30a520f7b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25792444fb888296deead30a520f7b3">&#9670;&nbsp;</a></span>discard_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::StreamMultiplexer::discard_bytes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>thread_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cancel the writing of the last count bytes written since the last breakpoint for the given thread. If count is more than the number of bytes since the last breakpoint, rewinds only to the last breakpoint. </p>

</div>
</div>
<a id="a6107af83d4ce5347df10459d0f57e399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6107af83d4ce5347df10459d0f57e399">&#9670;&nbsp;</a></span>discard_to_breakpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::StreamMultiplexer::discard_to_breakpoint </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>thread_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cancel the writing of and discard all data written since the previous breakpoint for the given thread. </p>

</div>
</div>
<a id="a749ab082e0364d470d84978c9757ef76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a749ab082e0364d470d84978c9757ef76">&#9670;&nbsp;</a></span>get_thread_stream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; vg::io::StreamMultiplexer::get_thread_stream </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>thread_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the stream for the thread with the given number to write to. This stream will never change address for a given thread, but the object may be destroyed or recreated in place, or moved out of, during calls to <a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#a562910d0ca3b3fac6b95b0c3ee3c81dd">register_breakpoint()</a>.</p>
<p>Note that using this function in an "untied" (i.e. not thread bound) OMP task is not supported! </p>

</div>
</div>
<a id="af986451d89174a2947be32aaefba6f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af986451d89174a2947be32aaefba6f94">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html">StreamMultiplexer</a>&amp; vg::io::StreamMultiplexer::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html">StreamMultiplexer</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0426a0e605e8375e1716dfb28b6482e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0426a0e605e8375e1716dfb28b6482e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html">StreamMultiplexer</a>&amp; vg::io::StreamMultiplexer::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html">StreamMultiplexer</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb05844bf345313fc1710db7f3610ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb05844bf345313fc1710db7f3610ac5">&#9670;&nbsp;</a></span>register_barrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::StreamMultiplexer::register_barrier </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>thread_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send along whatever has been written for the given thread's stream to the output stream. Only returns once any subsequent write by another thread is guaranteed to appear later in the file than what has been written by the given thread so far. Implicitly also creates a breakpoint. </p>

</div>
</div>
<a id="a562910d0ca3b3fac6b95b0c3ee3c81dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562910d0ca3b3fac6b95b0c3ee3c81dd">&#9670;&nbsp;</a></span>register_breakpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::StreamMultiplexer::register_breakpoint </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>thread_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function must be called after batches of writes to the stream from <a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#a749ab082e0364d470d84978c9757ef76">get_thread_stream()</a>, at points where it is legal, given the output format being constructed, to switch in the final output stream from one thread's output to another's.</p>
<p>It may adjust or replace the object that <a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html#a749ab082e0364d470d84978c9757ef76">get_thread_stream()</a> returned, but it must leave a stream at the same address.</p>
<p>Takes the thread number of the thread whose output we can break. </p>

</div>
</div>
<a id="a92c3f4f2de80a840aef85574935758ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c3f4f2de80a840aef85574935758ac">&#9670;&nbsp;</a></span>ring_buffer_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::StreamMultiplexer::ring_buffer_empty </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>thread_number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return if the ring buffer for the given thread is empty. Lock on the thread's ring buffer must be held. </p>

</div>
</div>
<a id="a0d671fb79357a83af6c5becfa890a6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d671fb79357a83af6c5becfa890a6f2">&#9670;&nbsp;</a></span>ring_buffer_full()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::StreamMultiplexer::ring_buffer_full </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>thread_number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return if the ring buffer for the given thread is full. Lock on the thread's ring buffer must be held. </p>

</div>
</div>
<a id="aa03a8b8e99c728355ade20923bcb4c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa03a8b8e99c728355ade20923bcb4c2f">&#9670;&nbsp;</a></span>ring_buffer_peek()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string &amp; vg::io::StreamMultiplexer::ring_buffer_peek </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>thread_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assuming the ring buffer for the given thread is not empty, get a reference to the next thing that would be popped. Lock on the thread's ring buffer must be held. </p>

</div>
</div>
<a id="ac4f6095e2eb79970075f9b2279e990ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f6095e2eb79970075f9b2279e990ce">&#9670;&nbsp;</a></span>ring_buffer_pop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::StreamMultiplexer::ring_buffer_pop </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>thread_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assuming the ring buffer for the given thread is not empty, remove the thing that is visible via peek. Lock on the thread's ring buffer must be held. </p>

</div>
</div>
<a id="a925607e24a8c6e905fc45c4b77bbe62c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925607e24a8c6e905fc45c4b77bbe62c">&#9670;&nbsp;</a></span>ring_buffer_push()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string &amp; vg::io::StreamMultiplexer::ring_buffer_push </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>thread_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assuming the ring buffer for the given thread is not full, mark the next space as occupied and return a reference to it. Lock on the thread's ring buffer must be held. </p>

</div>
</div>
<a id="ac0698f3b6387ce47f4e9d5b2929d6cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0698f3b6387ce47f4e9d5b2929d6cf4">&#9670;&nbsp;</a></span>want_breakpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::StreamMultiplexer::want_breakpoint </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>thread_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the multiplexer would like a breakpoint (i.e. has a substantial amount of data been written since the last breakpoint.</p>
<p>Writers can check this and conditionally flush their internal buffers to get to a good interleave-able state at regular intervals. </p>

</div>
</div>
<a id="a29ba6b97591887c453b0cc112cae41e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ba6b97591887c453b0cc112cae41e4">&#9670;&nbsp;</a></span>writer_thread_function()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::StreamMultiplexer::writer_thread_function </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function which is run as the writer thread. Empties queues as fast as it can. </p>
<p>Lock again and pop. Nobody else could have removed the thing we were working on.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a465b3bcbc4159b7cf997d35e972d6a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a465b3bcbc4159b7cf997d35e972d6a03">&#9670;&nbsp;</a></span>backing_stream</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; vg::io::StreamMultiplexer::backing_stream</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remember the backing stream we wrap. </p>

</div>
</div>
<a id="afd60eacdf650f68a3989c91670655146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd60eacdf650f68a3989c91670655146">&#9670;&nbsp;</a></span>MIN_QUEUE_ITEM_BYTES</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t vg::io::StreamMultiplexer::MIN_QUEUE_ITEM_BYTES = 10 * 64 * 1024</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Don't deal with anything smaller than a few BGZF blocks. </p>
<p>To prevent constant locking and unlocking of the queues, we want each item to be relatively substantial. </p>

</div>
</div>
<a id="a6e4432baab9571a1783b2a793b29905a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4432baab9571a1783b2a793b29905a">&#9670;&nbsp;</a></span>RING_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t vg::io::StreamMultiplexer::RING_BUFFER_SIZE = 10</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>What is the number of slots in each queue ring buffer? </p>
<p>Don't allow more than a few items per ring buffer. </p>

</div>
</div>
<a id="a836843731535676ddd71a68cd3cd6d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836843731535676ddd71a68cd3cd6d7f">&#9670;&nbsp;</a></span>thread_breakpoint_cursors</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;size_t&gt; vg::io::StreamMultiplexer::thread_breakpoint_cursors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Not every breakpoint results in the stream for a thread being cleared out and enqueued. We only actually use a breakpoint if we have enough data in the stream. But we still have to support discard_to_breakpoint. So we keep a cursor for where the most recent breakpoint was. The actual current position in each stream is tracked by the put pointer (seekp()/tellp()). </p>

</div>
</div>
<a id="a9ec3374dee16f6ee0ce853b04a4d6967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec3374dee16f6ee0ce853b04a4d6967">&#9670;&nbsp;</a></span>thread_queue_byte_counts</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;size_t&gt; vg::io::StreamMultiplexer::thread_queue_byte_counts</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This tracks the number of bytes of data in each thread's queue. </p>

</div>
</div>
<a id="a62843d99c1215b3d01109142f2356327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62843d99c1215b3d01109142f2356327">&#9670;&nbsp;</a></span>thread_queue_empty_slots</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;size_t&gt; vg::io::StreamMultiplexer::thread_queue_empty_slots</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the number of the next slot in the ring buffer whose data can be overwritten. </p>

</div>
</div>
<a id="ad34283d480d468d52412bce3daeae5c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34283d480d468d52412bce3daeae5c4">&#9670;&nbsp;</a></span>thread_queue_filled_slots</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;size_t&gt; vg::io::StreamMultiplexer::thread_queue_filled_slots</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the number of the last used slot in the ring buffer. If it is equal to thread_queue_empty, no slots are used. </p>

</div>
</div>
<a id="ae0404331337813a02b7bafd0fb95e10a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0404331337813a02b7bafd0fb95e10a">&#9670;&nbsp;</a></span>thread_queue_mutexes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;mutex&gt; vg::io::StreamMultiplexer::thread_queue_mutexes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access to each thread's queue and byte count is controlled by a mutex. The mutex only has to be held long enough to a little moving, and can only ever be contended between two threads. </p>

</div>
</div>
<a id="aa4bc760981467acc3bff684653ffebd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4bc760981467acc3bff684653ffebd5">&#9670;&nbsp;</a></span>thread_queues</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;vector&lt;string&gt; &gt; vg::io::StreamMultiplexer::thread_queues</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When a thread reaches a breakpoint and its stringstream is big enough, its string data is copied into this queue at the back, and the stream is emptied.</p>
<p>We use a ring buffer, so that the writer thread never needs to deallocate anything. To prevent ambiguity, the ring buffer always contains at least 1 empty slot. </p>

</div>
</div>
<a id="a9e75e8ebd9b414f7438dea9b43af3b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e75e8ebd9b414f7438dea9b43af3b56">&#9670;&nbsp;</a></span>thread_streams</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;stringstream&gt; vg::io::StreamMultiplexer::thread_streams</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Each thread gets a slot in this vector for a stringstream it is supposed to be currently writing to. </p>

</div>
</div>
<a id="ae51a3ffdfe9ec988bf732e4904dcbf60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51a3ffdfe9ec988bf732e4904dcbf60">&#9670;&nbsp;</a></span>writer_stop</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">atomic&lt;bool&gt; vg::io::StreamMultiplexer::writer_stop</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When set to true, cause the writer thread to finish writing all queues and terminate. </p>

</div>
</div>
<a id="a56a9d39b8ccdd13f07e835ad7a967a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a9d39b8ccdd13f07e835ad7a967a60">&#9670;&nbsp;</a></span>writer_thread</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">thread vg::io::StreamMultiplexer::writer_thread</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This thread is responsible for servicing all the queues and dumping the bytes to the real backing stream. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>deps/libvgio/include/vg/io/<a class="el" href="stream__multiplexer_8hpp.html">stream_multiplexer.hpp</a></li>
<li>deps/libvgio/src/<a class="el" href="stream__multiplexer_8cpp.html">stream_multiplexer.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
