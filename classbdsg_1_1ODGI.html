<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: bdsg::ODGI Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebdsg.html">bdsg</a></li><li class="navelem"><a class="el" href="classbdsg_1_1ODGI.html">ODGI</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classbdsg_1_1ODGI-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">bdsg::ODGI Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;odgi.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for bdsg::ODGI:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbdsg_1_1ODGI.png" usemap="#bdsg::ODGI_map" alt=""/>
  <map id="bdsg::ODGI_map" name="bdsg::ODGI_map">
<area href="classhandlegraph_1_1MutablePathDeletableHandleGraph.html" alt="handlegraph::MutablePathDeletableHandleGraph" shape="rect" coords="371,224,658,248"/>
<area href="classhandlegraph_1_1SerializableHandleGraph.html" alt="handlegraph::SerializableHandleGraph" shape="rect" coords="891,224,1178,248"/>
<area href="classhandlegraph_1_1MutablePathMutableHandleGraph.html" alt="handlegraph::MutablePathMutableHandleGraph" shape="rect" coords="148,168,435,192"/>
<area href="classhandlegraph_1_1DeletableHandleGraph.html" alt="handlegraph::DeletableHandleGraph" shape="rect" coords="594,168,881,192"/>
<area href="classhandlegraph_1_1Serializable.html" alt="handlegraph::Serializable" shape="rect" coords="891,168,1178,192"/>
<area href="classhandlegraph_1_1MutablePathHandleGraph.html" alt="handlegraph::MutablePathHandleGraph" shape="rect" coords="0,112,287,136"/>
<area href="classhandlegraph_1_1MutableHandleGraph.html" alt="handlegraph::MutableHandleGraph" shape="rect" coords="297,112,584,136"/>
<area href="classhandlegraph_1_1MutableHandleGraph.html" alt="handlegraph::MutableHandleGraph" shape="rect" coords="594,112,881,136"/>
<area href="classhandlegraph_1_1PathHandleGraph.html" alt="handlegraph::PathHandleGraph" shape="rect" coords="0,56,287,80"/>
<area href="classhandlegraph_1_1HandleGraph.html" alt="handlegraph::HandleGraph" shape="rect" coords="297,56,584,80"/>
<area href="classhandlegraph_1_1HandleGraph.html" alt="handlegraph::HandleGraph" shape="rect" coords="594,56,881,80"/>
<area href="classhandlegraph_1_1HandleGraph.html" alt="handlegraph::HandleGraph" shape="rect" coords="0,0,287,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdsg_1_1ODGI_1_1edge__helper.html">edge_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdsg_1_1ODGI_1_1path__metadata__t.html">path_metadata_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa10931aaf9f517e6c5063ab5aabd6e80"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#aa10931aaf9f517e6c5063ab5aabd6e80">ODGI</a> (void)</td></tr>
<tr class="separator:aa10931aaf9f517e6c5063ab5aabd6e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657c2084681b06ffa4fd8cf91d07a0fe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a657c2084681b06ffa4fd8cf91d07a0fe">~ODGI</a> (void)</td></tr>
<tr class="separator:a657c2084681b06ffa4fd8cf91d07a0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7e91edb2d2f3f5886c9cba85165d91"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a0b7e91edb2d2f3f5886c9cba85165d91">get_magic_number</a> () const</td></tr>
<tr class="memdesc:a0b7e91edb2d2f3f5886c9cba85165d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a high-entropy number to indicate which handle graph implementation this is.  <a href="#a0b7e91edb2d2f3f5886c9cba85165d91">More...</a><br /></td></tr>
<tr class="separator:a0b7e91edb2d2f3f5886c9cba85165d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a83407a5325e8a4fd95a54ab552fb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a43a83407a5325e8a4fd95a54ab552fb6">has_node</a> (<a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> node_id) const</td></tr>
<tr class="memdesc:a43a83407a5325e8a4fd95a54ab552fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to check if a node exists by ID.  <a href="#a43a83407a5325e8a4fd95a54ab552fb6">More...</a><br /></td></tr>
<tr class="separator:a43a83407a5325e8a4fd95a54ab552fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a29e97e52486fdcd85de1503301bc89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a0a29e97e52486fdcd85de1503301bc89">get_handle</a> (const <a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> &amp;node_id, bool is_reverse=false) const</td></tr>
<tr class="memdesc:a0a29e97e52486fdcd85de1503301bc89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the handle for the node with the given ID in the given orientation.  <a href="#a0a29e97e52486fdcd85de1503301bc89">More...</a><br /></td></tr>
<tr class="separator:a0a29e97e52486fdcd85de1503301bc89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d4ea7145009f15a6ea56bc308f3b3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#aa4d4ea7145009f15a6ea56bc308f3b3a">get_id</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:aa4d4ea7145009f15a6ea56bc308f3b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID from a handle.  <a href="#aa4d4ea7145009f15a6ea56bc308f3b3a">More...</a><br /></td></tr>
<tr class="separator:aa4d4ea7145009f15a6ea56bc308f3b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb485a462f1093a06d02b7bbe01bc82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a7cb485a462f1093a06d02b7bbe01bc82">get_is_reverse</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a7cb485a462f1093a06d02b7bbe01bc82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the orientation of a handle.  <a href="#a7cb485a462f1093a06d02b7bbe01bc82">More...</a><br /></td></tr>
<tr class="separator:a7cb485a462f1093a06d02b7bbe01bc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a9c756c01f41b0ee07dea7be704cb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a46a9c756c01f41b0ee07dea7be704cb9">flip</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a46a9c756c01f41b0ee07dea7be704cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the orientation of a handle (potentially without getting its ID)  <a href="#a46a9c756c01f41b0ee07dea7be704cb9">More...</a><br /></td></tr>
<tr class="separator:a46a9c756c01f41b0ee07dea7be704cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f8d526bad1bf4b9cc836650e418a9d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#af5f8d526bad1bf4b9cc836650e418a9d">get_length</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:af5f8d526bad1bf4b9cc836650e418a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of a node.  <a href="#af5f8d526bad1bf4b9cc836650e418a9d">More...</a><br /></td></tr>
<tr class="separator:af5f8d526bad1bf4b9cc836650e418a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bfc01300b6e922a4c7e18b5d8815fd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a15bfc01300b6e922a4c7e18b5d8815fd">get_sequence</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a15bfc01300b6e922a4c7e18b5d8815fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sequence of a node, presented in the handle's local forward orientation.  <a href="#a15bfc01300b6e922a4c7e18b5d8815fd">More...</a><br /></td></tr>
<tr class="separator:a15bfc01300b6e922a4c7e18b5d8815fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddeb239b50ed9039524ad64ded98134"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a9ddeb239b50ed9039524ad64ded98134">get_node_count</a> (void) const</td></tr>
<tr class="separator:a9ddeb239b50ed9039524ad64ded98134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77442cc3333d7fd0d1f2dcefe02d8645"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a77442cc3333d7fd0d1f2dcefe02d8645">min_node_id</a> (void) const</td></tr>
<tr class="separator:a77442cc3333d7fd0d1f2dcefe02d8645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8597d305f14b4c572ebd3f3167b9067e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a8597d305f14b4c572ebd3f3167b9067e">max_node_id</a> (void) const</td></tr>
<tr class="separator:a8597d305f14b4c572ebd3f3167b9067e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3daecc421eea0f87fac165694a07f689"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a3daecc421eea0f87fac165694a07f689">set_id_increment</a> (const <a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> &amp;min_id)</td></tr>
<tr class="memdesc:a3daecc421eea0f87fac165694a07f689"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the id increment, used when the graph starts at a high id to reduce loading costs  <a href="#a3daecc421eea0f87fac165694a07f689">More...</a><br /></td></tr>
<tr class="separator:a3daecc421eea0f87fac165694a07f689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb93e89319a1730e8aa1b4cd646b3a88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#abb93e89319a1730e8aa1b4cd646b3a88">increment_node_ids</a> (<a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> increment)</td></tr>
<tr class="memdesc:abb93e89319a1730e8aa1b4cd646b3a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given value to all node IDs.  <a href="#abb93e89319a1730e8aa1b4cd646b3a88">More...</a><br /></td></tr>
<tr class="separator:abb93e89319a1730e8aa1b4cd646b3a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9d9a5e4259e365194e650f4d8de89a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#aeb9d9a5e4259e365194e650f4d8de89a">reassign_node_ids</a> (const std::function&lt; <a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a>(const <a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> &amp;)&gt; &amp;get_new_id)</td></tr>
<tr class="memdesc:aeb9d9a5e4259e365194e650f4d8de89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reassign all node IDs as specified by the old-&gt;new mapping function.  <a href="#aeb9d9a5e4259e365194e650f4d8de89a">More...</a><br /></td></tr>
<tr class="separator:aeb9d9a5e4259e365194e650f4d8de89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f762f9a7977278859307a9c16a0ca9d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a1f762f9a7977278859307a9c16a0ca9d">get_degree</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left) const</td></tr>
<tr class="separator:a1f762f9a7977278859307a9c16a0ca9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283642a6aa72294926826b3e429bcb34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a283642a6aa72294926826b3e429bcb34">forward</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a283642a6aa72294926826b3e429bcb34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the locally forward version of a handle.  <a href="#a283642a6aa72294926826b3e429bcb34">More...</a><br /></td></tr>
<tr class="separator:a283642a6aa72294926826b3e429bcb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f151b46b20a3c08314058c69c37ba4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#aa9f151b46b20a3c08314058c69c37ba4">edge_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right) const</td></tr>
<tr class="separator:aa9f151b46b20a3c08314058c69c37ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d6a4235afe99439e8a323cc142ffc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#aa1d6a4235afe99439e8a323cc142ffc2">traverse_edge_handle</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left) const</td></tr>
<tr class="separator:aa1d6a4235afe99439e8a323cc142ffc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefbb6d165884048871c0c71dfd5ec0bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#aefbb6d165884048871c0c71dfd5ec0bd">has_path</a> (const std::string &amp;path_name) const</td></tr>
<tr class="memdesc:aefbb6d165884048871c0c71dfd5ec0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a path name exists and is legal to get a path handle for.  <a href="#aefbb6d165884048871c0c71dfd5ec0bd">More...</a><br /></td></tr>
<tr class="separator:aefbb6d165884048871c0c71dfd5ec0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5272dacca04fba9b408d034dbacf538d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a5272dacca04fba9b408d034dbacf538d">get_path_handle</a> (const std::string &amp;path_name) const</td></tr>
<tr class="separator:a5272dacca04fba9b408d034dbacf538d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aac861542bdd5019ca479b7a3a1eede"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a5aac861542bdd5019ca479b7a3a1eede">get_path_name</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="memdesc:a5aac861542bdd5019ca479b7a3a1eede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the name of a path from a handle to it.  <a href="#a5aac861542bdd5019ca479b7a3a1eede">More...</a><br /></td></tr>
<tr class="separator:a5aac861542bdd5019ca479b7a3a1eede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e16430b1cf49be4c97acb99301f0f9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a43e16430b1cf49be4c97acb99301f0f9">get_step_count</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="memdesc:a43e16430b1cf49be4c97acb99301f0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of node steps in the path.  <a href="#a43e16430b1cf49be4c97acb99301f0f9">More...</a><br /></td></tr>
<tr class="separator:a43e16430b1cf49be4c97acb99301f0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf1a14fd17058c4d8582b8c7c1d03bd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#aaaf1a14fd17058c4d8582b8c7c1d03bd">get_path_count</a> (void) const</td></tr>
<tr class="memdesc:aaaf1a14fd17058c4d8582b8c7c1d03bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of paths stored in the graph.  <a href="#aaaf1a14fd17058c4d8582b8c7c1d03bd">More...</a><br /></td></tr>
<tr class="separator:aaaf1a14fd17058c4d8582b8c7c1d03bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dff34b34dd834544745600fc5e329fe"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a2dff34b34dd834544745600fc5e329fe">steps_of_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool match_orientation=false) const</td></tr>
<tr class="separator:a2dff34b34dd834544745600fc5e329fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77cd4dee45911bb99040688f664d9c79"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a77cd4dee45911bb99040688f664d9c79">get_step_count</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a77cd4dee45911bb99040688f664d9c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of node steps on the handle.  <a href="#a77cd4dee45911bb99040688f664d9c79">More...</a><br /></td></tr>
<tr class="separator:a77cd4dee45911bb99040688f664d9c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cad8b4fd7cbc45c63d6a24aae9e08c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#ac8cad8b4fd7cbc45c63d6a24aae9e08c">get_handle_of_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="memdesc:ac8cad8b4fd7cbc45c63d6a24aae9e08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a node handle (node ID and orientation) from a handle to an step on a path.  <a href="#ac8cad8b4fd7cbc45c63d6a24aae9e08c">More...</a><br /></td></tr>
<tr class="separator:ac8cad8b4fd7cbc45c63d6a24aae9e08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e279a09b8a97ccf0b6173dbf403476"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a89e279a09b8a97ccf0b6173dbf403476">path_begin</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="separator:a89e279a09b8a97ccf0b6173dbf403476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4c772ba162987a9639aa5fa8d6771a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a1b4c772ba162987a9639aa5fa8d6771a">path_end</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="memdesc:a1b4c772ba162987a9639aa5fa8d6771a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle to a fictitious handle one past the end of the path.  <a href="#a1b4c772ba162987a9639aa5fa8d6771a">More...</a><br /></td></tr>
<tr class="separator:a1b4c772ba162987a9639aa5fa8d6771a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76cd8596923b721bc325145b9d9c148"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#ac76cd8596923b721bc325145b9d9c148">path_back</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="memdesc:ac76cd8596923b721bc325145b9d9c148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle to the last step, which is arbitrary in the case of a circular path.  <a href="#ac76cd8596923b721bc325145b9d9c148">More...</a><br /></td></tr>
<tr class="separator:ac76cd8596923b721bc325145b9d9c148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635e865722fa46278308b4a54a7f6c13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a635e865722fa46278308b4a54a7f6c13">path_front_end</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="memdesc:a635e865722fa46278308b4a54a7f6c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle to a fictitious handle one past the start of the path.  <a href="#a635e865722fa46278308b4a54a7f6c13">More...</a><br /></td></tr>
<tr class="separator:a635e865722fa46278308b4a54a7f6c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a124f7c425057df8fa48092dae6525"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a11a124f7c425057df8fa48092dae6525">is_path_front_end</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="memdesc:a11a124f7c425057df8fa48092dae6525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the step handle is a front end magic handle.  <a href="#a11a124f7c425057df8fa48092dae6525">More...</a><br /></td></tr>
<tr class="separator:a11a124f7c425057df8fa48092dae6525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd56c244b5681b99d4c68f3e829198a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#abd56c244b5681b99d4c68f3e829198a9">is_path_end</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="memdesc:abd56c244b5681b99d4c68f3e829198a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the step handle is an end magic handle.  <a href="#abd56c244b5681b99d4c68f3e829198a9">More...</a><br /></td></tr>
<tr class="separator:abd56c244b5681b99d4c68f3e829198a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ec93e4c218d661208be27bb6dbcbac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#aa5ec93e4c218d661208be27bb6dbcbac">has_next_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="memdesc:aa5ec93e4c218d661208be27bb6dbcbac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the step has a next step on the path, else false.  <a href="#aa5ec93e4c218d661208be27bb6dbcbac">More...</a><br /></td></tr>
<tr class="separator:aa5ec93e4c218d661208be27bb6dbcbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117c7a402f0deb7dfe3e4c60d5b85a7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a117c7a402f0deb7dfe3e4c60d5b85a7c">has_previous_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="memdesc:a117c7a402f0deb7dfe3e4c60d5b85a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the step has a previous step on the path, else false.  <a href="#a117c7a402f0deb7dfe3e4c60d5b85a7c">More...</a><br /></td></tr>
<tr class="separator:a117c7a402f0deb7dfe3e4c60d5b85a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b25ea3cd9dd8deda455adcb54048758"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a9b25ea3cd9dd8deda455adcb54048758">get_next_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="memdesc:a9b25ea3cd9dd8deda455adcb54048758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handle to the next step on the path.  <a href="#a9b25ea3cd9dd8deda455adcb54048758">More...</a><br /></td></tr>
<tr class="separator:a9b25ea3cd9dd8deda455adcb54048758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddc5873bb8e56f00a7788ee269cc3f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a0ddc5873bb8e56f00a7788ee269cc3f2">get_previous_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="memdesc:a0ddc5873bb8e56f00a7788ee269cc3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handle to the previous step on the path.  <a href="#a0ddc5873bb8e56f00a7788ee269cc3f2">More...</a><br /></td></tr>
<tr class="separator:a0ddc5873bb8e56f00a7788ee269cc3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca22411d8d2b91cd5646d012d4cced32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#aca22411d8d2b91cd5646d012d4cced32">get_path_handle_of_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="memdesc:aca22411d8d2b91cd5646d012d4cced32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handle to the path that a step is on.  <a href="#aca22411d8d2b91cd5646d012d4cced32">More...</a><br /></td></tr>
<tr class="separator:aca22411d8d2b91cd5646d012d4cced32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1f969f0a4aa08e812324a4e3028872"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a2f1f969f0a4aa08e812324a4e3028872">is_empty</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="memdesc:a2f1f969f0a4aa08e812324a4e3028872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given path is empty, and false otherwise.  <a href="#a2f1f969f0a4aa08e812324a4e3028872">More...</a><br /></td></tr>
<tr class="separator:a2f1f969f0a4aa08e812324a4e3028872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9aa896439054373d5f048fc64bcaf12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#af9aa896439054373d5f048fc64bcaf12">for_each_step_in_path</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, const std::function&lt; void(const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;)&gt; &amp;iteratee) const</td></tr>
<tr class="memdesc:af9aa896439054373d5f048fc64bcaf12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop over all the steps along a path, from first through last.  <a href="#af9aa896439054373d5f048fc64bcaf12">More...</a><br /></td></tr>
<tr class="separator:af9aa896439054373d5f048fc64bcaf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21969e49be312b2fec4af7372ea516c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a21969e49be312b2fec4af7372ea516c0">get_is_circular</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="memdesc:a21969e49be312b2fec4af7372ea516c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the path is circular.  <a href="#a21969e49be312b2fec4af7372ea516c0">More...</a><br /></td></tr>
<tr class="separator:a21969e49be312b2fec4af7372ea516c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916a526721ae5d609b354957172f971b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a916a526721ae5d609b354957172f971b">set_circularity</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle, bool circular)</td></tr>
<tr class="memdesc:a916a526721ae5d609b354957172f971b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set if the path is circular or not.  <a href="#a916a526721ae5d609b354957172f971b">More...</a><br /></td></tr>
<tr class="separator:a916a526721ae5d609b354957172f971b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4789eb41a9285a0dbc8c3f7dfe41b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a4d4789eb41a9285a0dbc8c3f7dfe41b0">create_handle</a> (const std::string &amp;sequence)</td></tr>
<tr class="memdesc:a4d4789eb41a9285a0dbc8c3f7dfe41b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new node with the given sequence and return the handle.  <a href="#a4d4789eb41a9285a0dbc8c3f7dfe41b0">More...</a><br /></td></tr>
<tr class="separator:a4d4789eb41a9285a0dbc8c3f7dfe41b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452b70cec271a66a9f154cfa40ed6466"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a452b70cec271a66a9f154cfa40ed6466">create_handle</a> (const std::string &amp;sequence, const <a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> &amp;id)</td></tr>
<tr class="memdesc:a452b70cec271a66a9f154cfa40ed6466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new node with the given id and sequence, then return the handle.  <a href="#a452b70cec271a66a9f154cfa40ed6466">More...</a><br /></td></tr>
<tr class="separator:a452b70cec271a66a9f154cfa40ed6466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceea39a6c1a3ca2404d36cb968970f62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#aceea39a6c1a3ca2404d36cb968970f62">create_hidden_handle</a> (const std::string &amp;sequence)</td></tr>
<tr class="separator:aceea39a6c1a3ca2404d36cb968970f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63156a0199c9382de3b196aeef7d845e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a63156a0199c9382de3b196aeef7d845e">destroy_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle)</td></tr>
<tr class="separator:a63156a0199c9382de3b196aeef7d845e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b8028afdfac4bc5f14ab58de8e4a8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a34b8028afdfac4bc5f14ab58de8e4a8c">create_edge</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right)</td></tr>
<tr class="separator:a34b8028afdfac4bc5f14ab58de8e4a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b75b9735e7ca21c66488bea6baa4da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a62b75b9735e7ca21c66488bea6baa4da">has_edge</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right) const</td></tr>
<tr class="memdesc:a62b75b9735e7ca21c66488bea6baa4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an edge exists.  <a href="#a62b75b9735e7ca21c66488bea6baa4da">More...</a><br /></td></tr>
<tr class="separator:a62b75b9735e7ca21c66488bea6baa4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f05c91a157684e6321a1cbcf83467e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a1f05c91a157684e6321a1cbcf83467e2">create_edge</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge)</td></tr>
<tr class="memdesc:a1f05c91a157684e6321a1cbcf83467e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient wrapper for create_edge.  <a href="#a1f05c91a157684e6321a1cbcf83467e2">More...</a><br /></td></tr>
<tr class="separator:a1f05c91a157684e6321a1cbcf83467e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac899f9aba8759607a6629ef40ff8ca4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#ac899f9aba8759607a6629ef40ff8ca4f">destroy_edge</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right)</td></tr>
<tr class="separator:ac899f9aba8759607a6629ef40ff8ca4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6710e4471ebadab935e9d5da028b3fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#aa6710e4471ebadab935e9d5da028b3fa">destroy_edge</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge)</td></tr>
<tr class="memdesc:aa6710e4471ebadab935e9d5da028b3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient wrapper for destroy_edge.  <a href="#aa6710e4471ebadab935e9d5da028b3fa">More...</a><br /></td></tr>
<tr class="separator:aa6710e4471ebadab935e9d5da028b3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03fb2ec6571cc5bfa141827303a530cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a03fb2ec6571cc5bfa141827303a530cf">clear</a> (void)</td></tr>
<tr class="memdesc:a03fb2ec6571cc5bfa141827303a530cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all nodes, edges, and paths.  <a href="#a03fb2ec6571cc5bfa141827303a530cf">More...</a><br /></td></tr>
<tr class="separator:a03fb2ec6571cc5bfa141827303a530cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0751769e5119ed6b511d715564fc94b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a0751769e5119ed6b511d715564fc94b3">clear_paths</a> (void)</td></tr>
<tr class="memdesc:a0751769e5119ed6b511d715564fc94b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all stored paths.  <a href="#a0751769e5119ed6b511d715564fc94b3">More...</a><br /></td></tr>
<tr class="separator:a0751769e5119ed6b511d715564fc94b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5ce7792f463b597fb91b327d735d80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a0b5ce7792f463b597fb91b327d735d80">swap_handles</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;a, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;b)</td></tr>
<tr class="separator:a0b5ce7792f463b597fb91b327d735d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5830007d8a3487d0e065a57edce76a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a1e5830007d8a3487d0e065a57edce76a">apply_ordering</a> (const std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;order, bool compact_ids=false)</td></tr>
<tr class="separator:a1e5830007d8a3487d0e065a57edce76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d199f8d5b559eab155b9e6e2ba71736"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a9d199f8d5b559eab155b9e6e2ba71736">optimize</a> (bool allow_id_reassignment=true)</td></tr>
<tr class="memdesc:a9d199f8d5b559eab155b9e6e2ba71736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Organize the graph for better performance and memory use.  <a href="#a9d199f8d5b559eab155b9e6e2ba71736">More...</a><br /></td></tr>
<tr class="separator:a9d199f8d5b559eab155b9e6e2ba71736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570d9d9907f0ad71f127f9345166437e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a570d9d9907f0ad71f127f9345166437e">apply_path_ordering</a> (const std::vector&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;order)</td></tr>
<tr class="memdesc:a570d9d9907f0ad71f127f9345166437e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder the graph's paths as given.  <a href="#a570d9d9907f0ad71f127f9345166437e">More...</a><br /></td></tr>
<tr class="separator:a570d9d9907f0ad71f127f9345166437e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdfaacd138082595779b01f54e5df8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a7cdfaacd138082595779b01f54e5df8b">apply_orientation</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle)</td></tr>
<tr class="separator:a7cdfaacd138082595779b01f54e5df8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e011120475409b6f7b8ad93e4c2ab4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#ac5e011120475409b6f7b8ad93e4c2ab4">divide_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const std::vector&lt; size_t &gt; &amp;offsets)</td></tr>
<tr class="separator:ac5e011120475409b6f7b8ad93e4c2ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcb735a0bffdcabd247628a5f7f8b5b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#aabcb735a0bffdcabd247628a5f7f8b5b">divide_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, size_t offset)</td></tr>
<tr class="memdesc:aabcb735a0bffdcabd247628a5f7f8b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of divide_handle for a single division point.  <a href="#aabcb735a0bffdcabd247628a5f7f8b5b">More...</a><br /></td></tr>
<tr class="separator:aabcb735a0bffdcabd247628a5f7f8b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff3e1fdc8b210547d871d3014e670ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a8ff3e1fdc8b210547d871d3014e670ba">combine_handles</a> (const std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;handles)</td></tr>
<tr class="separator:a8ff3e1fdc8b210547d871d3014e670ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1265a7527979210c56e990e08d4e650"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#ab1265a7527979210c56e990e08d4e650">destroy_path</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path)</td></tr>
<tr class="separator:ab1265a7527979210c56e990e08d4e650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127ed64f4237d7b307e73633508c7e5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a127ed64f4237d7b307e73633508c7e5d">create_path_handle</a> (const std::string &amp;name, bool is_circular=false)</td></tr>
<tr class="separator:a127ed64f4237d7b307e73633508c7e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b5764a3b881b921ce745fd8e53d1ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a74b5764a3b881b921ce745fd8e53d1ab">prepend_step</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;to_append)</td></tr>
<tr class="separator:a74b5764a3b881b921ce745fd8e53d1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b068258f3a98847bcde404ef293d9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#af9b068258f3a98847bcde404ef293d9c">append_step</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;to_append)</td></tr>
<tr class="separator:af9b068258f3a98847bcde404ef293d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91a47ba26660fdd0022e193a5de05df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#ab91a47ba26660fdd0022e193a5de05df">insert_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;before, const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;after, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;to_insert)</td></tr>
<tr class="separator:ab91a47ba26660fdd0022e193a5de05df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab249018b1f7ccbb325f7de2575b2f269"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#ab249018b1f7ccbb325f7de2575b2f269">set_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle)</td></tr>
<tr class="memdesc:ab249018b1f7ccbb325f7de2575b2f269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the step to the given handle, possibly re-linking and cleaning up if needed.  <a href="#ab249018b1f7ccbb325f7de2575b2f269">More...</a><br /></td></tr>
<tr class="separator:ab249018b1f7ccbb325f7de2575b2f269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a08999aeec3f00b077be5157e497b4"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#ad1a08999aeec3f00b077be5157e497b4">rewrite_segment</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;segment_begin, const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;segment_end, const std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;new_segment)</td></tr>
<tr class="memdesc:ad1a08999aeec3f00b077be5157e497b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the path range with the new segment.  <a href="#ad1a08999aeec3f00b077be5157e497b4">More...</a><br /></td></tr>
<tr class="separator:ad1a08999aeec3f00b077be5157e497b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6df0eaba6bfd6781eee8297f3781d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a3f6df0eaba6bfd6781eee8297f3781d0">display</a> (void) const</td></tr>
<tr class="memdesc:a3f6df0eaba6bfd6781eee8297f3781d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function to visualize the state of the graph.  <a href="#a3f6df0eaba6bfd6781eee8297f3781d0">More...</a><br /></td></tr>
<tr class="separator:a3f6df0eaba6bfd6781eee8297f3781d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803a41f3012e735d81272826acdac236"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a803a41f3012e735d81272826acdac236">to_gfa</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a803a41f3012e735d81272826acdac236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to GFA (for debugging)  <a href="#a803a41f3012e735d81272826acdac236">More...</a><br /></td></tr>
<tr class="separator:a803a41f3012e735d81272826acdac236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683d1879ff05c9e27f1586cb8f61376f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a683d1879ff05c9e27f1586cb8f61376f">to_gfa</a> (const string &amp;filename) const</td></tr>
<tr class="memdesc:a683d1879ff05c9e27f1586cb8f61376f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to GFA and send to the given filename, or "-" for standard output (the default).  <a href="#a683d1879ff05c9e27f1586cb8f61376f">More...</a><br /></td></tr>
<tr class="separator:a683d1879ff05c9e27f1586cb8f61376f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7efc962237f615ababad29f06d98c9b"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#ab7efc962237f615ababad29f06d98c9b">to_gfa</a> () const</td></tr>
<tr class="memdesc:ab7efc962237f615ababad29f06d98c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to GFA and return as a string.  <a href="#ab7efc962237f615ababad29f06d98c9b">More...</a><br /></td></tr>
<tr class="separator:ab7efc962237f615ababad29f06d98c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316d91c973ef3b034a7d40118ff350b6"><td class="memItemLeft" align="right" valign="top">long long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a316d91c973ef3b034a7d40118ff350b6">serialize_and_measure</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a316d91c973ef3b034a7d40118ff350b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4feef9688b5ecd376e84bd693f0466"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a8b4feef9688b5ecd376e84bd693f0466">load</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:a8b4feef9688b5ecd376e84bd693f0466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load.  <a href="#a8b4feef9688b5ecd376e84bd693f0466">More...</a><br /></td></tr>
<tr class="separator:a8b4feef9688b5ecd376e84bd693f0466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1MutablePathDeletableHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1MutablePathDeletableHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1MutablePathDeletableHandleGraph.html">handlegraph::MutablePathDeletableHandleGraph</a></td></tr>
<tr class="memitem:a2d936ce540af42363619ebb77c60a4ff inherit pub_methods_classhandlegraph_1_1MutablePathDeletableHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutablePathDeletableHandleGraph.html#a2d936ce540af42363619ebb77c60a4ff">~MutablePathDeletableHandleGraph</a> ()=default</td></tr>
<tr class="separator:a2d936ce540af42363619ebb77c60a4ff inherit pub_methods_classhandlegraph_1_1MutablePathDeletableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1MutablePathMutableHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1MutablePathMutableHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">handlegraph::MutablePathMutableHandleGraph</a></td></tr>
<tr class="memitem:a55379ced0e4f2952ca3353c558affc44 inherit pub_methods_classhandlegraph_1_1MutablePathMutableHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html#a55379ced0e4f2952ca3353c558affc44">~MutablePathMutableHandleGraph</a> ()=default</td></tr>
<tr class="separator:a55379ced0e4f2952ca3353c558affc44 inherit pub_methods_classhandlegraph_1_1MutablePathMutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1MutablePathHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html">handlegraph::MutablePathHandleGraph</a></td></tr>
<tr class="memitem:a3b9b032ce45f87e1abd5c175db6f5275 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a3b9b032ce45f87e1abd5c175db6f5275">~MutablePathHandleGraph</a> ()=default</td></tr>
<tr class="separator:a3b9b032ce45f87e1abd5c175db6f5275 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1PathHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1PathHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">handlegraph::PathHandleGraph</a></td></tr>
<tr class="memitem:a49fe5658c5ef27e1d7aba69cd3d7159b inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a49fe5658c5ef27e1d7aba69cd3d7159b">~PathHandleGraph</a> ()=default</td></tr>
<tr class="separator:a49fe5658c5ef27e1d7aba69cd3d7159b inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f1d0595543d760322042770201297c inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:aa3f1d0595543d760322042770201297c inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#aa3f1d0595543d760322042770201297c">for_each_path_handle</a> (const Iteratee &amp;iteratee) const</td></tr>
<tr class="separator:aa3f1d0595543d760322042770201297c inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006a8e3ab9e2783ef7bf80b98b35959c inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a006a8e3ab9e2783ef7bf80b98b35959c inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a006a8e3ab9e2783ef7bf80b98b35959c">for_each_step_on_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const Iteratee &amp;iteratee) const</td></tr>
<tr class="separator:a006a8e3ab9e2783ef7bf80b98b35959c inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa071f31a10a02d8231b029d0a7ddef0b inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhandlegraph_1_1PathForEachSocket.html">PathForEachSocket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#aa071f31a10a02d8231b029d0a7ddef0b">scan_path</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path) const</td></tr>
<tr class="separator:aa071f31a10a02d8231b029d0a7ddef0b inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184353db571dd2086d79e4e31f2f97f1 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a184353db571dd2086d79e4e31f2f97f1 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a184353db571dd2086d79e4e31f2f97f1">for_each_step_in_path</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, const Iteratee &amp;iteratee) const</td></tr>
<tr class="separator:a184353db571dd2086d79e4e31f2f97f1 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1HandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1HandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1HandleGraph.html">handlegraph::HandleGraph</a></td></tr>
<tr class="memitem:a24fb796441c9ad8c870fdb716a82b305 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a24fb796441c9ad8c870fdb716a82b305">~HandleGraph</a> ()=default</td></tr>
<tr class="separator:a24fb796441c9ad8c870fdb716a82b305 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d21f30e62ad0b0c5919b2fe95e6f8aa inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a4d21f30e62ad0b0c5919b2fe95e6f8aa inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a4d21f30e62ad0b0c5919b2fe95e6f8aa">follow_edges</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left, const Iteratee &amp;iteratee) const</td></tr>
<tr class="separator:a4d21f30e62ad0b0c5919b2fe95e6f8aa inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928bdeabd328d357b538e30590164ab4 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a928bdeabd328d357b538e30590164ab4 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a928bdeabd328d357b538e30590164ab4">for_each_handle</a> (const Iteratee &amp;iteratee, bool parallel=false) const</td></tr>
<tr class="separator:a928bdeabd328d357b538e30590164ab4 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6171cdd6036c73623c96656f8b44fe9d inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a6171cdd6036c73623c96656f8b44fe9d">has_edge</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge) const</td></tr>
<tr class="memdesc:a6171cdd6036c73623c96656f8b44fe9d inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient wrapper of has_edge for edge_t argument.  <a href="classhandlegraph_1_1HandleGraph.html#a6171cdd6036c73623c96656f8b44fe9d">More...</a><br /></td></tr>
<tr class="separator:a6171cdd6036c73623c96656f8b44fe9d inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ff62014d7f0f0c01ada8a3d40a278d inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a20ff62014d7f0f0c01ada8a3d40a278d">get_edge_count</a> () const</td></tr>
<tr class="separator:a20ff62014d7f0f0c01ada8a3d40a278d inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c98da99e0d32ebcc9fd31be4b779e29 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a4c98da99e0d32ebcc9fd31be4b779e29">get_total_length</a> () const</td></tr>
<tr class="separator:a4c98da99e0d32ebcc9fd31be4b779e29 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d58c3e26e9e7954dd25c3eff7af521 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a64d58c3e26e9e7954dd25c3eff7af521">get_base</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, size_t index) const</td></tr>
<tr class="separator:a64d58c3e26e9e7954dd25c3eff7af521 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c6fcda357516b1160996c63ed40d63 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a74c6fcda357516b1160996c63ed40d63">get_subsequence</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, size_t index, size_t size) const</td></tr>
<tr class="separator:a74c6fcda357516b1160996c63ed40d63 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e946bb4ed53f9423072955cdaab6386 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a9e946bb4ed53f9423072955cdaab6386">forward</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a9e946bb4ed53f9423072955cdaab6386 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the locally forward version of a handle.  <a href="classhandlegraph_1_1HandleGraph.html#a9e946bb4ed53f9423072955cdaab6386">More...</a><br /></td></tr>
<tr class="separator:a9e946bb4ed53f9423072955cdaab6386 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3766f1aca1cbdbf827f2a12aaf2078ec inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a3766f1aca1cbdbf827f2a12aaf2078ec">edge_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right) const</td></tr>
<tr class="separator:a3766f1aca1cbdbf827f2a12aaf2078ec inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af167b0664299cfd4eac610f129fa5fee inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#af167b0664299cfd4eac610f129fa5fee">traverse_edge_handle</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left) const</td></tr>
<tr class="separator:af167b0664299cfd4eac610f129fa5fee inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61570ded026f825d62ea7608a1e92349 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a61570ded026f825d62ea7608a1e92349 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a61570ded026f825d62ea7608a1e92349">for_each_edge</a> (const Iteratee &amp;iteratee, bool parallel=false) const</td></tr>
<tr class="separator:a61570ded026f825d62ea7608a1e92349 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1MutableHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1MutableHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">handlegraph::MutableHandleGraph</a></td></tr>
<tr class="memitem:ace50b9ed07cbbe94f7da963ff02d4141 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#ace50b9ed07cbbe94f7da963ff02d4141">~MutableHandleGraph</a> ()=default</td></tr>
<tr class="separator:ace50b9ed07cbbe94f7da963ff02d4141 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff0a0f9497da3498170fdfc2ce97797 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a3ff0a0f9497da3498170fdfc2ce97797">create_edge</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge)</td></tr>
<tr class="memdesc:a3ff0a0f9497da3498170fdfc2ce97797 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient wrapper for create_edge.  <a href="classhandlegraph_1_1MutableHandleGraph.html#a3ff0a0f9497da3498170fdfc2ce97797">More...</a><br /></td></tr>
<tr class="separator:a3ff0a0f9497da3498170fdfc2ce97797 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c38787f0ff4a2695e61d98cb402175 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a05c38787f0ff4a2695e61d98cb402175">divide_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, size_t offset)</td></tr>
<tr class="memdesc:a05c38787f0ff4a2695e61d98cb402175 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of divide_handle for a single division point.  <a href="classhandlegraph_1_1MutableHandleGraph.html#a05c38787f0ff4a2695e61d98cb402175">More...</a><br /></td></tr>
<tr class="separator:a05c38787f0ff4a2695e61d98cb402175 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877dc8c0ae9a584907d45328512720cc inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a877dc8c0ae9a584907d45328512720cc">increment_node_ids</a> (long increment)</td></tr>
<tr class="memdesc:a877dc8c0ae9a584907d45328512720cc inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">This specialization for long appears to be needed to avoid confusion about nid_t.  <a href="classhandlegraph_1_1MutableHandleGraph.html#a877dc8c0ae9a584907d45328512720cc">More...</a><br /></td></tr>
<tr class="separator:a877dc8c0ae9a584907d45328512720cc inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1DeletableHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">handlegraph::DeletableHandleGraph</a></td></tr>
<tr class="memitem:a62ed805e124ceb05cfa98d4e631a9ebd inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#a62ed805e124ceb05cfa98d4e631a9ebd">~DeletableHandleGraph</a> ()=default</td></tr>
<tr class="separator:a62ed805e124ceb05cfa98d4e631a9ebd inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65cef3b3261f8d1bc2057c5f2ee100a inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#aa65cef3b3261f8d1bc2057c5f2ee100a">truncate_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool trunc_left, size_t offset)</td></tr>
<tr class="separator:aa65cef3b3261f8d1bc2057c5f2ee100a inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2b397c1b4ec7f9c75ccc5b9ce06564 inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#aec2b397c1b4ec7f9c75ccc5b9ce06564">destroy_edge</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge)</td></tr>
<tr class="memdesc:aec2b397c1b4ec7f9c75ccc5b9ce06564 inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient wrapper for destroy_edge.  <a href="classhandlegraph_1_1DeletableHandleGraph.html#aec2b397c1b4ec7f9c75ccc5b9ce06564">More...</a><br /></td></tr>
<tr class="separator:aec2b397c1b4ec7f9c75ccc5b9ce06564 inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1Serializable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1Serializable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1Serializable.html">handlegraph::Serializable</a></td></tr>
<tr class="memitem:ade5618a9c7a93b72550fdbb06ca41518 inherit pub_methods_classhandlegraph_1_1Serializable"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1Serializable.html#ade5618a9c7a93b72550fdbb06ca41518">~Serializable</a> ()=default</td></tr>
<tr class="separator:ade5618a9c7a93b72550fdbb06ca41518 inherit pub_methods_classhandlegraph_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae323cce9552f03774ab71dd5fb07d0 inherit pub_methods_classhandlegraph_1_1Serializable"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1Serializable.html#adae323cce9552f03774ab71dd5fb07d0">serialize</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:adae323cce9552f03774ab71dd5fb07d0 inherit pub_methods_classhandlegraph_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e9dfc830acdf96fbfe53d83d33802e inherit pub_methods_classhandlegraph_1_1Serializable"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1Serializable.html#ac6e9dfc830acdf96fbfe53d83d33802e">serialize</a> (const std::string &amp;filename) const</td></tr>
<tr class="separator:ac6e9dfc830acdf96fbfe53d83d33802e inherit pub_methods_classhandlegraph_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e101879c6d02c4d189248c9bc340319 inherit pub_methods_classhandlegraph_1_1Serializable"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1Serializable.html#a2e101879c6d02c4d189248c9bc340319">deserialize</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a2e101879c6d02c4d189248c9bc340319 inherit pub_methods_classhandlegraph_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b89e4a5c2a4724fe8748c586dd8ccf inherit pub_methods_classhandlegraph_1_1Serializable"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1Serializable.html#ad3b89e4a5c2a4724fe8748c586dd8ccf">deserialize</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:ad3b89e4a5c2a4724fe8748c586dd8ccf inherit pub_methods_classhandlegraph_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050e6c2b6e2fccd85362e908da60d20b inherit pub_methods_classhandlegraph_1_1Serializable"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1Serializable.html#a050e6c2b6e2fccd85362e908da60d20b">serialize</a> (std::ostream &amp;out)</td></tr>
<tr class="separator:a050e6c2b6e2fccd85362e908da60d20b inherit pub_methods_classhandlegraph_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97699c9b50235d5f2439eb57c5df653 inherit pub_methods_classhandlegraph_1_1Serializable"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1Serializable.html#aa97699c9b50235d5f2439eb57c5df653">serialize</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:aa97699c9b50235d5f2439eb57c5df653 inherit pub_methods_classhandlegraph_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a791e3c6c641e48f12475eb7c0e610f04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a791e3c6c641e48f12475eb7c0e610f04">follow_edges_impl</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;iteratee) const</td></tr>
<tr class="separator:a791e3c6c641e48f12475eb7c0e610f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a03c7c43b17ab8e20d1ce25038599bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a2a03c7c43b17ab8e20d1ce25038599bd">for_each_handle_impl</a> (const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;iteratee, bool parallel=false) const</td></tr>
<tr class="separator:a2a03c7c43b17ab8e20d1ce25038599bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c121314db5b735c0697bfa380eb837"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a94c121314db5b735c0697bfa380eb837">for_each_path_handle_impl</a> (const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; &amp;iteratee) const</td></tr>
<tr class="memdesc:a94c121314db5b735c0697bfa380eb837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a function on each path in the graph.  <a href="#a94c121314db5b735c0697bfa380eb837">More...</a><br /></td></tr>
<tr class="separator:a94c121314db5b735c0697bfa380eb837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16e82b77edebf5bceb31301bddbac2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#ac16e82b77edebf5bceb31301bddbac2a">for_each_step_on_handle_impl</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;)&gt; &amp;iteratee) const</td></tr>
<tr class="memdesc:ac16e82b77edebf5bceb31301bddbac2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate the path steps on a given handle (strand agnostic)  <a href="#ac16e82b77edebf5bceb31301bddbac2a">More...</a><br /></td></tr>
<tr class="separator:ac16e82b77edebf5bceb31301bddbac2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611a37a8f9cc6612e6fdf9039da6839f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a611a37a8f9cc6612e6fdf9039da6839f">has_linear_next_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="memdesc:a611a37a8f9cc6612e6fdf9039da6839f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the step has a next step on the path that doesn't wrap around, else false.  <a href="#a611a37a8f9cc6612e6fdf9039da6839f">More...</a><br /></td></tr>
<tr class="separator:a611a37a8f9cc6612e6fdf9039da6839f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e083851337fd6d17f4d198d6442fff9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a9e083851337fd6d17f4d198d6442fff9">has_linear_previous_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="memdesc:a9e083851337fd6d17f4d198d6442fff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the step has a previous step on the path that doesn't wrap around, else false.  <a href="#a9e083851337fd6d17f4d198d6442fff9">More...</a><br /></td></tr>
<tr class="separator:a9e083851337fd6d17f4d198d6442fff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:adb5e739dd1620c10e832108bb95eeeb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#adb5e739dd1620c10e832108bb95eeeb3">serialize_members</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:adb5e739dd1620c10e832108bb95eeeb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization that implements the inherited "serialze" method.  <a href="#adb5e739dd1620c10e832108bb95eeeb3">More...</a><br /></td></tr>
<tr class="separator:adb5e739dd1620c10e832108bb95eeeb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8051835b531ba5f1c5c6c21205c18f01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a8051835b531ba5f1c5c6c21205c18f01">deserialize_members</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:a8051835b531ba5f1c5c6c21205c18f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialization that implements the inherited "deserialze" method.  <a href="#a8051835b531ba5f1c5c6c21205c18f01">More...</a><br /></td></tr>
<tr class="separator:a8051835b531ba5f1c5c6c21205c18f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76e1e0b1dcf885b26edbf02a4bccca5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#ac76e1e0b1dcf885b26edbf02a4bccca5">canonicalize_edge</a> (<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right) const</td></tr>
<tr class="separator:ac76e1e0b1dcf885b26edbf02a4bccca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a47baa8c05034f7ea104b860f4bb500"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a2a47baa8c05034f7ea104b860f4bb500">edge_delta_to_id</a> (uint64_t left, uint64_t delta) const</td></tr>
<tr class="memdesc:a2a47baa8c05034f7ea104b860f4bb500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to convert between edge storage and actual id.  <a href="#a2a47baa8c05034f7ea104b860f4bb500">More...</a><br /></td></tr>
<tr class="separator:a2a47baa8c05034f7ea104b860f4bb500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32634eb3a1d22c1b0049d7941cc0ac90"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a32634eb3a1d22c1b0049d7941cc0ac90">edge_to_delta</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right) const</td></tr>
<tr class="memdesc:a32634eb3a1d22c1b0049d7941cc0ac90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to convert between ids and stored edge.  <a href="#a32634eb3a1d22c1b0049d7941cc0ac90">More...</a><br /></td></tr>
<tr class="separator:a32634eb3a1d22c1b0049d7941cc0ac90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32a71cc6154412610201ce34b47d6cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#aa32a71cc6154412610201ce34b47d6cf">destroy_path_handle_records</a> (uint64_t i)</td></tr>
<tr class="memdesc:aa32a71cc6154412610201ce34b47d6cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to simplify removal of path handle records.  <a href="#aa32a71cc6154412610201ce34b47d6cf">More...</a><br /></td></tr>
<tr class="separator:aa32a71cc6154412610201ce34b47d6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfdedab948ca178b87f3f6ff31edafb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a9dfdedab948ca178b87f3f6ff31edafb">create_step</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle)</td></tr>
<tr class="memdesc:a9dfdedab948ca178b87f3f6ff31edafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to create the internal records for the step.  <a href="#a9dfdedab948ca178b87f3f6ff31edafb">More...</a><br /></td></tr>
<tr class="separator:a9dfdedab948ca178b87f3f6ff31edafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8154aa4f5f9b0e9aa0a80043c53cb2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#ae8154aa4f5f9b0e9aa0a80043c53cb2f">destroy_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle, bool clean_up_empty_path=true)</td></tr>
<tr class="memdesc:ae8154aa4f5f9b0e9aa0a80043c53cb2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to destroy the internal records for the step.  <a href="#ae8154aa4f5f9b0e9aa0a80043c53cb2f">More...</a><br /></td></tr>
<tr class="separator:ae8154aa4f5f9b0e9aa0a80043c53cb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b838cef09db03164c14ecfa74bd4dbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a8b838cef09db03164c14ecfa74bd4dbe">link_steps</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;from, const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;to)</td></tr>
<tr class="memdesc:a8b838cef09db03164c14ecfa74bd4dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to stitch up partially built paths.  <a href="#a8b838cef09db03164c14ecfa74bd4dbe">More...</a><br /></td></tr>
<tr class="separator:a8b838cef09db03164c14ecfa74bd4dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead08eef70b458c7437b1b426c66553f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#aead08eef70b458c7437b1b426c66553f">decrement_rank</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle)</td></tr>
<tr class="memdesc:aead08eef70b458c7437b1b426c66553f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the step rank references for this step.  <a href="#aead08eef70b458c7437b1b426c66553f">More...</a><br /></td></tr>
<tr class="separator:aead08eef70b458c7437b1b426c66553f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab673c6dd900657a2a31ee9ea0dbf2611"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#ab673c6dd900657a2a31ee9ea0dbf2611">set_handle_of_step</a> (<a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:ab673c6dd900657a2a31ee9ea0dbf2611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the given step handle to point to the given handle.  <a href="#ab673c6dd900657a2a31ee9ea0dbf2611">More...</a><br /></td></tr>
<tr class="separator:ab673c6dd900657a2a31ee9ea0dbf2611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0732e24fcd5aabb78e109aa92aa1509e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbdsg_1_1ODGI_1_1path__metadata__t.html">path_metadata_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a0732e24fcd5aabb78e109aa92aa1509e">find_metadata</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path)</td></tr>
<tr class="memdesc:a0732e24fcd5aabb78e109aa92aa1509e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the path metadata for a path.  <a href="#a0732e24fcd5aabb78e109aa92aa1509e">More...</a><br /></td></tr>
<tr class="separator:a0732e24fcd5aabb78e109aa92aa1509e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b27bbcef4c2efe28b9ee26759a1aba1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structbdsg_1_1ODGI_1_1path__metadata__t.html">path_metadata_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a5b27bbcef4c2efe28b9ee26759a1aba1">find_metadata</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path) const</td></tr>
<tr class="memdesc:a5b27bbcef4c2efe28b9ee26759a1aba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the metadata for a path, read-only.  <a href="#a5b27bbcef4c2efe28b9ee26759a1aba1">More...</a><br /></td></tr>
<tr class="separator:a5b27bbcef4c2efe28b9ee26759a1aba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23d11fddc9cb68d5b80b4b557954bbe"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#af23d11fddc9cb68d5b80b4b557954bbe">path_to_rank</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path) const</td></tr>
<tr class="memdesc:af23d11fddc9cb68d5b80b4b557954bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the 0-based rank encoded by a path handle.  <a href="#af23d11fddc9cb68d5b80b4b557954bbe">More...</a><br /></td></tr>
<tr class="separator:af23d11fddc9cb68d5b80b4b557954bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8541c8178fd0a21db8579db55b53ca39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a8541c8178fd0a21db8579db55b53ca39">rank_to_path</a> (size_t rank) const</td></tr>
<tr class="memdesc:a8541c8178fd0a21db8579db55b53ca39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the path handle encoding the given 0-based rank.  <a href="#a8541c8178fd0a21db8579db55b53ca39">More...</a><br /></td></tr>
<tr class="separator:a8541c8178fd0a21db8579db55b53ca39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db273d2507e0e7960d0b1fa2d439d1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a8db273d2507e0e7960d0b1fa2d439d1b">add_to_number</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, int64_t offset) const</td></tr>
<tr class="separator:a8db273d2507e0e7960d0b1fa2d439d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3304c7fd92ccdc8b7492df7a18c97d89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a3304c7fd92ccdc8b7492df7a18c97d89">set_handle_sequence</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const std::string &amp;seq)</td></tr>
<tr class="memdesc:a3304c7fd92ccdc8b7492df7a18c97d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compact away the deleted nodes info.  <a href="#a3304c7fd92ccdc8b7492df7a18c97d89">More...</a><br /></td></tr>
<tr class="separator:a3304c7fd92ccdc8b7492df7a18c97d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75675edac6cc43b4aaaf9328d51279cf"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a75675edac6cc43b4aaaf9328d51279cf">id_to_rank</a> (const <a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> &amp;node_id) const</td></tr>
<tr class="memdesc:a75675edac6cc43b4aaaf9328d51279cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the backing node rank for a given node id  <a href="#a75675edac6cc43b4aaaf9328d51279cf">More...</a><br /></td></tr>
<tr class="separator:a75675edac6cc43b4aaaf9328d51279cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2629006a078b90f4e6306d6bc8c133be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a2629006a078b90f4e6306d6bc8c133be">rank_to_id</a> (const uint64_t &amp;rank) const</td></tr>
<tr class="memdesc:a2629006a078b90f4e6306d6bc8c133be"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the node id for the node with the given backing rank  <a href="#a2629006a078b90f4e6306d6bc8c133be">More...</a><br /></td></tr>
<tr class="separator:a2629006a078b90f4e6306d6bc8c133be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a845e5fd6eee78d6105091f8cbb37a06d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; node_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a845e5fd6eee78d6105091f8cbb37a06d">node_v</a></td></tr>
<tr class="memdesc:a845e5fd6eee78d6105091f8cbb37a06d"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are the backing data structures that we use to fulfill the above functions.  <a href="#a845e5fd6eee78d6105091f8cbb37a06d">More...</a><br /></td></tr>
<tr class="separator:a845e5fd6eee78d6105091f8cbb37a06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef8013c0bbc64e9e4ba1ba9faf74985"><td class="memItemLeft" align="right" valign="top">suc_bv&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#aaef8013c0bbc64e9e4ba1ba9faf74985">deleted_node_bv</a></td></tr>
<tr class="memdesc:aaef8013c0bbc64e9e4ba1ba9faf74985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark deleted nodes here for translating graph ids into internal ranks.  <a href="#aaef8013c0bbc64e9e4ba1ba9faf74985">More...</a><br /></td></tr>
<tr class="separator:aaef8013c0bbc64e9e4ba1ba9faf74985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ba4eff77a484fb635e6275b3294d39"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a27ba4eff77a484fb635e6275b3294d39">_deleted_node_count</a> = 0</td></tr>
<tr class="separator:a27ba4eff77a484fb635e6275b3294d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c79025549d3e373a09fe471d09c8808"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a1c79025549d3e373a09fe471d09c8808">_max_node_rank</a> = 0</td></tr>
<tr class="separator:a1c79025549d3e373a09fe471d09c8808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcd0546ab6e96642d38570f642a6a2a"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#abbcd0546ab6e96642d38570f642a6a2a">_min_node_rank</a> = std::numeric_limits&lt;decltype(_min_node_rank)&gt;::max()</td></tr>
<tr class="separator:abbcd0546ab6e96642d38570f642a6a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042ef9861a75537a35e26d2dd31516c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a042ef9861a75537a35e26d2dd31516c6">_id_increment</a> = 1</td></tr>
<tr class="separator:a042ef9861a75537a35e26d2dd31516c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8bceab131b7a51df75c8b2354dc215"><td class="memItemLeft" align="right" valign="top">hash_set&lt; <a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#aec8bceab131b7a51df75c8b2354dc215">graph_id_hidden_set</a></td></tr>
<tr class="separator:aec8bceab131b7a51df75c8b2354dc215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c86ac9e3606a17826e01c73719ee0d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structbdsg_1_1ODGI_1_1path__metadata__t.html">path_metadata_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a82c86ac9e3606a17826e01c73719ee0d">path_metadata_v</a></td></tr>
<tr class="memdesc:a82c86ac9e3606a17826e01c73719ee0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps between path identifier and the start, end, and length of the path  <a href="#a82c86ac9e3606a17826e01c73719ee0d">More...</a><br /></td></tr>
<tr class="separator:a82c86ac9e3606a17826e01c73719ee0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427c27fc015bebd3177ffafc8517c728"><td class="memItemLeft" align="right" valign="top">string_hash_map&lt; std::string, <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a427c27fc015bebd3177ffafc8517c728">path_name_map</a></td></tr>
<tr class="memdesc:a427c27fc015bebd3177ffafc8517c728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Links path names to handles.  <a href="#a427c27fc015bebd3177ffafc8517c728">More...</a><br /></td></tr>
<tr class="separator:a427c27fc015bebd3177ffafc8517c728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bc41b3879acd02979c22f841791e6e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a22bc41b3879acd02979c22f841791e6e">_node_count</a> = 0</td></tr>
<tr class="memdesc:a22bc41b3879acd02979c22f841791e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper to record the number of live nodes.  <a href="#a22bc41b3879acd02979c22f841791e6e">More...</a><br /></td></tr>
<tr class="separator:a22bc41b3879acd02979c22f841791e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a55ac331a90b588e7f795572c4b0963"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a8a55ac331a90b588e7f795572c4b0963">_edge_count</a> = 0</td></tr>
<tr class="memdesc:a8a55ac331a90b588e7f795572c4b0963"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper to record the number of live edges.  <a href="#a8a55ac331a90b588e7f795572c4b0963">More...</a><br /></td></tr>
<tr class="separator:a8a55ac331a90b588e7f795572c4b0963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40a397647ed92d84ea2bb418bad40bb"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#ac40a397647ed92d84ea2bb418bad40bb">_path_count</a> = 0</td></tr>
<tr class="memdesc:ac40a397647ed92d84ea2bb418bad40bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper to record the number of live paths.  <a href="#ac40a397647ed92d84ea2bb418bad40bb">More...</a><br /></td></tr>
<tr class="separator:ac40a397647ed92d84ea2bb418bad40bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d66ceb7a06f6dd27922015b755b1b8e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1ODGI.html#a9d66ceb7a06f6dd27922015b755b1b8e">_path_rank_next</a> = 0</td></tr>
<tr class="memdesc:a9d66ceb7a06f6dd27922015b755b1b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper to record the next path rank to use (path deletions are hard because of our path FM-index)  <a href="#a9d66ceb7a06f6dd27922015b755b1b8e">More...</a><br /></td></tr>
<tr class="separator:a9d66ceb7a06f6dd27922015b755b1b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classbdsg_1_1ODGI.html">ODGI</a> (Optimized Dynamic Graph Index) is a good all-around HandleGraph implementation. It represents nodes as C++ objects stored in a vector, but aggressively bit-packs and delta-compresses edge and path step information within each node. Using separate node objects can reduce the need for defragmentation as in <a class="el" href="classbdsg_1_1PackedGraph.html">PackedGraph</a>, but some deletion operations are still lazy.</p>
<p><a class="el" href="classbdsg_1_1ODGI.html">ODGI</a> is a good implementation to choose if you don't need your graph to be as small as <a class="el" href="classbdsg_1_1PackedGraph.html">PackedGraph</a> or as fast to access as <a class="el" href="classbdsg_1_1HashGraph.html">HashGraph</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa10931aaf9f517e6c5063ab5aabd6e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10931aaf9f517e6c5063ab5aabd6e80">&#9670;&nbsp;</a></span>ODGI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bdsg::ODGI::ODGI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a657c2084681b06ffa4fd8cf91d07a0fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657c2084681b06ffa4fd8cf91d07a0fe">&#9670;&nbsp;</a></span>~ODGI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bdsg::ODGI::~ODGI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8db273d2507e0e7960d0b1fa2d439d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db273d2507e0e7960d0b1fa2d439d1b">&#9670;&nbsp;</a></span>add_to_number()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> bdsg::ODGI::add_to_number </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add the offset to the number packed in the given handle, and return a new modified handle. </p>

</div>
</div>
<a id="af9b068258f3a98847bcde404ef293d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b068258f3a98847bcde404ef293d9c">&#9670;&nbsp;</a></span>append_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> bdsg::ODGI::append_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to_append</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Append a visit to a node to the given path. Returns a handle to the new final step on the path which is appended. Handles to prior steps on the path, and to other paths, must remain valid. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a83a4a14a629cde03d33e4eb3f6bb192d">handlegraph::MutablePathHandleGraph</a>.</p>

</div>
</div>
<a id="a1e5830007d8a3487d0e065a57edce76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e5830007d8a3487d0e065a57edce76a">&#9670;&nbsp;</a></span>apply_ordering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::apply_ordering </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>order_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compact_ids</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reorder the graph's internal structure to match that given. Optionally compact the id space of the graph to match the ordering, from 1-&gt;|ordering|. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a7e14ea0ae201ba87934559ecbd3a2981">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a id="a7cdfaacd138082595779b01f54e5df8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cdfaacd138082595779b01f54e5df8b">&#9670;&nbsp;</a></span>apply_orientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> bdsg::ODGI::apply_orientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alter the node that the given handle corresponds to so the orientation indicated by the handle becomes the node's local forward orientation. Rewrites all edges pointing to the node and the node's sequence to reflect this. Invalidates all handles to the node (including the one passed). Returns a new, valid handle to the node in its new forward orientation. Note that it is possible for the node's ID to change. Updates all stored paths. May change the ordering of the underlying graph. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a71433449cb13e22dc19caaf544b6d7bc">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a id="a570d9d9907f0ad71f127f9345166437e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a570d9d9907f0ad71f127f9345166437e">&#9670;&nbsp;</a></span>apply_path_ordering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::apply_path_ordering </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder the graph's paths as given. </p>

</div>
</div>
<a id="ac76e1e0b1dcf885b26edbf02a4bccca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76e1e0b1dcf885b26edbf02a4bccca5">&#9670;&nbsp;</a></span>canonicalize_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::canonicalize_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a03fb2ec6571cc5bfa141827303a530cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03fb2ec6571cc5bfa141827303a530cf">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all nodes, edges, and paths. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#a6e1a83e72b47643e43c6176f39d8db5e">handlegraph::DeletableHandleGraph</a>.</p>

</div>
</div>
<a id="a0751769e5119ed6b511d715564fc94b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0751769e5119ed6b511d715564fc94b3">&#9670;&nbsp;</a></span>clear_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::clear_paths </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all stored paths. </p>

</div>
</div>
<a id="a8ff3e1fdc8b210547d871d3014e670ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff3e1fdc8b210547d871d3014e670ba">&#9670;&nbsp;</a></span>combine_handles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> bdsg::ODGI::combine_handles </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>handles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34b8028afdfac4bc5f14ab58de8e4a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b8028afdfac4bc5f14ab58de8e4a8c">&#9670;&nbsp;</a></span>create_edge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::create_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>left_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right_h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an edge connecting the given handles in the given order and orientations. Ignores existing edges. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a34a5e01f270713ba856a93c55039faf0">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a id="a1f05c91a157684e6321a1cbcf83467e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f05c91a157684e6321a1cbcf83467e2">&#9670;&nbsp;</a></span>create_edge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::create_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenient wrapper for create_edge. </p>

</div>
</div>
<a id="a4d4789eb41a9285a0dbc8c3f7dfe41b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4789eb41a9285a0dbc8c3f7dfe41b0">&#9670;&nbsp;</a></span>create_handle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> bdsg::ODGI::create_handle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new node with the given sequence and return the handle. </p>
<p>Create a new node with the given sequence and return the handle. The sequence may not be empty. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a8c9d8ca8160a9b94a57000eab3e97aaa">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a id="a452b70cec271a66a9f154cfa40ed6466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452b70cec271a66a9f154cfa40ed6466">&#9670;&nbsp;</a></span>create_handle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> bdsg::ODGI::create_handle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new node with the given id and sequence, then return the handle. </p>
<p>Create a new node with the given id and sequence, then return the handle. The sequence may not be empty. The ID must be strictly greater than 0. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#ae844fce457858cd2dc54dde786f79e5c">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a id="aceea39a6c1a3ca2404d36cb968970f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceea39a6c1a3ca2404d36cb968970f62">&#9670;&nbsp;</a></span>create_hidden_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> bdsg::ODGI::create_hidden_handle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a node that is immediately "hidden" (i.e. to be used for parts of paths that traversed deleted portions of the graph). has_node for the ID of a hidden handle will return false. Also, no edges may be added to it. </p>

</div>
</div>
<a id="a127ed64f4237d7b307e73633508c7e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127ed64f4237d7b307e73633508c7e5d">&#9670;&nbsp;</a></span>create_path_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> bdsg::ODGI::create_path_handle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_circular</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a path with the given name. The caller must ensure that no path with the given name exists already, or the behavior is undefined. Returns a handle to the created empty path. Handles to other paths must remain valid. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a0873a6eb776bb2557a5b8453dbf13824">handlegraph::MutablePathHandleGraph</a>.</p>

</div>
</div>
<a id="a9dfdedab948ca178b87f3f6ff31edafb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dfdedab948ca178b87f3f6ff31edafb">&#9670;&nbsp;</a></span>create_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> bdsg::ODGI::create_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to create the internal records for the step. </p>

</div>
</div>
<a id="aead08eef70b458c7437b1b426c66553f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead08eef70b458c7437b1b426c66553f">&#9670;&nbsp;</a></span>decrement_rank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::decrement_rank </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrement the step rank references for this step. </p>
<p>helper to handle the case where we remove an step from a given path on a node that has other steps from the same path, thus invalidating the ranks used to refer to it </p>

</div>
</div>
<a id="a8051835b531ba5f1c5c6c21205c18f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8051835b531ba5f1c5c6c21205c18f01">&#9670;&nbsp;</a></span>deserialize_members()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::deserialize_members </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialization that implements the inherited "deserialze" method. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1Serializable.html#a33651ea0e5d56a7a1471f8f0ce10b95d">handlegraph::Serializable</a>.</p>

</div>
</div>
<a id="ac899f9aba8759607a6629ef40ff8ca4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac899f9aba8759607a6629ef40ff8ca4f">&#9670;&nbsp;</a></span>destroy_edge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::destroy_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>left_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right_h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove the edge connecting the given handles in the given order and orientations. Ignores nonexistent edges. Does not update any stored paths. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#a285ac35e805eab548c4106ee534d79f2">handlegraph::DeletableHandleGraph</a>.</p>

</div>
</div>
<a id="aa6710e4471ebadab935e9d5da028b3fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6710e4471ebadab935e9d5da028b3fa">&#9670;&nbsp;</a></span>destroy_edge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::destroy_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenient wrapper for destroy_edge. </p>

</div>
</div>
<a id="a63156a0199c9382de3b196aeef7d845e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63156a0199c9382de3b196aeef7d845e">&#9670;&nbsp;</a></span>destroy_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::destroy_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove the node belonging to the given handle and all of its edges. If any paths visit it, it becomes a "hidden" node accessible only via the paths. Invalidates the destroyed handle. May be called during serial for_each_handle iteration <b>ONLY</b> on the node being iterated. May <b>NOT</b> be called during parallel for_each_handle iteration. May <b>NOT</b> be called on the node from which edges are being followed during follow_edges.</p>
<p>Remove the node belonging to the given handle and all of its edges. If any paths visit it, it becomes a "hidden" node accessible only via the paths. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#a06d4d3ecda0694d5045c457f3eecd8e3">handlegraph::DeletableHandleGraph</a>.</p>

</div>
</div>
<a id="ab1265a7527979210c56e990e08d4e650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1265a7527979210c56e990e08d4e650">&#9670;&nbsp;</a></span>destroy_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::destroy_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the interface for a handle graph with embedded paths where the paths can be modified. Note that if the <em>graph</em> can also be modified, the implementation will also need to inherit from MutableHandleGraph, via the combination MutablePathMutableHandleGraph interface. TODO: This is a very limited interface at the moment. It will probably need to be extended. Destroy the given path. Invalidates handles to the path and its node steps.</p>
<p>Destroy the given path. Invalidates handles to the path and its node steps. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a05a7303ef2f259c6384b0b9b1f9d3f56">handlegraph::MutablePathHandleGraph</a>.</p>

</div>
</div>
<a id="aa32a71cc6154412610201ce34b47d6cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32a71cc6154412610201ce34b47d6cf">&#9670;&nbsp;</a></span>destroy_path_handle_records()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::destroy_path_handle_records </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to simplify removal of path handle records. </p>

</div>
</div>
<a id="ae8154aa4f5f9b0e9aa0a80043c53cb2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8154aa4f5f9b0e9aa0a80043c53cb2f">&#9670;&nbsp;</a></span>destroy_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::destroy_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clean_up_empty_path</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to destroy the internal records for the step. </p>

</div>
</div>
<a id="a3f6df0eaba6bfd6781eee8297f3781d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6df0eaba6bfd6781eee8297f3781d0">&#9670;&nbsp;</a></span>display()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::display </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A helper function to visualize the state of the graph. </p>
<p>Ordered across the nodes in graph_id_iv, stores the path ids (1-based) at each segment in seq_wt, delimited by 0, one for each path step (node traversal).</p>
<p>Stores path names in their internal order, delimited by '$'</p>
<p>Marks the beginning of each path name </p>

</div>
</div>
<a id="ac5e011120475409b6f7b8ad93e4c2ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e011120475409b6f7b8ad93e4c2ab4">&#9670;&nbsp;</a></span>divide_handle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; bdsg::ODGI::divide_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a handle's underlying node at the given offsets in the handle's orientation. Returns all of the handles to the parts. Other handles to the node being split may be invalidated. The split pieces stay in the same local forward orientation as the original node, but the returned handles come in the order and orientation appropriate for the handle passed in. Updates stored paths. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#aca166406fa2000778552ed77c41a5e4c">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a id="aabcb735a0bffdcabd247628a5f7f8b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabcb735a0bffdcabd247628a5f7f8b5b">&#9670;&nbsp;</a></span>divide_handle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&gt; bdsg::ODGI::divide_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialization of divide_handle for a single division point. </p>

</div>
</div>
<a id="a2a47baa8c05034f7ea104b860f4bb500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a47baa8c05034f7ea104b860f4bb500">&#9670;&nbsp;</a></span>edge_delta_to_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::ODGI::edge_delta_to_id </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to convert between edge storage and actual id. </p>

</div>
</div>
<a id="aa9f151b46b20a3c08314058c69c37ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f151b46b20a3c08314058c69c37ba4">&#9670;&nbsp;</a></span>edge_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> bdsg::ODGI::edge_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A pair of handles can be used as an edge. When so used, the handles have a canonical order and orientation. </p>

</div>
</div>
<a id="a32634eb3a1d22c1b0049d7941cc0ac90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32634eb3a1d22c1b0049d7941cc0ac90">&#9670;&nbsp;</a></span>edge_to_delta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::ODGI::edge_to_delta </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to convert between ids and stored edge. </p>

</div>
</div>
<a id="a0732e24fcd5aabb78e109aa92aa1509e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0732e24fcd5aabb78e109aa92aa1509e">&#9670;&nbsp;</a></span>find_metadata() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbdsg_1_1ODGI_1_1path__metadata__t.html">ODGI::path_metadata_t</a> &amp; bdsg::ODGI::find_metadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the path metadata for a path. </p>

</div>
</div>
<a id="a5b27bbcef4c2efe28b9ee26759a1aba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b27bbcef4c2efe28b9ee26759a1aba1">&#9670;&nbsp;</a></span>find_metadata() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structbdsg_1_1ODGI_1_1path__metadata__t.html">ODGI::path_metadata_t</a> &amp; bdsg::ODGI::find_metadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the metadata for a path, read-only. </p>

</div>
</div>
<a id="a46a9c756c01f41b0ee07dea7be704cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a9c756c01f41b0ee07dea7be704cb9">&#9670;&nbsp;</a></span>flip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> bdsg::ODGI::flip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invert the orientation of a handle (potentially without getting its ID) </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#aaa3f94ae7e884408ef6e8ca8fd45c7d7">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a791e3c6c641e48f12475eb7c0e610f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791e3c6c641e48f12475eb7c0e610f04">&#9670;&nbsp;</a></span>follow_edges_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::ODGI::follow_edges_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>go_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loop over all the handles to next/previous (right/left) nodes. Passes them to a callback which returns false to stop iterating and true to continue. Returns true if we finished and false if we stopped early. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a89bbc118fe1e8e1acb162c14be33e8b5">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a2a03c7c43b17ab8e20d1ce25038599bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a03c7c43b17ab8e20d1ce25038599bd">&#9670;&nbsp;</a></span>for_each_handle_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::ODGI::for_each_handle_impl </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loop over all the nodes in the graph in their local forward orientations, in their internal stored order. Stop if the iteratee returns false. Can be told to run in parallel, in which case stopping after a false return value is on a best-effort basis and iteration order is not defined. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#af48ba081fcb810267dc50e3a3e7ad391">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a94c121314db5b735c0697bfa380eb837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c121314db5b735c0697bfa380eb837">&#9670;&nbsp;</a></span>for_each_path_handle_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::ODGI::for_each_path_handle_impl </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a function on each path in the graph. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a79f48793555f6be311f6df6603324e7b">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="af9aa896439054373d5f048fc64bcaf12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9aa896439054373d5f048fc64bcaf12">&#9670;&nbsp;</a></span>for_each_step_in_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::for_each_step_in_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loop over all the steps along a path, from first through last. </p>
<p>This is the interface for a handle graph that supports modification. </p>

</div>
</div>
<a id="ac16e82b77edebf5bceb31301bddbac2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16e82b77edebf5bceb31301bddbac2a">&#9670;&nbsp;</a></span>for_each_step_on_handle_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::ODGI::for_each_step_on_handle_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerate the path steps on a given handle (strand agnostic) </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a2bbdf56b268001c629cf000f5bd8bb9a">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a283642a6aa72294926826b3e429bcb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a283642a6aa72294926826b3e429bcb34">&#9670;&nbsp;</a></span>forward()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> bdsg::ODGI::forward </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the locally forward version of a handle. </p>

</div>
</div>
<a id="a1f762f9a7977278859307a9c16a0ca9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f762f9a7977278859307a9c16a0ca9d">&#9670;&nbsp;</a></span>get_degree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t bdsg::ODGI::get_degree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>go_left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a handle from a Visit Protobuf object. Must be using'd to avoid shadowing. Get the number of edges on the right (go_left = false) or left (go_left = true) side of the given handle. The default implementation is O(n) in the number of edges returned, but graph implementations that track this information more efficiently can override this method.</p>
<p>Get the number of edges on the right (go_left = false) or left (go_left = true) side of the given handle. The default implementation is O(n) in the number of edges returned, but graph implementations that track this information more efficiently can override this method. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1HandleGraph.html#ab259e3aba0da47b0ef1c9b5e43c7d209">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a0a29e97e52486fdcd85de1503301bc89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a29e97e52486fdcd85de1503301bc89">&#9670;&nbsp;</a></span>get_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> bdsg::ODGI::get_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> &amp;&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up the handle for the node with the given ID in the given orientation. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a6dd9d70931835f5c75518b23a780b744">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="ac8cad8b4fd7cbc45c63d6a24aae9e08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8cad8b4fd7cbc45c63d6a24aae9e08c">&#9670;&nbsp;</a></span>get_handle_of_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> bdsg::ODGI::get_handle_of_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a node handle (node ID and orientation) from a handle to an step on a path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a339e690ce3e2bb8280dd1f3ea45abe42">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="aa4d4ea7145009f15a6ea56bc308f3b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d4ea7145009f15a6ea56bc308f3b3a">&#9670;&nbsp;</a></span>get_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> bdsg::ODGI::get_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ID from a handle. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#adb7f6e144bf2a59679f7b2eddad934eb">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a21969e49be312b2fec4af7372ea516c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21969e49be312b2fec4af7372ea516c0">&#9670;&nbsp;</a></span>get_is_circular()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::ODGI::get_is_circular </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the path is circular. </p>
<p>is the path circular </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a9391c34d9f0c16b21d5bb3bb7ec772e4">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a7cb485a462f1093a06d02b7bbe01bc82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb485a462f1093a06d02b7bbe01bc82">&#9670;&nbsp;</a></span>get_is_reverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::ODGI::get_is_reverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the orientation of a handle. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a92773f90eb58f18adb9418a4440223c1">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="af5f8d526bad1bf4b9cc836650e418a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f8d526bad1bf4b9cc836650e418a9d">&#9670;&nbsp;</a></span>get_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t bdsg::ODGI::get_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of a node. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a569ff35fb85c725b0b6b6933ed303e49">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a0b7e91edb2d2f3f5886c9cba85165d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7e91edb2d2f3f5886c9cba85165d91">&#9670;&nbsp;</a></span>get_magic_number()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t bdsg::ODGI::get_magic_number </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a high-entropy number to indicate which handle graph implementation this is. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1Serializable.html#a8879f13f2204a80a6c428883187961db">handlegraph::Serializable</a>.</p>

</div>
</div>
<a id="a9b25ea3cd9dd8deda455adcb54048758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b25ea3cd9dd8deda455adcb54048758">&#9670;&nbsp;</a></span>get_next_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> bdsg::ODGI::get_next_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a handle to the next step on the path. </p>
<p>Returns a handle to the next step on the path Returns the forward end iterator if none exists </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a209786f5c9e2c0210b383f2022ee221f">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a9ddeb239b50ed9039524ad64ded98134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ddeb239b50ed9039524ad64ded98134">&#9670;&nbsp;</a></span>get_node_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t bdsg::ODGI::get_node_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of nodes in the graph TODO: can't be node_count because XG has a field named node_count.</p>
<p>Return the number of nodes in the graph. Doesn't count deleted or hidden nodes. TODO: can't be node_count because XG has a field named node_count. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a9f95108e6c3f68f404fa93bd3306e4c6">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="aaaf1a14fd17058c4d8582b8c7c1d03bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf1a14fd17058c4d8582b8c7c1d03bd">&#9670;&nbsp;</a></span>get_path_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t bdsg::ODGI::get_path_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of paths stored in the graph. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#acd5df753593ecdfb7aa8c411b98ebad9">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a5272dacca04fba9b408d034dbacf538d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5272dacca04fba9b408d034dbacf538d">&#9670;&nbsp;</a></span>get_path_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> bdsg::ODGI::get_path_handle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Look up the path handle for the given path name. The path with that name must exist. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a5d6059d716882a80e3982de17011866e">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="aca22411d8d2b91cd5646d012d4cced32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca22411d8d2b91cd5646d012d4cced32">&#9670;&nbsp;</a></span>get_path_handle_of_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> bdsg::ODGI::get_path_handle_of_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a handle to the path that a step is on. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a1d1ca9865da585257709f54769f5d6a9">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a5aac861542bdd5019ca479b7a3a1eede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aac861542bdd5019ca479b7a3a1eede">&#9670;&nbsp;</a></span>get_path_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string bdsg::ODGI::get_path_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up the name of a path from a handle to it. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a565f4312a42dfe77ae14c1ee9ed9f2ba">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a0ddc5873bb8e56f00a7788ee269cc3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ddc5873bb8e56f00a7788ee269cc3f2">&#9670;&nbsp;</a></span>get_previous_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> bdsg::ODGI::get_previous_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a handle to the previous step on the path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a71040226b29aa5046f4cc04c8c9aa9fb">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a15bfc01300b6e922a4c7e18b5d8815fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15bfc01300b6e922a4c7e18b5d8815fd">&#9670;&nbsp;</a></span>get_sequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string bdsg::ODGI::get_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the sequence of a node, presented in the handle's local forward orientation. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a8cc2ab8a1292e30ba5e167a823f66d92">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a43e16430b1cf49be4c97acb99301f0f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e16430b1cf49be4c97acb99301f0f9">&#9670;&nbsp;</a></span>get_step_count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t bdsg::ODGI::get_step_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of node steps in the path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#add91075c3490f8dc5acf667f2b26832c">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a77cd4dee45911bb99040688f664d9c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77cd4dee45911bb99040688f664d9c79">&#9670;&nbsp;</a></span>get_step_count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t bdsg::ODGI::get_step_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of node steps on the handle. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a6d3a31f0c19054cd2908525119869b80">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a62b75b9735e7ca21c66488bea6baa4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b75b9735e7ca21c66488bea6baa4da">&#9670;&nbsp;</a></span>has_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::ODGI::has_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if an edge exists. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1HandleGraph.html#a069448fbe58665b9ff531ad0b8c5af57">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a611a37a8f9cc6612e6fdf9039da6839f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611a37a8f9cc6612e6fdf9039da6839f">&#9670;&nbsp;</a></span>has_linear_next_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::ODGI::has_linear_next_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the step has a next step on the path that doesn't wrap around, else false. </p>

</div>
</div>
<a id="a9e083851337fd6d17f4d198d6442fff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e083851337fd6d17f4d198d6442fff9">&#9670;&nbsp;</a></span>has_linear_previous_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::ODGI::has_linear_previous_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the step has a previous step on the path that doesn't wrap around, else false. </p>

</div>
</div>
<a id="aa5ec93e4c218d661208be27bb6dbcbac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ec93e4c218d661208be27bb6dbcbac">&#9670;&nbsp;</a></span>has_next_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::ODGI::has_next_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the step has a next step on the path, else false. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a81bf54cb4d07a0d47c84862ecebc349d">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a43a83407a5325e8a4fd95a54ab552fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a83407a5325e8a4fd95a54ab552fb6">&#9670;&nbsp;</a></span>has_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::ODGI::has_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to check if a node exists by ID. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a6e58a79001cd7d839ac1f1adaff34dfb">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="aefbb6d165884048871c0c71dfd5ec0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefbb6d165884048871c0c71dfd5ec0bd">&#9670;&nbsp;</a></span>has_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::ODGI::has_path </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if a path name exists and is legal to get a path handle for. </p>
<p>This is the interface for a handle graph that stores embedded paths. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#ab7de11c1e994bc104378c4b798013430">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a117c7a402f0deb7dfe3e4c60d5b85a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a117c7a402f0deb7dfe3e4c60d5b85a7c">&#9670;&nbsp;</a></span>has_previous_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::ODGI::has_previous_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the step has a previous step on the path, else false. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a93a1ee451e750cb82f1711fd6c3db8cc">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a75675edac6cc43b4aaaf9328d51279cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75675edac6cc43b4aaaf9328d51279cf">&#9670;&nbsp;</a></span>id_to_rank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::ODGI::id_to_rank </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> &amp;&#160;</td>
          <td class="paramname"><em>node_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the backing node rank for a given node id </p>

</div>
</div>
<a id="abb93e89319a1730e8aa1b4cd646b3a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb93e89319a1730e8aa1b4cd646b3a88">&#9670;&nbsp;</a></span>increment_node_ids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::increment_node_ids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a>&#160;</td>
          <td class="paramname"><em>increment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the given value to all node IDs. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a902b211a1f86645818b3da1cb64af0be">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a id="ab91a47ba26660fdd0022e193a5de05df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab91a47ba26660fdd0022e193a5de05df">&#9670;&nbsp;</a></span>insert_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> bdsg::ODGI::insert_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>after</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to_insert</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a visit to a node to the given path between the given steps. Returns a handle to the new step on the path which is appended. Handles to prior steps on the path, and to other paths, must remain valid. </p>

</div>
</div>
<a id="a2f1f969f0a4aa08e812324a4e3028872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1f969f0a4aa08e812324a4e3028872">&#9670;&nbsp;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::ODGI::is_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the given path is empty, and false otherwise. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#aef3f2c04d1e315e485460dcd902467cb">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="abd56c244b5681b99d4c68f3e829198a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd56c244b5681b99d4c68f3e829198a9">&#9670;&nbsp;</a></span>is_path_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::ODGI::is_path_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the step handle is an end magic handle. </p>

</div>
</div>
<a id="a11a124f7c425057df8fa48092dae6525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a124f7c425057df8fa48092dae6525">&#9670;&nbsp;</a></span>is_path_front_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::ODGI::is_path_front_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the step handle is a front end magic handle. </p>

</div>
</div>
<a id="a8b838cef09db03164c14ecfa74bd4dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b838cef09db03164c14ecfa74bd4dbe">&#9670;&nbsp;</a></span>link_steps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::link_steps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to stitch up partially built paths. </p>

</div>
</div>
<a id="a8b4feef9688b5ecd376e84bd693f0466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4feef9688b5ecd376e84bd693f0466">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::load </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load. </p>

</div>
</div>
<a id="a8597d305f14b4c572ebd3f3167b9067e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8597d305f14b4c572ebd3f3167b9067e">&#9670;&nbsp;</a></span>max_node_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> bdsg::ODGI::max_node_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the largest ID in the graph, or some larger number if the largest ID is unavailable. Return value is unspecified if the graph is empty. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a5a2e2b1ea6a29b3f4b34a6abcb6dbc50">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a77442cc3333d7fd0d1f2dcefe02d8645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77442cc3333d7fd0d1f2dcefe02d8645">&#9670;&nbsp;</a></span>min_node_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> bdsg::ODGI::min_node_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the smallest ID in the graph, or some smaller number if the smallest ID is unavailable. Return value is unspecified if the graph is empty. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a85c52fe4b5f483504ed142d0ad94a969">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a9d199f8d5b559eab155b9e6e2ba71736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d199f8d5b559eab155b9e6e2ba71736">&#9670;&nbsp;</a></span>optimize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::optimize </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_id_reassignment</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Organize the graph for better performance and memory use. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a195c81fa446b62d94fda8841eaa3bb85">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a id="ac76cd8596923b721bc325145b9d9c148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76cd8596923b721bc325145b9d9c148">&#9670;&nbsp;</a></span>path_back()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> bdsg::ODGI::path_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a handle to the last step, which is arbitrary in the case of a circular path. </p>
<p>Get a handle to the last step in a path The path MUST be nonempty. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a31bb33a87ad8efd68876fc5ae1deeb09">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a89e279a09b8a97ccf0b6173dbf403476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89e279a09b8a97ccf0b6173dbf403476">&#9670;&nbsp;</a></span>path_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> bdsg::ODGI::path_begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a handle to the first step in a path. The path MUST be nonempty. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a815759484087ed92214c2c1c6b9d1a11">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a1b4c772ba162987a9639aa5fa8d6771a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4c772ba162987a9639aa5fa8d6771a">&#9670;&nbsp;</a></span>path_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> bdsg::ODGI::path_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a handle to a fictitious handle one past the end of the path. </p>
<p>Get the forward end iterator. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a5c3a5e04838d9e4a0a0ddf574c4de827">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a635e865722fa46278308b4a54a7f6c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635e865722fa46278308b4a54a7f6c13">&#9670;&nbsp;</a></span>path_front_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> bdsg::ODGI::path_front_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a handle to a fictitious handle one past the start of the path. </p>
<p>Get the reverse end iterator. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#ad7412bf19084f2b38ffec42517a6a9e9">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="af23d11fddc9cb68d5b80b4b557954bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23d11fddc9cb68d5b80b4b557954bbe">&#9670;&nbsp;</a></span>path_to_rank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t bdsg::ODGI::path_to_rank </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the 0-based rank encoded by a path handle. </p>

</div>
</div>
<a id="a74b5764a3b881b921ce745fd8e53d1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b5764a3b881b921ce745fd8e53d1ab">&#9670;&nbsp;</a></span>prepend_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> bdsg::ODGI::prepend_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to_append</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Append a visit to a node to the given path. Returns a handle to the new final step on the path which is appended. Handles to prior steps on the path, and to other paths, must remain valid. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#aed17038a0104017d37ff74e15f7f436a">handlegraph::MutablePathHandleGraph</a>.</p>

</div>
</div>
<a id="a2629006a078b90f4e6306d6bc8c133be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2629006a078b90f4e6306d6bc8c133be">&#9670;&nbsp;</a></span>rank_to_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> bdsg::ODGI::rank_to_id </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>rank</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the node id for the node with the given backing rank </p>

</div>
</div>
<a id="a8541c8178fd0a21db8579db55b53ca39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8541c8178fd0a21db8579db55b53ca39">&#9670;&nbsp;</a></span>rank_to_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> bdsg::ODGI::rank_to_path </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rank</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the path handle encoding the given 0-based rank. </p>
<p>Get the path handle encodign the given 0-based rank. </p>

</div>
</div>
<a id="aeb9d9a5e4259e365194e650f4d8de89a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9d9a5e4259e365194e650f4d8de89a">&#9670;&nbsp;</a></span>reassign_node_ids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::reassign_node_ids </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; <a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a>(const <a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>get_new_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reassign all node IDs as specified by the old-&gt;new mapping function. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a4805d276a83a1dad2462e6b8dd2443dc">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a id="ad1a08999aeec3f00b077be5157e497b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a08999aeec3f00b077be5157e497b4">&#9670;&nbsp;</a></span>rewrite_segment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; bdsg::ODGI::rewrite_segment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>segment_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>segment_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_segment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the path range with the new segment. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#af28f1372aa6dad2654a22eb8463e2a07">handlegraph::MutablePathHandleGraph</a>.</p>

</div>
</div>
<a id="a316d91c973ef3b034a7d40118ff350b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316d91c973ef3b034a7d40118ff350b6">&#9670;&nbsp;</a></span>serialize_and_measure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long int bdsg::ODGI::serialize_and_measure </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serialize. Return the number of bytes written. We use a long long int here to keep varying types like uint64_t away from the Python bindings. </p>

</div>
</div>
<a id="adb5e739dd1620c10e832108bb95eeeb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb5e739dd1620c10e832108bb95eeeb3">&#9670;&nbsp;</a></span>serialize_members()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::serialize_members </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialization that implements the inherited "serialze" method. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1Serializable.html#a79235728e5f1e8fb1c0e19e275a33fff">handlegraph::Serializable</a>.</p>

</div>
</div>
<a id="a916a526721ae5d609b354957172f971b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916a526721ae5d609b354957172f971b">&#9670;&nbsp;</a></span>set_circularity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::set_circularity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>circular</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set if the path is circular or not. </p>
<p>set the circular flag for the path </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a9172694447503e35d50093d55e845eb8">handlegraph::MutablePathHandleGraph</a>.</p>

</div>
</div>
<a id="ab673c6dd900657a2a31ee9ea0dbf2611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab673c6dd900657a2a31ee9ea0dbf2611">&#9670;&nbsp;</a></span>set_handle_of_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::set_handle_of_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the given step handle to point to the given handle. </p>

</div>
</div>
<a id="a3304c7fd92ccdc8b7492df7a18c97d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3304c7fd92ccdc8b7492df7a18c97d89">&#9670;&nbsp;</a></span>set_handle_sequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::set_handle_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compact away the deleted nodes info. </p>
<p>Set the handle sequence </p>

</div>
</div>
<a id="a3daecc421eea0f87fac165694a07f689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3daecc421eea0f87fac165694a07f689">&#9670;&nbsp;</a></span>set_id_increment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::set_id_increment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> &amp;&#160;</td>
          <td class="paramname"><em>min_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the id increment, used when the graph starts at a high id to reduce loading costs </p>
<p>Set a minimum id to increment the id space by, used as a hint during construction. May have no effect on a backing implementation. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#ab844ab426cd9f289414aca4d8b892ca9">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a id="ab249018b1f7ccbb325f7de2575b2f269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab249018b1f7ccbb325f7de2575b2f269">&#9670;&nbsp;</a></span>set_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> bdsg::ODGI::set_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the step to the given handle, possibly re-linking and cleaning up if needed. </p>
<p>reassign the given step to the new handle </p>

</div>
</div>
<a id="a2dff34b34dd834544745600fc5e329fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dff34b34dd834544745600fc5e329fe">&#9670;&nbsp;</a></span>steps_of_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; bdsg::ODGI::steps_of_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>match_orientation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a vector of all steps of a node on paths. Optionally restricts to steps that match the handle in orientation. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a015b050f33861cbc8e2a0efaaf771a30">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a0b5ce7792f463b597fb91b327d735d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b5ce7792f463b597fb91b327d735d80">&#9670;&nbsp;</a></span>swap_handles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::swap_handles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap the nodes corresponding to the given handles, in the ordering used by for_each_handle when looping over the graph. Other handles to the nodes being swapped must not be invalidated. If a swap is made while for_each_handle is running, it affects the order of the handles traversed during the current traversal (so swapping an already seen handle to a later handle's position will make the seen handle be visited again and the later handle not be visited at all). </p>

</div>
</div>
<a id="a803a41f3012e735d81272826acdac236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803a41f3012e735d81272826acdac236">&#9670;&nbsp;</a></span>to_gfa() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::to_gfa </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to GFA (for debugging) </p>

</div>
</div>
<a id="a683d1879ff05c9e27f1586cb8f61376f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683d1879ff05c9e27f1586cb8f61376f">&#9670;&nbsp;</a></span>to_gfa() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::ODGI::to_gfa </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to GFA and send to the given filename, or "-" for standard output (the default). </p>

</div>
</div>
<a id="ab7efc962237f615ababad29f06d98c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7efc962237f615ababad29f06d98c9b">&#9670;&nbsp;</a></span>to_gfa() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string bdsg::ODGI::to_gfa </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to GFA and return as a string. </p>

</div>
</div>
<a id="aa1d6a4235afe99439e8a323cc142ffc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d6a4235afe99439e8a323cc142ffc2">&#9670;&nbsp;</a></span>traverse_edge_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> bdsg::ODGI::traverse_edge_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>View the given edge handle from either inward end handle and produce the outward handle you would arrive at. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a27ba4eff77a484fb635e6275b3294d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ba4eff77a484fb635e6275b3294d39">&#9670;&nbsp;</a></span>_deleted_node_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::ODGI::_deleted_node_count = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a55ac331a90b588e7f795572c4b0963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a55ac331a90b588e7f795572c4b0963">&#9670;&nbsp;</a></span>_edge_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::ODGI::_edge_count = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper to record the number of live edges. </p>

</div>
</div>
<a id="a042ef9861a75537a35e26d2dd31516c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a042ef9861a75537a35e26d2dd31516c6">&#9670;&nbsp;</a></span>_id_increment</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> bdsg::ODGI::_id_increment = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ID of the lowest-rank (rank 0) node. Must be at least 1, or else the rank 0 node can't exist. </p>

</div>
</div>
<a id="a1c79025549d3e373a09fe471d09c8808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c79025549d3e373a09fe471d09c8808">&#9670;&nbsp;</a></span>_max_node_rank</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::ODGI::_max_node_rank = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Max rank (distance above _id_increment) of a node in the graph. 0 if the graph is empty. </p>

</div>
</div>
<a id="abbcd0546ab6e96642d38570f642a6a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbcd0546ab6e96642d38570f642a6a2a">&#9670;&nbsp;</a></span>_min_node_rank</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::ODGI::_min_node_rank = std::numeric_limits&lt;decltype(_min_node_rank)&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Min rank (distance above _id_increment) of a node in the graph. Maximum possible value if the graph is empty, for easy min(). </p>

</div>
</div>
<a id="a22bc41b3879acd02979c22f841791e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22bc41b3879acd02979c22f841791e6e">&#9670;&nbsp;</a></span>_node_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::ODGI::_node_count = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper to record the number of live nodes. </p>

</div>
</div>
<a id="ac40a397647ed92d84ea2bb418bad40bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40a397647ed92d84ea2bb418bad40bb">&#9670;&nbsp;</a></span>_path_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::ODGI::_path_count = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper to record the number of live paths. </p>

</div>
</div>
<a id="a9d66ceb7a06f6dd27922015b755b1b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d66ceb7a06f6dd27922015b755b1b8e">&#9670;&nbsp;</a></span>_path_rank_next</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::ODGI::_path_rank_next = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper to record the next path rank to use (path deletions are hard because of our path FM-index) </p>

</div>
</div>
<a id="aaef8013c0bbc64e9e4ba1ba9faf74985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef8013c0bbc64e9e4ba1ba9faf74985">&#9670;&nbsp;</a></span>deleted_node_bv</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">suc_bv bdsg::ODGI::deleted_node_bv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark deleted nodes here for translating graph ids into internal ranks. </p>

</div>
</div>
<a id="aec8bceab131b7a51df75c8b2354dc215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8bceab131b7a51df75c8b2354dc215">&#9670;&nbsp;</a></span>graph_id_hidden_set</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hash_set&lt;<a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a>&gt; bdsg::ODGI::graph_id_hidden_set</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Records nodes that are hidden, but used to compactly store path sequence that has been removed from the node space. Hidden nodes are not counted towards the node count of the graph, and has_node will return false for their IDs (although new nodes cannot be created with the same IDs). Hidden nodes are destroyed as soon as the last path leaves them, so they may be invalidated by (or in the middle of!) path operations like rewrite_segment. </p>

</div>
</div>
<a id="a845e5fd6eee78d6105091f8cbb37a06d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845e5fd6eee78d6105091f8cbb37a06d">&#9670;&nbsp;</a></span>node_v</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;node_t&gt; bdsg::ODGI::node_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These are the backing data structures that we use to fulfill the above functions. </p>
<p>Records the handle to node_id mapping Use the special value "0" to indicate deleted nodes so that handle references in the id_map and elsewhere are not immediately destroyed </p>

</div>
</div>
<a id="a82c86ac9e3606a17826e01c73719ee0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c86ac9e3606a17826e01c73719ee0d">&#9670;&nbsp;</a></span>path_metadata_v</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structbdsg_1_1ODGI_1_1path__metadata__t.html">path_metadata_t</a>&gt; bdsg::ODGI::path_metadata_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>maps between path identifier and the start, end, and length of the path </p>

</div>
</div>
<a id="a427c27fc015bebd3177ffafc8517c728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a427c27fc015bebd3177ffafc8517c728">&#9670;&nbsp;</a></span>path_name_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string_hash_map&lt;std::string, <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&gt; bdsg::ODGI::path_name_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Links path names to handles. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>deps/libbdsg/include/bdsg/<a class="el" href="odgi_8hpp.html">odgi.hpp</a></li>
<li>deps/libbdsg/src/<a class="el" href="odgi_8cpp.html">odgi.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
