<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: bdsg::PackedGraph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebdsg.html">bdsg</a></li><li class="navelem"><a class="el" href="classbdsg_1_1PackedGraph.html">PackedGraph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classbdsg_1_1PackedGraph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">bdsg::PackedGraph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;packed_graph.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for bdsg::PackedGraph:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbdsg_1_1PackedGraph.png" usemap="#bdsg::PackedGraph_map" alt=""/>
  <map id="bdsg::PackedGraph_map" name="bdsg::PackedGraph_map">
<area href="classhandlegraph_1_1MutablePathDeletableHandleGraph.html" alt="handlegraph::MutablePathDeletableHandleGraph" shape="rect" coords="371,224,658,248"/>
<area href="classhandlegraph_1_1SerializableHandleGraph.html" alt="handlegraph::SerializableHandleGraph" shape="rect" coords="668,224,955,248"/>
<area href="classhandlegraph_1_1MutablePathMutableHandleGraph.html" alt="handlegraph::MutablePathMutableHandleGraph" shape="rect" coords="148,168,435,192"/>
<area href="classhandlegraph_1_1DeletableHandleGraph.html" alt="handlegraph::DeletableHandleGraph" shape="rect" coords="594,168,881,192"/>
<area href="classhandlegraph_1_1MutablePathHandleGraph.html" alt="handlegraph::MutablePathHandleGraph" shape="rect" coords="0,112,287,136"/>
<area href="classhandlegraph_1_1MutableHandleGraph.html" alt="handlegraph::MutableHandleGraph" shape="rect" coords="297,112,584,136"/>
<area href="classhandlegraph_1_1MutableHandleGraph.html" alt="handlegraph::MutableHandleGraph" shape="rect" coords="594,112,881,136"/>
<area href="classhandlegraph_1_1PathHandleGraph.html" alt="handlegraph::PathHandleGraph" shape="rect" coords="0,56,287,80"/>
<area href="classhandlegraph_1_1HandleGraph.html" alt="handlegraph::HandleGraph" shape="rect" coords="297,56,584,80"/>
<area href="classhandlegraph_1_1HandleGraph.html" alt="handlegraph::HandleGraph" shape="rect" coords="594,56,881,80"/>
<area href="classhandlegraph_1_1HandleGraph.html" alt="handlegraph::HandleGraph" shape="rect" coords="0,0,287,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdsg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a87b6cb6c626e2d5ee5e6de3d8df08131"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a87b6cb6c626e2d5ee5e6de3d8df08131">PackedGraph</a> ()</td></tr>
<tr class="separator:a87b6cb6c626e2d5ee5e6de3d8df08131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3362b6c150ac98cbf7445755e8fedd29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a3362b6c150ac98cbf7445755e8fedd29">~PackedGraph</a> ()</td></tr>
<tr class="separator:a3362b6c150ac98cbf7445755e8fedd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca0ee6c2a333464bc6cdb1b18c2b9d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#afca0ee6c2a333464bc6cdb1b18c2b9d8">PackedGraph</a> (istream &amp;in)</td></tr>
<tr class="memdesc:afca0ee6c2a333464bc6cdb1b18c2b9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a stream.  <a href="#afca0ee6c2a333464bc6cdb1b18c2b9d8">More...</a><br /></td></tr>
<tr class="separator:afca0ee6c2a333464bc6cdb1b18c2b9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7294b78c97f997722b16b63e44f3097b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a7294b78c97f997722b16b63e44f3097b">has_node</a> (<a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> node_id) const</td></tr>
<tr class="memdesc:a7294b78c97f997722b16b63e44f3097b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to check if a node exists by ID.  <a href="#a7294b78c97f997722b16b63e44f3097b">More...</a><br /></td></tr>
<tr class="separator:a7294b78c97f997722b16b63e44f3097b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca60a15f8e345f4e1d768242d4ea467"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#adca60a15f8e345f4e1d768242d4ea467">get_handle</a> (const <a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> &amp;node_id, bool is_reverse=false) const</td></tr>
<tr class="memdesc:adca60a15f8e345f4e1d768242d4ea467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the handle for the node with the given ID in the given orientation.  <a href="#adca60a15f8e345f4e1d768242d4ea467">More...</a><br /></td></tr>
<tr class="separator:adca60a15f8e345f4e1d768242d4ea467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512c710d04d1c149509e42ad8ca398a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a512c710d04d1c149509e42ad8ca398a6">get_id</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a512c710d04d1c149509e42ad8ca398a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID from a handle.  <a href="#a512c710d04d1c149509e42ad8ca398a6">More...</a><br /></td></tr>
<tr class="separator:a512c710d04d1c149509e42ad8ca398a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe45fa6049feccdb2483480c933c18c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a0fe45fa6049feccdb2483480c933c18c">get_is_reverse</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a0fe45fa6049feccdb2483480c933c18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the orientation of a handle.  <a href="#a0fe45fa6049feccdb2483480c933c18c">More...</a><br /></td></tr>
<tr class="separator:a0fe45fa6049feccdb2483480c933c18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d6ff30cfee43a4775f193cb4be7b65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a70d6ff30cfee43a4775f193cb4be7b65">flip</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a70d6ff30cfee43a4775f193cb4be7b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the orientation of a handle (potentially without getting its ID)  <a href="#a70d6ff30cfee43a4775f193cb4be7b65">More...</a><br /></td></tr>
<tr class="separator:a70d6ff30cfee43a4775f193cb4be7b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e362150d842d5d41dc45862b22d3678"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a9e362150d842d5d41dc45862b22d3678">get_length</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a9e362150d842d5d41dc45862b22d3678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of a node.  <a href="#a9e362150d842d5d41dc45862b22d3678">More...</a><br /></td></tr>
<tr class="separator:a9e362150d842d5d41dc45862b22d3678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1442d05ca10695703721089632313e7"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#ae1442d05ca10695703721089632313e7">get_sequence</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:ae1442d05ca10695703721089632313e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sequence of a node, presented in the handle's local forward orientation.  <a href="#ae1442d05ca10695703721089632313e7">More...</a><br /></td></tr>
<tr class="separator:ae1442d05ca10695703721089632313e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ffc74c329a625ee889a26d0ec805ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#ad4ffc74c329a625ee889a26d0ec805ca">follow_edges_impl</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;iteratee) const</td></tr>
<tr class="separator:ad4ffc74c329a625ee889a26d0ec805ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069cacf9a8547b92ceffe0eb308570a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a069cacf9a8547b92ceffe0eb308570a7">for_each_handle_impl</a> (const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;iteratee, bool parallel=false) const</td></tr>
<tr class="separator:a069cacf9a8547b92ceffe0eb308570a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a29e8af8100512e741664c1b02f723"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a47a29e8af8100512e741664c1b02f723">get_edge_count</a> () const</td></tr>
<tr class="separator:a47a29e8af8100512e741664c1b02f723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f8b11cd024d595f443d667bb51686c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#ac3f8b11cd024d595f443d667bb51686c">get_total_length</a> () const</td></tr>
<tr class="separator:ac3f8b11cd024d595f443d667bb51686c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0689098db10d3a299d0da887b3ac3e4"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#ae0689098db10d3a299d0da887b3ac3e4">get_base</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, size_t index) const</td></tr>
<tr class="separator:ae0689098db10d3a299d0da887b3ac3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdea91d8bd3743cbd15fca819bf3cdea"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#acdea91d8bd3743cbd15fca819bf3cdea">get_subsequence</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, size_t index, size_t size) const</td></tr>
<tr class="separator:acdea91d8bd3743cbd15fca819bf3cdea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d810c3086dd53670ca6ece7808869f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a08d810c3086dd53670ca6ece7808869f">get_node_count</a> (void) const</td></tr>
<tr class="memdesc:a08d810c3086dd53670ca6ece7808869f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of nodes in the graph.  <a href="#a08d810c3086dd53670ca6ece7808869f">More...</a><br /></td></tr>
<tr class="separator:a08d810c3086dd53670ca6ece7808869f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4666ae932f6847857c9cb625829bb0db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a4666ae932f6847857c9cb625829bb0db">min_node_id</a> (void) const</td></tr>
<tr class="separator:a4666ae932f6847857c9cb625829bb0db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e3e50eb06c106445f975a9f9f64bdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a66e3e50eb06c106445f975a9f9f64bdb">max_node_id</a> (void) const</td></tr>
<tr class="separator:a66e3e50eb06c106445f975a9f9f64bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28bde85caccd04a4bd4a9531d9177033"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a28bde85caccd04a4bd4a9531d9177033">create_handle</a> (const std::string &amp;sequence)</td></tr>
<tr class="separator:a28bde85caccd04a4bd4a9531d9177033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf661f0200611fd54c465435d3002248"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#acf661f0200611fd54c465435d3002248">create_handle</a> (const std::string &amp;sequence, const <a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> &amp;id)</td></tr>
<tr class="separator:acf661f0200611fd54c465435d3002248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af299fbb72bf0e424756d673990f51d59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#af299fbb72bf0e424756d673990f51d59">destroy_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle)</td></tr>
<tr class="separator:af299fbb72bf0e424756d673990f51d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457e1feb2fcdfce59119616183ca956b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a457e1feb2fcdfce59119616183ca956b">create_edge</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right)</td></tr>
<tr class="separator:a457e1feb2fcdfce59119616183ca956b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa707e831fb29c6427d0f38adf756961e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#aa707e831fb29c6427d0f38adf756961e">destroy_edge</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right)</td></tr>
<tr class="separator:aa707e831fb29c6427d0f38adf756961e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ffbb9d5d8ff42cb196498ab39269dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a49ffbb9d5d8ff42cb196498ab39269dd">clear</a> (void)</td></tr>
<tr class="memdesc:a49ffbb9d5d8ff42cb196498ab39269dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all nodes and edges. Does not update any stored paths.  <a href="#a49ffbb9d5d8ff42cb196498ab39269dd">More...</a><br /></td></tr>
<tr class="separator:a49ffbb9d5d8ff42cb196498ab39269dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2029190f1e0d12d4bc66b1acd169335d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a2029190f1e0d12d4bc66b1acd169335d">apply_orientation</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle)</td></tr>
<tr class="separator:a2029190f1e0d12d4bc66b1acd169335d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf885bc104efc729931c960d708cb24"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#afcf885bc104efc729931c960d708cb24">divide_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const std::vector&lt; size_t &gt; &amp;offsets)</td></tr>
<tr class="separator:afcf885bc104efc729931c960d708cb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb1c32597c3d92b956333fe5d1b7eb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a3cb1c32597c3d92b956333fe5d1b7eb3">optimize</a> (bool allow_id_reassignment=true)</td></tr>
<tr class="separator:a3cb1c32597c3d92b956333fe5d1b7eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8596b1af5d2f7c2650fcf94c4fecf367"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a8596b1af5d2f7c2650fcf94c4fecf367">apply_ordering</a> (const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;order, bool <a class="el" href="classbdsg_1_1PackedGraph.html#a7d3af382e4be809951d40564237ca4c8">compact_ids</a>=false)</td></tr>
<tr class="separator:a8596b1af5d2f7c2650fcf94c4fecf367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7fb8307d18f2dc78756d8430a705a93"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#ac7fb8307d18f2dc78756d8430a705a93">get_path_count</a> () const</td></tr>
<tr class="memdesc:ac7fb8307d18f2dc78756d8430a705a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of paths stored in the graph.  <a href="#ac7fb8307d18f2dc78756d8430a705a93">More...</a><br /></td></tr>
<tr class="separator:ac7fb8307d18f2dc78756d8430a705a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f833ac365097e97efe196eaf46e37a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a6f833ac365097e97efe196eaf46e37a7">has_path</a> (const std::string &amp;path_name) const</td></tr>
<tr class="memdesc:a6f833ac365097e97efe196eaf46e37a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a path name exists and is legal to get a path handle for.  <a href="#a6f833ac365097e97efe196eaf46e37a7">More...</a><br /></td></tr>
<tr class="separator:a6f833ac365097e97efe196eaf46e37a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ceae162ab93a6cece2d222cb32aee60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a3ceae162ab93a6cece2d222cb32aee60">get_path_handle</a> (const std::string &amp;path_name) const</td></tr>
<tr class="separator:a3ceae162ab93a6cece2d222cb32aee60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41bd8484de5fedfd126eb6be86f277e7"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a41bd8484de5fedfd126eb6be86f277e7">get_path_name</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="memdesc:a41bd8484de5fedfd126eb6be86f277e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the name of a path from a handle to it.  <a href="#a41bd8484de5fedfd126eb6be86f277e7">More...</a><br /></td></tr>
<tr class="separator:a41bd8484de5fedfd126eb6be86f277e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae614ce491ea677b086ef323cef123013"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#ae614ce491ea677b086ef323cef123013">get_is_circular</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="memdesc:ae614ce491ea677b086ef323cef123013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up whether a path is circular.  <a href="#ae614ce491ea677b086ef323cef123013">More...</a><br /></td></tr>
<tr class="separator:ae614ce491ea677b086ef323cef123013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ec5ffe54100d8ce84aa41ea666f694"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a51ec5ffe54100d8ce84aa41ea666f694">get_step_count</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="memdesc:a51ec5ffe54100d8ce84aa41ea666f694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of node steps in the path.  <a href="#a51ec5ffe54100d8ce84aa41ea666f694">More...</a><br /></td></tr>
<tr class="separator:a51ec5ffe54100d8ce84aa41ea666f694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468a71289a32bc7d2389457896c581f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a468a71289a32bc7d2389457896c581f8">get_handle_of_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="memdesc:a468a71289a32bc7d2389457896c581f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a node handle (node ID and orientation) from a handle to an step on a path.  <a href="#a468a71289a32bc7d2389457896c581f8">More...</a><br /></td></tr>
<tr class="separator:a468a71289a32bc7d2389457896c581f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c61530afad057172fcff0a65fc9547"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a74c61530afad057172fcff0a65fc9547">path_begin</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="separator:a74c61530afad057172fcff0a65fc9547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4dc11493d3c114370f0cf2c82fefd81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#ae4dc11493d3c114370f0cf2c82fefd81">path_end</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="separator:ae4dc11493d3c114370f0cf2c82fefd81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd30df6ea1bce48e05bf6254655ccf25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#acd30df6ea1bce48e05bf6254655ccf25">path_back</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="separator:acd30df6ea1bce48e05bf6254655ccf25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bb4bbfad090dc16fe0bfd4d6717bed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#af4bb4bbfad090dc16fe0bfd4d6717bed">path_front_end</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="separator:af4bb4bbfad090dc16fe0bfd4d6717bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8141214b86c13f99d5105fd0479b25af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a8141214b86c13f99d5105fd0479b25af">has_next_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="memdesc:a8141214b86c13f99d5105fd0479b25af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the step is not the last step in a non-circular path.  <a href="#a8141214b86c13f99d5105fd0479b25af">More...</a><br /></td></tr>
<tr class="separator:a8141214b86c13f99d5105fd0479b25af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e6944d161770bafd7aeaa8508ef93a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#ab5e6944d161770bafd7aeaa8508ef93a">has_previous_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="memdesc:ab5e6944d161770bafd7aeaa8508ef93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the step is not the first step in a non-circular path.  <a href="#ab5e6944d161770bafd7aeaa8508ef93a">More...</a><br /></td></tr>
<tr class="separator:ab5e6944d161770bafd7aeaa8508ef93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b91251e9cb6cbfd8388d4268217c45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#ad4b91251e9cb6cbfd8388d4268217c45">get_next_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="separator:ad4b91251e9cb6cbfd8388d4268217c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43eef1990fdfd67c34f44894a89bfeda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a43eef1990fdfd67c34f44894a89bfeda">get_previous_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="separator:a43eef1990fdfd67c34f44894a89bfeda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc6e38517f00e4e61bd9e3a5af1a962"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#acbc6e38517f00e4e61bd9e3a5af1a962">get_path_handle_of_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="memdesc:acbc6e38517f00e4e61bd9e3a5af1a962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handle to the path that an step is on.  <a href="#acbc6e38517f00e4e61bd9e3a5af1a962">More...</a><br /></td></tr>
<tr class="separator:acbc6e38517f00e4e61bd9e3a5af1a962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a62949f7ae3e0e4ea23bde66febc1e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a6a62949f7ae3e0e4ea23bde66febc1e1">for_each_path_handle_impl</a> (const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; &amp;iteratee) const</td></tr>
<tr class="memdesc:a6a62949f7ae3e0e4ea23bde66febc1e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a function on each path in the graph.  <a href="#a6a62949f7ae3e0e4ea23bde66febc1e1">More...</a><br /></td></tr>
<tr class="separator:a6a62949f7ae3e0e4ea23bde66febc1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d430c401baf707511c35e9f21e391b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a9d430c401baf707511c35e9f21e391b0">for_each_step_on_handle_impl</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const function&lt; bool(const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;)&gt; &amp;iteratee) const</td></tr>
<tr class="memdesc:a9d430c401baf707511c35e9f21e391b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the given function for each step of the given handle on a path.  <a href="#a9d430c401baf707511c35e9f21e391b0">More...</a><br /></td></tr>
<tr class="separator:a9d430c401baf707511c35e9f21e391b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4984d8fbd73d4661173cd8ae773a87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#ade4984d8fbd73d4661173cd8ae773a87">destroy_path</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path)</td></tr>
<tr class="separator:ade4984d8fbd73d4661173cd8ae773a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a55f1b56d716f79935ff25a554ebfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#ad2a55f1b56d716f79935ff25a554ebfc">create_path_handle</a> (const string &amp;name, bool is_circular=false)</td></tr>
<tr class="separator:ad2a55f1b56d716f79935ff25a554ebfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5c580f60fa9630f8813d78575f7161"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a5e5c580f60fa9630f8813d78575f7161">append_step</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;to_append)</td></tr>
<tr class="separator:a5e5c580f60fa9630f8813d78575f7161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0a7f1579a8c18cf1de1a5690cd1ed4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a5c0a7f1579a8c18cf1de1a5690cd1ed4">prepend_step</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;to_prepend)</td></tr>
<tr class="separator:a5c0a7f1579a8c18cf1de1a5690cd1ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2297321ff0f8a0f8dafcfc79e85a899"><td class="memItemLeft" align="right" valign="top">pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#af2297321ff0f8a0f8dafcfc79e85a899">rewrite_segment</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;segment_begin, const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;segment_end, const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;new_segment)</td></tr>
<tr class="separator:af2297321ff0f8a0f8dafcfc79e85a899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa756f1d4671ea6a22382f1753c1bd17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#aaa756f1d4671ea6a22382f1753c1bd17">set_circularity</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, bool circular)</td></tr>
<tr class="separator:aaa756f1d4671ea6a22382f1753c1bd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265258f9e9ea78a96e86f594e11224ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a265258f9e9ea78a96e86f594e11224ad">set_id_increment</a> (const <a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> &amp;<a class="el" href="classbdsg_1_1PackedGraph.html#af642ed4edfaf4f16c99a822d54a6da28">min_id</a>)</td></tr>
<tr class="separator:a265258f9e9ea78a96e86f594e11224ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3c1c0c184ce781b1f792149331cbfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#aab3c1c0c184ce781b1f792149331cbfb">increment_node_ids</a> (<a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> increment)</td></tr>
<tr class="separator:aab3c1c0c184ce781b1f792149331cbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f213978cb671f8e9586901321b79e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#af7f213978cb671f8e9586901321b79e2">reassign_node_ids</a> (const std::function&lt; <a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a>(const <a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> &amp;)&gt; &amp;get_new_id)</td></tr>
<tr class="separator:af7f213978cb671f8e9586901321b79e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21ccd2b60369a6375d33d0f51073a89"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#aa21ccd2b60369a6375d33d0f51073a89">get_magic_number</a> () const</td></tr>
<tr class="memdesc:aa21ccd2b60369a6375d33d0f51073a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a static high-entropy number to indicate the class.  <a href="#aa21ccd2b60369a6375d33d0f51073a89">More...</a><br /></td></tr>
<tr class="separator:aa21ccd2b60369a6375d33d0f51073a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78de6cdf98b68b77a0d44eb843571d8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a78de6cdf98b68b77a0d44eb843571d8c">report_memory</a> (ostream &amp;out, bool individual_paths=false) const</td></tr>
<tr class="separator:a78de6cdf98b68b77a0d44eb843571d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1MutablePathDeletableHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1MutablePathDeletableHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1MutablePathDeletableHandleGraph.html">handlegraph::MutablePathDeletableHandleGraph</a></td></tr>
<tr class="memitem:a2d936ce540af42363619ebb77c60a4ff inherit pub_methods_classhandlegraph_1_1MutablePathDeletableHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutablePathDeletableHandleGraph.html#a2d936ce540af42363619ebb77c60a4ff">~MutablePathDeletableHandleGraph</a> ()=default</td></tr>
<tr class="separator:a2d936ce540af42363619ebb77c60a4ff inherit pub_methods_classhandlegraph_1_1MutablePathDeletableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1MutablePathMutableHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1MutablePathMutableHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">handlegraph::MutablePathMutableHandleGraph</a></td></tr>
<tr class="memitem:a55379ced0e4f2952ca3353c558affc44 inherit pub_methods_classhandlegraph_1_1MutablePathMutableHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html#a55379ced0e4f2952ca3353c558affc44">~MutablePathMutableHandleGraph</a> ()=default</td></tr>
<tr class="separator:a55379ced0e4f2952ca3353c558affc44 inherit pub_methods_classhandlegraph_1_1MutablePathMutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1MutablePathHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html">handlegraph::MutablePathHandleGraph</a></td></tr>
<tr class="memitem:a3b9b032ce45f87e1abd5c175db6f5275 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a3b9b032ce45f87e1abd5c175db6f5275">~MutablePathHandleGraph</a> ()=default</td></tr>
<tr class="separator:a3b9b032ce45f87e1abd5c175db6f5275 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0873a6eb776bb2557a5b8453dbf13824 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a0873a6eb776bb2557a5b8453dbf13824">create_path_handle</a> (const std::string &amp;name, bool is_circular=false)=0</td></tr>
<tr class="separator:a0873a6eb776bb2557a5b8453dbf13824 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28f1372aa6dad2654a22eb8463e2a07 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#af28f1372aa6dad2654a22eb8463e2a07">rewrite_segment</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;segment_begin, const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;segment_end, const std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;new_segment)=0</td></tr>
<tr class="separator:af28f1372aa6dad2654a22eb8463e2a07 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1PathHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1PathHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">handlegraph::PathHandleGraph</a></td></tr>
<tr class="memitem:a49fe5658c5ef27e1d7aba69cd3d7159b inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a49fe5658c5ef27e1d7aba69cd3d7159b">~PathHandleGraph</a> ()=default</td></tr>
<tr class="separator:a49fe5658c5ef27e1d7aba69cd3d7159b inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3a31f0c19054cd2908525119869b80 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a6d3a31f0c19054cd2908525119869b80">get_step_count</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a6d3a31f0c19054cd2908525119869b80 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of node steps on a handle.  <a href="classhandlegraph_1_1PathHandleGraph.html#a6d3a31f0c19054cd2908525119869b80">More...</a><br /></td></tr>
<tr class="separator:a6d3a31f0c19054cd2908525119869b80 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f1d0595543d760322042770201297c inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:aa3f1d0595543d760322042770201297c inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#aa3f1d0595543d760322042770201297c">for_each_path_handle</a> (const Iteratee &amp;iteratee) const</td></tr>
<tr class="separator:aa3f1d0595543d760322042770201297c inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006a8e3ab9e2783ef7bf80b98b35959c inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a006a8e3ab9e2783ef7bf80b98b35959c inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a006a8e3ab9e2783ef7bf80b98b35959c">for_each_step_on_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const Iteratee &amp;iteratee) const</td></tr>
<tr class="separator:a006a8e3ab9e2783ef7bf80b98b35959c inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015b050f33861cbc8e2a0efaaf771a30 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a015b050f33861cbc8e2a0efaaf771a30">steps_of_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool match_orientation=false) const</td></tr>
<tr class="separator:a015b050f33861cbc8e2a0efaaf771a30 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3f2c04d1e315e485460dcd902467cb inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#aef3f2c04d1e315e485460dcd902467cb">is_empty</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="memdesc:aef3f2c04d1e315e485460dcd902467cb inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given path is empty, and false otherwise.  <a href="classhandlegraph_1_1PathHandleGraph.html#aef3f2c04d1e315e485460dcd902467cb">More...</a><br /></td></tr>
<tr class="separator:aef3f2c04d1e315e485460dcd902467cb inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa071f31a10a02d8231b029d0a7ddef0b inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhandlegraph_1_1PathForEachSocket.html">PathForEachSocket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#aa071f31a10a02d8231b029d0a7ddef0b">scan_path</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path) const</td></tr>
<tr class="separator:aa071f31a10a02d8231b029d0a7ddef0b inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184353db571dd2086d79e4e31f2f97f1 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a184353db571dd2086d79e4e31f2f97f1 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a184353db571dd2086d79e4e31f2f97f1">for_each_step_in_path</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, const Iteratee &amp;iteratee) const</td></tr>
<tr class="separator:a184353db571dd2086d79e4e31f2f97f1 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1HandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1HandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1HandleGraph.html">handlegraph::HandleGraph</a></td></tr>
<tr class="memitem:a24fb796441c9ad8c870fdb716a82b305 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a24fb796441c9ad8c870fdb716a82b305">~HandleGraph</a> ()=default</td></tr>
<tr class="separator:a24fb796441c9ad8c870fdb716a82b305 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d21f30e62ad0b0c5919b2fe95e6f8aa inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a4d21f30e62ad0b0c5919b2fe95e6f8aa inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a4d21f30e62ad0b0c5919b2fe95e6f8aa">follow_edges</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left, const Iteratee &amp;iteratee) const</td></tr>
<tr class="separator:a4d21f30e62ad0b0c5919b2fe95e6f8aa inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928bdeabd328d357b538e30590164ab4 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a928bdeabd328d357b538e30590164ab4 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a928bdeabd328d357b538e30590164ab4">for_each_handle</a> (const Iteratee &amp;iteratee, bool parallel=false) const</td></tr>
<tr class="separator:a928bdeabd328d357b538e30590164ab4 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab259e3aba0da47b0ef1c9b5e43c7d209 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#ab259e3aba0da47b0ef1c9b5e43c7d209">get_degree</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left) const</td></tr>
<tr class="separator:ab259e3aba0da47b0ef1c9b5e43c7d209 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069448fbe58665b9ff531ad0b8c5af57 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a069448fbe58665b9ff531ad0b8c5af57">has_edge</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right) const</td></tr>
<tr class="separator:a069448fbe58665b9ff531ad0b8c5af57 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6171cdd6036c73623c96656f8b44fe9d inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a6171cdd6036c73623c96656f8b44fe9d">has_edge</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge) const</td></tr>
<tr class="memdesc:a6171cdd6036c73623c96656f8b44fe9d inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient wrapper of has_edge for edge_t argument.  <a href="classhandlegraph_1_1HandleGraph.html#a6171cdd6036c73623c96656f8b44fe9d">More...</a><br /></td></tr>
<tr class="separator:a6171cdd6036c73623c96656f8b44fe9d inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e946bb4ed53f9423072955cdaab6386 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a9e946bb4ed53f9423072955cdaab6386">forward</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a9e946bb4ed53f9423072955cdaab6386 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the locally forward version of a handle.  <a href="classhandlegraph_1_1HandleGraph.html#a9e946bb4ed53f9423072955cdaab6386">More...</a><br /></td></tr>
<tr class="separator:a9e946bb4ed53f9423072955cdaab6386 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3766f1aca1cbdbf827f2a12aaf2078ec inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a3766f1aca1cbdbf827f2a12aaf2078ec">edge_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right) const</td></tr>
<tr class="separator:a3766f1aca1cbdbf827f2a12aaf2078ec inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af167b0664299cfd4eac610f129fa5fee inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#af167b0664299cfd4eac610f129fa5fee">traverse_edge_handle</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left) const</td></tr>
<tr class="separator:af167b0664299cfd4eac610f129fa5fee inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61570ded026f825d62ea7608a1e92349 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a61570ded026f825d62ea7608a1e92349 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a61570ded026f825d62ea7608a1e92349">for_each_edge</a> (const Iteratee &amp;iteratee, bool parallel=false) const</td></tr>
<tr class="separator:a61570ded026f825d62ea7608a1e92349 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1MutableHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1MutableHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">handlegraph::MutableHandleGraph</a></td></tr>
<tr class="memitem:ace50b9ed07cbbe94f7da963ff02d4141 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#ace50b9ed07cbbe94f7da963ff02d4141">~MutableHandleGraph</a> ()=default</td></tr>
<tr class="separator:ace50b9ed07cbbe94f7da963ff02d4141 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff0a0f9497da3498170fdfc2ce97797 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a3ff0a0f9497da3498170fdfc2ce97797">create_edge</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge)</td></tr>
<tr class="memdesc:a3ff0a0f9497da3498170fdfc2ce97797 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient wrapper for create_edge.  <a href="classhandlegraph_1_1MutableHandleGraph.html#a3ff0a0f9497da3498170fdfc2ce97797">More...</a><br /></td></tr>
<tr class="separator:a3ff0a0f9497da3498170fdfc2ce97797 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c38787f0ff4a2695e61d98cb402175 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a05c38787f0ff4a2695e61d98cb402175">divide_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, size_t offset)</td></tr>
<tr class="memdesc:a05c38787f0ff4a2695e61d98cb402175 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of divide_handle for a single division point.  <a href="classhandlegraph_1_1MutableHandleGraph.html#a05c38787f0ff4a2695e61d98cb402175">More...</a><br /></td></tr>
<tr class="separator:a05c38787f0ff4a2695e61d98cb402175 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e14ea0ae201ba87934559ecbd3a2981 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a7e14ea0ae201ba87934559ecbd3a2981">apply_ordering</a> (const std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;order, bool compact_ids=false)=0</td></tr>
<tr class="separator:a7e14ea0ae201ba87934559ecbd3a2981 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877dc8c0ae9a584907d45328512720cc inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a877dc8c0ae9a584907d45328512720cc">increment_node_ids</a> (long increment)</td></tr>
<tr class="memdesc:a877dc8c0ae9a584907d45328512720cc inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">This specialization for long appears to be needed to avoid confusion about nid_t.  <a href="classhandlegraph_1_1MutableHandleGraph.html#a877dc8c0ae9a584907d45328512720cc">More...</a><br /></td></tr>
<tr class="separator:a877dc8c0ae9a584907d45328512720cc inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1DeletableHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">handlegraph::DeletableHandleGraph</a></td></tr>
<tr class="memitem:a62ed805e124ceb05cfa98d4e631a9ebd inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#a62ed805e124ceb05cfa98d4e631a9ebd">~DeletableHandleGraph</a> ()=default</td></tr>
<tr class="separator:a62ed805e124ceb05cfa98d4e631a9ebd inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65cef3b3261f8d1bc2057c5f2ee100a inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#aa65cef3b3261f8d1bc2057c5f2ee100a">truncate_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool trunc_left, size_t offset)</td></tr>
<tr class="separator:aa65cef3b3261f8d1bc2057c5f2ee100a inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2b397c1b4ec7f9c75ccc5b9ce06564 inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#aec2b397c1b4ec7f9c75ccc5b9ce06564">destroy_edge</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge)</td></tr>
<tr class="memdesc:aec2b397c1b4ec7f9c75ccc5b9ce06564 inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient wrapper for destroy_edge.  <a href="classhandlegraph_1_1DeletableHandleGraph.html#aec2b397c1b4ec7f9c75ccc5b9ce06564">More...</a><br /></td></tr>
<tr class="separator:aec2b397c1b4ec7f9c75ccc5b9ce06564 inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1SerializableHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1SerializableHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1SerializableHandleGraph.html">handlegraph::SerializableHandleGraph</a></td></tr>
<tr class="memitem:a21940e94ff216cfd44eaf540044d8fc7 inherit pub_methods_classhandlegraph_1_1SerializableHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SerializableHandleGraph.html#a21940e94ff216cfd44eaf540044d8fc7">~SerializableHandleGraph</a> ()=default</td></tr>
<tr class="separator:a21940e94ff216cfd44eaf540044d8fc7 inherit pub_methods_classhandlegraph_1_1SerializableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed30acaddc8cc1650044fd8299643a24 inherit pub_methods_classhandlegraph_1_1SerializableHandleGraph"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SerializableHandleGraph.html#aed30acaddc8cc1650044fd8299643a24">serialize</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:aed30acaddc8cc1650044fd8299643a24 inherit pub_methods_classhandlegraph_1_1SerializableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b908eb72c828e7f75d825a34a87651 inherit pub_methods_classhandlegraph_1_1SerializableHandleGraph"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SerializableHandleGraph.html#a97b908eb72c828e7f75d825a34a87651">serialize</a> (const std::string &amp;filename) const</td></tr>
<tr class="separator:a97b908eb72c828e7f75d825a34a87651 inherit pub_methods_classhandlegraph_1_1SerializableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9736fd91bf5becf144e4e9c1a247af31 inherit pub_methods_classhandlegraph_1_1SerializableHandleGraph"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SerializableHandleGraph.html#a9736fd91bf5becf144e4e9c1a247af31">deserialize</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a9736fd91bf5becf144e4e9c1a247af31 inherit pub_methods_classhandlegraph_1_1SerializableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e247159597af5d6596f7eba9afbe284 inherit pub_methods_classhandlegraph_1_1SerializableHandleGraph"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1SerializableHandleGraph.html#a5e247159597af5d6596f7eba9afbe284">deserialize</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:a5e247159597af5d6596f7eba9afbe284 inherit pub_methods_classhandlegraph_1_1SerializableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:abebaf484e5f8ca064aa30cc3fba38d1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#abebaf484e5f8ca064aa30cc3fba38d1f">serialize_members</a> (ostream &amp;out) const</td></tr>
<tr class="memdesc:abebaf484e5f8ca064aa30cc3fba38d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the graph to an out stream (called from the inherited 'serialize' method)  <a href="#abebaf484e5f8ca064aa30cc3fba38d1f">More...</a><br /></td></tr>
<tr class="separator:abebaf484e5f8ca064aa30cc3fba38d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2f00e2a89ad95c07c23892daaf02c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a0f2f00e2a89ad95c07c23892daaf02c3">deserialize_members</a> (istream &amp;in)</td></tr>
<tr class="memdesc:a0f2f00e2a89ad95c07c23892daaf02c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the graph from an in stream (called from the inherited 'deserialize' method)  <a href="#a0f2f00e2a89ad95c07c23892daaf02c3">More...</a><br /></td></tr>
<tr class="separator:a0f2f00e2a89ad95c07c23892daaf02c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1dc6acc90fe7e14046bc22844b36991"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#af1dc6acc90fe7e14046bc22844b36991">tighten</a> (void)</td></tr>
<tr class="separator:af1dc6acc90fe7e14046bc22844b36991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3af382e4be809951d40564237ca4c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a7d3af382e4be809951d40564237ca4c8">compact_ids</a> (const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;order)</td></tr>
<tr class="separator:a7d3af382e4be809951d40564237ca4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c4113ab7366834d2dbce6ee3f4bf96"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a96c4113ab7366834d2dbce6ee3f4bf96">new_node_record</a> (<a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> node_id)</td></tr>
<tr class="separator:a96c4113ab7366834d2dbce6ee3f4bf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47754701687bd025df96798b22ad9f44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a47754701687bd025df96798b22ad9f44">remove_edge_reference</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;on, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;to)</td></tr>
<tr class="memdesc:a47754701687bd025df96798b22ad9f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and edge on given handle, to a given handle, and remove it from the edge list.  <a href="#a47754701687bd025df96798b22ad9f44">More...</a><br /></td></tr>
<tr class="separator:a47754701687bd025df96798b22ad9f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6b2e4d2f72aa541e04e21fabeaec89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a4b6b2e4d2f72aa541e04e21fabeaec89">eject_deleted_paths</a> ()</td></tr>
<tr class="memdesc:a4b6b2e4d2f72aa541e04e21fabeaec89"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we've deleted any paths, remove them from the paths vector and reassign path IDs.  <a href="#a4b6b2e4d2f72aa541e04e21fabeaec89">More...</a><br /></td></tr>
<tr class="separator:a4b6b2e4d2f72aa541e04e21fabeaec89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7edd80968f8d6d2865da20a1307179"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#afa7edd80968f8d6d2865da20a1307179">defragment</a> (bool force=false)</td></tr>
<tr class="separator:afa7edd80968f8d6d2865da20a1307179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c98ea5d42e6ab70fc04d65ac0989af8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a3c98ea5d42e6ab70fc04d65ac0989af8">defragment_path</a> (const int64_t &amp;path_idx, bool force=false)</td></tr>
<tr class="separator:a3c98ea5d42e6ab70fc04d65ac0989af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c60e2c48e1b656edf89c2b338308871"><td class="memItemLeft" align="right" valign="top">PackedVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a7c60e2c48e1b656edf89c2b338308871">encode_and_assign_path_name</a> (const string &amp;path_name)</td></tr>
<tr class="memdesc:a7c60e2c48e1b656edf89c2b338308871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a path name into an integer vector, assigning new chars as necessary.  <a href="#a7c60e2c48e1b656edf89c2b338308871">More...</a><br /></td></tr>
<tr class="separator:a7c60e2c48e1b656edf89c2b338308871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd861560dbc8f5f3e36f0554892e580"><td class="memItemLeft" align="right" valign="top">PackedVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a0bd861560dbc8f5f3e36f0554892e580">encode_path_name</a> (const string &amp;path_name) const</td></tr>
<tr class="separator:a0bd861560dbc8f5f3e36f0554892e580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79bbc84f695050d95d3a53c7812fe12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#aa79bbc84f695050d95d3a53c7812fe12">append_path_name</a> (const string &amp;path_name)</td></tr>
<tr class="separator:aa79bbc84f695050d95d3a53c7812fe12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14f098d6c3013afcd7a235ea2250a57"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#ae14f098d6c3013afcd7a235ea2250a57">decode_path_name</a> (const int64_t &amp;path_idx) const</td></tr>
<tr class="memdesc:ae14f098d6c3013afcd7a235ea2250a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the internal representation of a path name and return it as a string.  <a href="#ae14f098d6c3013afcd7a235ea2250a57">More...</a><br /></td></tr>
<tr class="separator:ae14f098d6c3013afcd7a235ea2250a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1bfe9d375da81afe833dde436d4fd4f"><td class="memItemLeft" align="right" valign="top">PackedVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#ac1bfe9d375da81afe833dde436d4fd4f">extract_encoded_path_name</a> (const int64_t &amp;path_idx) const</td></tr>
<tr class="memdesc:ac1bfe9d375da81afe833dde436d4fd4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the internal representation of a path name, but do not decode it.  <a href="#ac1bfe9d375da81afe833dde436d4fd4f">More...</a><br /></td></tr>
<tr class="separator:ac1bfe9d375da81afe833dde436d4fd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1016444a5f5ffd73c0cfbd3fb9375359"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a1016444a5f5ffd73c0cfbd3fb9375359">encode_nucleotide</a> (const char &amp;nt) const</td></tr>
<tr class="memdesc:a1016444a5f5ffd73c0cfbd3fb9375359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience functions to translate between encodings in the vectors.  <a href="#a1016444a5f5ffd73c0cfbd3fb9375359">More...</a><br /></td></tr>
<tr class="separator:a1016444a5f5ffd73c0cfbd3fb9375359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c47b9fdc2e68f6fd7bb8a7e98669ee9"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a1c47b9fdc2e68f6fd7bb8a7e98669ee9">decode_nucleotide</a> (const uint64_t &amp;val) const</td></tr>
<tr class="memdesc:a1c47b9fdc2e68f6fd7bb8a7e98669ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map [0, 4] to nucleotides.  <a href="#a1c47b9fdc2e68f6fd7bb8a7e98669ee9">More...</a><br /></td></tr>
<tr class="separator:a1c47b9fdc2e68f6fd7bb8a7e98669ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82de7c4736713100ba59e8f6f86ac516"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a82de7c4736713100ba59e8f6f86ac516">complement_encoded_nucleotide</a> (const uint64_t &amp;val) const</td></tr>
<tr class="memdesc:a82de7c4736713100ba59e8f6f86ac516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complement nucleotide encoded as [0, 4].  <a href="#a82de7c4736713100ba59e8f6f86ac516">More...</a><br /></td></tr>
<tr class="separator:a82de7c4736713100ba59e8f6f86ac516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb15feea2045b0f8e44893af1f4a1bdb"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#acb15feea2045b0f8e44893af1f4a1bdb">get_assignment</a> (const char &amp;c) const</td></tr>
<tr class="separator:acb15feea2045b0f8e44893af1f4a1bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cfc43082e5b17115f9a66fd216f37a7"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a1cfc43082e5b17115f9a66fd216f37a7">get_or_make_assignment</a> (const char &amp;c)</td></tr>
<tr class="memdesc:a1cfc43082e5b17115f9a66fd216f37a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the integer assignment of a char, assigning a new one if necessary.  <a href="#a1cfc43082e5b17115f9a66fd216f37a7">More...</a><br /></td></tr>
<tr class="separator:a1cfc43082e5b17115f9a66fd216f37a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be6ecd4ae5805a72c5a6856f7ef2ed6"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a4be6ecd4ae5805a72c5a6856f7ef2ed6">get_char</a> (const uint64_t &amp;assignment) const</td></tr>
<tr class="memdesc:a4be6ecd4ae5805a72c5a6856f7ef2ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the char assigned to an integer (must be already assigned)  <a href="#a4be6ecd4ae5805a72c5a6856f7ef2ed6">More...</a><br /></td></tr>
<tr class="separator:a4be6ecd4ae5805a72c5a6856f7ef2ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370b82704992635d03210f033f65d688"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a370b82704992635d03210f033f65d688">graph_iv_index</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="separator:a370b82704992635d03210f033f65d688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8678b4d2c1b2b4327218fbb32dd6a57b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a8678b4d2c1b2b4327218fbb32dd6a57b">graph_index_to_seq_len_index</a> (const size_t &amp;graph_index) const</td></tr>
<tr class="separator:a8678b4d2c1b2b4327218fbb32dd6a57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43758247e9cf4dde965134d300527d1c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a43758247e9cf4dde965134d300527d1c">graph_index_to_seq_start_index</a> (const size_t &amp;graph_index) const</td></tr>
<tr class="separator:a43758247e9cf4dde965134d300527d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f8e3be2f3193775661754abde2ac8e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a77f8e3be2f3193775661754abde2ac8e">graph_index_to_node_member_index</a> (const size_t &amp;graph_index) const</td></tr>
<tr class="separator:a77f8e3be2f3193775661754abde2ac8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435427441951ae3816cf6376f4ca3451"><td class="memItemLeft" align="right" valign="top">const uint64_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a435427441951ae3816cf6376f4ca3451">encode_traversal</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="separator:a435427441951ae3816cf6376f4ca3451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f5a45b2de1f7e25341e8081f31f336"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a05f5a45b2de1f7e25341e8081f31f336">decode_traversal</a> (const uint64_t &amp;val) const</td></tr>
<tr class="separator:a05f5a45b2de1f7e25341e8081f31f336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6348575901320aff5c13dfc5d4a983e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#aa6348575901320aff5c13dfc5d4a983e">get_next_edge_index</a> (const uint64_t &amp;edge_index) const</td></tr>
<tr class="separator:aa6348575901320aff5c13dfc5d4a983e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d073358f58fe721cd9585697341e440"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a1d073358f58fe721cd9585697341e440">get_edge_target</a> (const uint64_t &amp;edge_index) const</td></tr>
<tr class="separator:a1d073358f58fe721cd9585697341e440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612b299b52d1a53359f16bbdec0886ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a612b299b52d1a53359f16bbdec0886ce">set_edge_target</a> (const uint64_t &amp;edge_index, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle)</td></tr>
<tr class="separator:a612b299b52d1a53359f16bbdec0886ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b13eb9f4ad3c3fa44719fb5de07b11"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#af8b13eb9f4ad3c3fa44719fb5de07b11">get_next_membership</a> (const uint64_t &amp;membership_index) const</td></tr>
<tr class="separator:af8b13eb9f4ad3c3fa44719fb5de07b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306dc538bd192d5798d3fb6d2ab4a126"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a306dc538bd192d5798d3fb6d2ab4a126">get_membership_step</a> (const uint64_t &amp;membership_index) const</td></tr>
<tr class="separator:a306dc538bd192d5798d3fb6d2ab4a126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ac15735f507befa1c31fdcecc565c0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a21ac15735f507befa1c31fdcecc565c0">get_membership_path</a> (const uint64_t &amp;membership_index) const</td></tr>
<tr class="separator:a21ac15735f507befa1c31fdcecc565c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e10bae6fc4504b557a9b72e217c0f1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a8e10bae6fc4504b557a9b72e217c0f1b">set_next_membership</a> (const uint64_t &amp;membership_index, const uint64_t &amp;next)</td></tr>
<tr class="separator:a8e10bae6fc4504b557a9b72e217c0f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933958da682703e613cd9cbb233d79a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a933958da682703e613cd9cbb233d79a9">set_membership_step</a> (const uint64_t &amp;membership_index, const uint64_t &amp;step)</td></tr>
<tr class="separator:a933958da682703e613cd9cbb233d79a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692302b97529bc3ef3a6423d84efa6cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a692302b97529bc3ef3a6423d84efa6cc">set_membership_path</a> (const uint64_t &amp;membership_index, const uint64_t &amp;path)</td></tr>
<tr class="separator:a692302b97529bc3ef3a6423d84efa6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8c62ed8289ad8a4fb96dc208e33a44"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a6d8c62ed8289ad8a4fb96dc208e33a44">get_step_trav</a> (const <a class="el" href="structbdsg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &amp;path, const uint64_t &amp;step_index) const</td></tr>
<tr class="separator:a6d8c62ed8289ad8a4fb96dc208e33a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa43f7ff31b78890940c43c93c1c1e2"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a7fa43f7ff31b78890940c43c93c1c1e2">get_step_prev</a> (const <a class="el" href="structbdsg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &amp;path, const uint64_t &amp;step_index) const</td></tr>
<tr class="separator:a7fa43f7ff31b78890940c43c93c1c1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5e6d5fc977a25196b38b854e4720ae"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a0e5e6d5fc977a25196b38b854e4720ae">get_step_next</a> (const <a class="el" href="structbdsg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &amp;path, const uint64_t &amp;step_index) const</td></tr>
<tr class="separator:a0e5e6d5fc977a25196b38b854e4720ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d9748a1599137ceace5b11561779f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a85d9748a1599137ceace5b11561779f9">set_step_trav</a> (<a class="el" href="structbdsg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &amp;path, const uint64_t &amp;step_index, const uint64_t &amp;trav)</td></tr>
<tr class="separator:a85d9748a1599137ceace5b11561779f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4038aba29d614501d927c81d3002d38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#ab4038aba29d614501d927c81d3002d38">set_step_prev</a> (<a class="el" href="structbdsg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &amp;path, const uint64_t &amp;step_index, const uint64_t &amp;prev_index)</td></tr>
<tr class="separator:ab4038aba29d614501d927c81d3002d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc68c23fd4d161a26dc17c65216c83fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#acc68c23fd4d161a26dc17c65216c83fb">set_step_next</a> (<a class="el" href="structbdsg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &amp;path, const uint64_t &amp;step_index, const uint64_t &amp;next_index)</td></tr>
<tr class="separator:acc68c23fd4d161a26dc17c65216c83fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aca3c119c31f6ad25d9d047d06c2d8c08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#aca3c119c31f6ad25d9d047d06c2d8c08">max_id</a> = 0</td></tr>
<tr class="memdesc:aca3c119c31f6ad25d9d047d06c2d8c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum ID in the graph.  <a href="#aca3c119c31f6ad25d9d047d06c2d8c08">More...</a><br /></td></tr>
<tr class="separator:aca3c119c31f6ad25d9d047d06c2d8c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af642ed4edfaf4f16c99a822d54a6da28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#af642ed4edfaf4f16c99a822d54a6da28">min_id</a> = std::numeric_limits&lt;<a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a>&gt;::max()</td></tr>
<tr class="memdesc:af642ed4edfaf4f16c99a822d54a6da28"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum ID in the graph.  <a href="#af642ed4edfaf4f16c99a822d54a6da28">More...</a><br /></td></tr>
<tr class="separator:af642ed4edfaf4f16c99a822d54a6da28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9347a79f203cea8dcb2ad718239c0d16"><td class="memItemLeft" align="right" valign="top">PagedVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a9347a79f203cea8dcb2ad718239c0d16">graph_iv</a></td></tr>
<tr class="separator:a9347a79f203cea8dcb2ad718239c0d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff031e9f06dde29714840fbdc7595b26"><td class="memItemLeft" align="right" valign="top">PagedVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#aff031e9f06dde29714840fbdc7595b26">seq_start_iv</a></td></tr>
<tr class="memdesc:aff031e9f06dde29714840fbdc7595b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the start of a node's sequence in seq_iv. Matches the order of graph_iv.  <a href="#aff031e9f06dde29714840fbdc7595b26">More...</a><br /></td></tr>
<tr class="separator:aff031e9f06dde29714840fbdc7595b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9a47b712acd4004b8193fc7d089854"><td class="memItemLeft" align="right" valign="top">PackedVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a9d9a47b712acd4004b8193fc7d089854">seq_length_iv</a></td></tr>
<tr class="memdesc:a9d9a47b712acd4004b8193fc7d089854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the length of a node's sequence in seq_iv. Matches the order of graph_iv.  <a href="#a9d9a47b712acd4004b8193fc7d089854">More...</a><br /></td></tr>
<tr class="separator:a9d9a47b712acd4004b8193fc7d089854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a1c95f63982dd19386e5b84b69d866"><td class="memItemLeft" align="right" valign="top">PagedVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a32a1c95f63982dd19386e5b84b69d866">edge_lists_iv</a></td></tr>
<tr class="separator:a32a1c95f63982dd19386e5b84b69d866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae228b7077774e863c7125eb7f7b5708d"><td class="memItemLeft" align="right" valign="top">PackedDeque&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#ae228b7077774e863c7125eb7f7b5708d">nid_to_graph_iv</a></td></tr>
<tr class="separator:ae228b7077774e863c7125eb7f7b5708d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354c95f86aad410bb56d23b6bab12f55"><td class="memItemLeft" align="right" valign="top">PackedVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a354c95f86aad410bb56d23b6bab12f55">seq_iv</a></td></tr>
<tr class="memdesc:a354c95f86aad410bb56d23b6bab12f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes all of the sequences of all nodes in the graph.  <a href="#a354c95f86aad410bb56d23b6bab12f55">More...</a><br /></td></tr>
<tr class="separator:a354c95f86aad410bb56d23b6bab12f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae899936e18848adca0be6be3dbf055ea"><td class="memItemLeft" align="right" valign="top">PagedVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#ae899936e18848adca0be6be3dbf055ea">path_membership_node_iv</a></td></tr>
<tr class="separator:ae899936e18848adca0be6be3dbf055ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2622d00d64d548bc30f42aece23179"><td class="memItemLeft" align="right" valign="top">PagedVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a4a2622d00d64d548bc30f42aece23179">path_membership_id_iv</a></td></tr>
<tr class="separator:a4a2622d00d64d548bc30f42aece23179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae31379968a57af07badb00bff7c201"><td class="memItemLeft" align="right" valign="top">PagedVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a5ae31379968a57af07badb00bff7c201">path_membership_offset_iv</a></td></tr>
<tr class="memdesc:a5ae31379968a57af07badb00bff7c201"><td class="mdescLeft">&#160;</td><td class="mdescRight">1-based offset of the occurrence of the node in the corresponding <a class="el" href="structbdsg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> vector.  <a href="#a5ae31379968a57af07badb00bff7c201">More...</a><br /></td></tr>
<tr class="separator:a5ae31379968a57af07badb00bff7c201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd372ed020a12d43bcd857897d2e20b"><td class="memItemLeft" align="right" valign="top">PagedVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a7cd372ed020a12d43bcd857897d2e20b">path_membership_next_iv</a></td></tr>
<tr class="separator:a7cd372ed020a12d43bcd857897d2e20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2759df3bc044d4c70a5c5d435fb99a"><td class="memItemLeft" align="right" valign="top">hash_map&lt; char, uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a9d2759df3bc044d4c70a5c5d435fb99a">char_assignment</a></td></tr>
<tr class="memdesc:a9d2759df3bc044d4c70a5c5d435fb99a"><td class="mdescLeft">&#160;</td><td class="mdescRight">We will reassign char values from the path names to small integers.  <a href="#a9d2759df3bc044d4c70a5c5d435fb99a">More...</a><br /></td></tr>
<tr class="separator:a9d2759df3bc044d4c70a5c5d435fb99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0351002c89d050c36827fc18bcc6da"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#aff0351002c89d050c36827fc18bcc6da">inverse_char_assignment</a></td></tr>
<tr class="memdesc:aff0351002c89d050c36827fc18bcc6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse mapping from integer to the char value.  <a href="#aff0351002c89d050c36827fc18bcc6da">More...</a><br /></td></tr>
<tr class="separator:aff0351002c89d050c36827fc18bcc6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e3b5c2c3f05fece654faf6f06fc426"><td class="memItemLeft" align="right" valign="top">PackedVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#af4e3b5c2c3f05fece654faf6f06fc426">path_names_iv</a></td></tr>
<tr class="separator:af4e3b5c2c3f05fece654faf6f06fc426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86fe04dbf96248b43407ffeae86c56fd"><td class="memItemLeft" align="right" valign="top">PagedVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a86fe04dbf96248b43407ffeae86c56fd">path_name_start_iv</a></td></tr>
<tr class="separator:a86fe04dbf96248b43407ffeae86c56fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1fed5a13cbd083d895a147a21d735bc"><td class="memItemLeft" align="right" valign="top">PackedVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#ab1fed5a13cbd083d895a147a21d735bc">path_name_length_iv</a></td></tr>
<tr class="memdesc:ab1fed5a13cbd083d895a147a21d735bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The length of the path's name for the path with the same index in paths.  <a href="#ab1fed5a13cbd083d895a147a21d735bc">More...</a><br /></td></tr>
<tr class="separator:ab1fed5a13cbd083d895a147a21d735bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5961387ed0eaf83549314c9896be054"><td class="memItemLeft" align="right" valign="top">PackedVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#af5961387ed0eaf83549314c9896be054">path_is_deleted_iv</a></td></tr>
<tr class="memdesc:af5961387ed0eaf83549314c9896be054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-vector that marks whether the path at the same index has been deleted.  <a href="#af5961387ed0eaf83549314c9896be054">More...</a><br /></td></tr>
<tr class="separator:af5961387ed0eaf83549314c9896be054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60a6dce2b61c71c35c02be42f4e9aff"><td class="memItemLeft" align="right" valign="top">PackedVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#ac60a6dce2b61c71c35c02be42f4e9aff">path_is_circular_iv</a></td></tr>
<tr class="memdesc:ac60a6dce2b61c71c35c02be42f4e9aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-vector that marks whether the path at the same index is circular.  <a href="#ac60a6dce2b61c71c35c02be42f4e9aff">More...</a><br /></td></tr>
<tr class="separator:ac60a6dce2b61c71c35c02be42f4e9aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b755f6f91328e95f4f6cfccc7fdeaf"><td class="memItemLeft" align="right" valign="top">PagedVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#ab5b755f6f91328e95f4f6cfccc7fdeaf">path_head_iv</a></td></tr>
<tr class="separator:ab5b755f6f91328e95f4f6cfccc7fdeaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057c4666cfa393873d4af73a09ec0260"><td class="memItemLeft" align="right" valign="top">PagedVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a057c4666cfa393873d4af73a09ec0260">path_tail_iv</a></td></tr>
<tr class="separator:a057c4666cfa393873d4af73a09ec0260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787243dcdc9092e1ab13560c407309cd"><td class="memItemLeft" align="right" valign="top">PackedVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a787243dcdc9092e1ab13560c407309cd">path_deleted_steps_iv</a></td></tr>
<tr class="memdesc:a787243dcdc9092e1ab13560c407309cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of steps that have have deleted from the path at the same index.  <a href="#a787243dcdc9092e1ab13560c407309cd">More...</a><br /></td></tr>
<tr class="separator:a787243dcdc9092e1ab13560c407309cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7806e6bfb0ddb6ca4e45e58284afc651"><td class="memItemLeft" align="right" valign="top">string_hash_map&lt; PackedVector, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a7806e6bfb0ddb6ca4e45e58284afc651">path_id</a></td></tr>
<tr class="memdesc:a7806e6bfb0ddb6ca4e45e58284afc651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map from path names to index in the paths vector.  <a href="#a7806e6bfb0ddb6ca4e45e58284afc651">More...</a><br /></td></tr>
<tr class="separator:a7806e6bfb0ddb6ca4e45e58284afc651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c8f7b4d16571cb20bc79af52864d72"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structbdsg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#aa8c8f7b4d16571cb20bc79af52864d72">paths</a></td></tr>
<tr class="memdesc:aa8c8f7b4d16571cb20bc79af52864d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of the embedded paths in the graph.  <a href="#aa8c8f7b4d16571cb20bc79af52864d72">More...</a><br /></td></tr>
<tr class="separator:aa8c8f7b4d16571cb20bc79af52864d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0248e98adea1be14aca2c4649ac1e7"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#adf0248e98adea1be14aca2c4649ac1e7">deleted_node_records</a> = 0</td></tr>
<tr class="separator:adf0248e98adea1be14aca2c4649ac1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c43fb8d9174124356d1e2c5e0b2631"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a03c43fb8d9174124356d1e2c5e0b2631">deleted_edge_records</a> = 0</td></tr>
<tr class="separator:a03c43fb8d9174124356d1e2c5e0b2631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4785af202afbabd7c308bd3789cb399a"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a4785af202afbabd7c308bd3789cb399a">deleted_membership_records</a> = 0</td></tr>
<tr class="separator:a4785af202afbabd7c308bd3789cb399a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bb5d94df082458102f6dfc34b0301b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a68bb5d94df082458102f6dfc34b0301b">deleted_bases</a> = 0</td></tr>
<tr class="separator:a68bb5d94df082458102f6dfc34b0301b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10bc4726865eabba327d590e7f6d62b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#ad10bc4726865eabba327d590e7f6d62b">reversing_self_edge_records</a> = 0</td></tr>
<tr class="separator:ad10bc4726865eabba327d590e7f6d62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da6fb453f0fa6b7e5862715c90b024c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a2da6fb453f0fa6b7e5862715c90b024c">deleted_reversing_self_edge_records</a> = 0</td></tr>
<tr class="separator:a2da6fb453f0fa6b7e5862715c90b024c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a1a5432d1f092d8acb2d0767386048e82"><td class="memItemLeft" align="right" valign="top">static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a1a5432d1f092d8acb2d0767386048e82">defrag_factor</a> = .2</td></tr>
<tr class="memdesc:a1a5432d1f092d8acb2d0767386048e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defragment data structures when the orphaned records are this fraction of the whole.  <a href="#a1a5432d1f092d8acb2d0767386048e82">More...</a><br /></td></tr>
<tr class="separator:a1a5432d1f092d8acb2d0767386048e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833f4f878a79f6af95d41f3ae9505ff3"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a833f4f878a79f6af95d41f3ae9505ff3">NARROW_PAGE_WIDTH</a> = 256</td></tr>
<tr class="memdesc:a833f4f878a79f6af95d41f3ae9505ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">We use standard page widths for page-compressed vectors.  <a href="#a833f4f878a79f6af95d41f3ae9505ff3">More...</a><br /></td></tr>
<tr class="separator:a833f4f878a79f6af95d41f3ae9505ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6a0778610a6c987e25973a3dc6b063"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a7e6a0778610a6c987e25973a3dc6b063">WIDE_PAGE_WIDTH</a> = 1024</td></tr>
<tr class="separator:a7e6a0778610a6c987e25973a3dc6b063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a27b74856d540814936a3ca20b99ba4"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a3a27b74856d540814936a3ca20b99ba4">GRAPH_RECORD_SIZE</a> = 2</td></tr>
<tr class="separator:a3a27b74856d540814936a3ca20b99ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872d174e49c91d80c8e6525559deead7"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a872d174e49c91d80c8e6525559deead7">GRAPH_START_EDGES_OFFSET</a> = 0</td></tr>
<tr class="separator:a872d174e49c91d80c8e6525559deead7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499c0603b67cc9897bf327839520c0d5"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a499c0603b67cc9897bf327839520c0d5">GRAPH_END_EDGES_OFFSET</a> = 1</td></tr>
<tr class="separator:a499c0603b67cc9897bf327839520c0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2a3b08add2ff14b0930c2f9b3e8515"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a6a2a3b08add2ff14b0930c2f9b3e8515">SEQ_START_RECORD_SIZE</a> = 1</td></tr>
<tr class="separator:a6a2a3b08add2ff14b0930c2f9b3e8515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312418ec8bc32e2b7190f132c2d26197"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a312418ec8bc32e2b7190f132c2d26197">SEQ_LENGTH_RECORD_SIZE</a> = 1</td></tr>
<tr class="separator:a312418ec8bc32e2b7190f132c2d26197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f31a32cc1c5822533ce5b1689ab945"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#ab5f31a32cc1c5822533ce5b1689ab945">EDGE_RECORD_SIZE</a> = 2</td></tr>
<tr class="separator:ab5f31a32cc1c5822533ce5b1689ab945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2a13720153efe904d46023ab088bca"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#ace2a13720153efe904d46023ab088bca">EDGE_TRAV_OFFSET</a> = 0</td></tr>
<tr class="separator:ace2a13720153efe904d46023ab088bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3e0c22822e51e8f722be346ce90261"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#aac3e0c22822e51e8f722be346ce90261">EDGE_NEXT_OFFSET</a> = 1</td></tr>
<tr class="separator:aac3e0c22822e51e8f722be346ce90261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8bfacdd4b3d36f7ccf07082929fbe81"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#ab8bfacdd4b3d36f7ccf07082929fbe81">NODE_MEMBER_RECORD_SIZE</a> = 1</td></tr>
<tr class="separator:ab8bfacdd4b3d36f7ccf07082929fbe81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ba89e4f0d2ef8e0770e97d2864a14d"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#ac8ba89e4f0d2ef8e0770e97d2864a14d">MEMBERSHIP_ID_RECORD_SIZE</a> = 1</td></tr>
<tr class="separator:ac8ba89e4f0d2ef8e0770e97d2864a14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac464a78936660bed504ae84cc79701c1"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#ac464a78936660bed504ae84cc79701c1">MEMBERSHIP_OFFSET_RECORD_SIZE</a> = 1</td></tr>
<tr class="separator:ac464a78936660bed504ae84cc79701c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fa18235e375ce5cfc68a04045d1e72"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a64fa18235e375ce5cfc68a04045d1e72">MEMBERSHIP_NEXT_RECORD_SIZE</a> = 1</td></tr>
<tr class="separator:a64fa18235e375ce5cfc68a04045d1e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6d769063a91f4cbeecf9955ab86001"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a7f6d769063a91f4cbeecf9955ab86001">PATH_RECORD_SIZE</a> = 2</td></tr>
<tr class="separator:a7f6d769063a91f4cbeecf9955ab86001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977ed5f554dc950591e4cc731c3b2697"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a977ed5f554dc950591e4cc731c3b2697">PATH_PREV_OFFSET</a> = 0</td></tr>
<tr class="separator:a977ed5f554dc950591e4cc731c3b2697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3baa830d54746f47c0ac02abc057002a"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a3baa830d54746f47c0ac02abc057002a">PATH_NEXT_OFFSET</a> = 1</td></tr>
<tr class="separator:a3baa830d54746f47c0ac02abc057002a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5f597ac6398e6df99dc9d457670d88"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#abf5f597ac6398e6df99dc9d457670d88">STEP_RECORD_SIZE</a> = 1</td></tr>
<tr class="separator:abf5f597ac6398e6df99dc9d457670d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6320e9cd5104ae878dfe13bb80c33a"><td class="memItemLeft" align="right" valign="top">static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdsg_1_1PackedGraph.html#a9c6320e9cd5104ae878dfe13bb80c33a">PATH_RESIZE_FACTOR</a> = 1.25</td></tr>
<tr class="separator:a9c6320e9cd5104ae878dfe13bb80c33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classhandlegraph_1_1PathHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classhandlegraph_1_1PathHandleGraph')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">handlegraph::PathHandleGraph</a></td></tr>
<tr class="memitem:a2bbdf56b268001c629cf000f5bd8bb9a inherit pro_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a2bbdf56b268001c629cf000f5bd8bb9a">for_each_step_on_handle_impl</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;)&gt; &amp;iteratee) const =0</td></tr>
<tr class="separator:a2bbdf56b268001c629cf000f5bd8bb9a inherit pro_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classbdsg_1_1PackedGraph.html">PackedGraph</a> is a HandleGraph implementation designed to use very little memory. It stores its data in bit-packed integer vectors, which are dynamically widened as needed in O(1) amortized time. Within these vectors, graphs are stored using adjacency linked lists.</p>
<p>Since removals of elements can cause slots in the internal vectors to become unused, the graph will occasionally defragment itself after some modification operations, which involves copying its internal data structures.</p>
<p>This implementation is a good choice when working with very large graphs, where the final memory usage of the constructed graph must be minimized. It is not a good choice when large fractions of the graph will need to be deleted and replaced; <a class="el" href="classbdsg_1_1ODGI.html">ODGI</a> or <a class="el" href="classbdsg_1_1HashGraph.html">HashGraph</a> may be better for such workloads. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a87b6cb6c626e2d5ee5e6de3d8df08131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b6cb6c626e2d5ee5e6de3d8df08131">&#9670;&nbsp;</a></span>PackedGraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdsg::PackedGraph::PackedGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3362b6c150ac98cbf7445755e8fedd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3362b6c150ac98cbf7445755e8fedd29">&#9670;&nbsp;</a></span>~PackedGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdsg::PackedGraph::~PackedGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afca0ee6c2a333464bc6cdb1b18c2b9d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca0ee6c2a333464bc6cdb1b18c2b9d8">&#9670;&nbsp;</a></span>PackedGraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdsg::PackedGraph::PackedGraph </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from a stream. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa79bbc84f695050d95d3a53c7812fe12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79bbc84f695050d95d3a53c7812fe12">&#9670;&nbsp;</a></span>append_path_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::append_path_name </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encode the path name into the internal representation and append it to the master list of path names. </p>

</div>
</div>
<a id="a5e5c580f60fa9630f8813d78575f7161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5c580f60fa9630f8813d78575f7161">&#9670;&nbsp;</a></span>append_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> bdsg::PackedGraph::append_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to_append</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Append a visit to a node to the given path. Returns a handle to the new final step on the path which is appended. Handles to prior steps on the path, and to other paths, must remain valid. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a83a4a14a629cde03d33e4eb3f6bb192d">handlegraph::MutablePathHandleGraph</a>.</p>

</div>
</div>
<a id="a8596b1af5d2f7c2650fcf94c4fecf367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8596b1af5d2f7c2650fcf94c4fecf367">&#9670;&nbsp;</a></span>apply_ordering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::apply_ordering </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compact_ids</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reorder the graph's internal structure to match that given. This sets the order that is used for iteration in functions like for_each_handle. Optionally compact the id space of the graph to match the ordering, from 1-&gt;|ordering|. This may be a no-op in the case of graph implementations that do not have any mechanism to maintain an ordering. </p>

</div>
</div>
<a id="a2029190f1e0d12d4bc66b1acd169335d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2029190f1e0d12d4bc66b1acd169335d">&#9670;&nbsp;</a></span>apply_orientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> bdsg::PackedGraph::apply_orientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alter the node that the given handle corresponds to so the orientation indicated by the handle becomes the node's local forward orientation. Rewrites all edges pointing to the node and the node's sequence to reflect this. Invalidates all handles to the node (including the one passed). Returns a new, valid handle to the node in its new forward orientation. Note that it is possible for the node's ID to change. Does not update any stored paths. May change the ordering of the underlying graph. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a71433449cb13e22dc19caaf544b6d7bc">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a id="a49ffbb9d5d8ff42cb196498ab39269dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ffbb9d5d8ff42cb196498ab39269dd">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all nodes and edges. Does not update any stored paths. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#a6e1a83e72b47643e43c6176f39d8db5e">handlegraph::DeletableHandleGraph</a>.</p>

</div>
</div>
<a id="a7d3af382e4be809951d40564237ca4c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d3af382e4be809951d40564237ca4c8">&#9670;&nbsp;</a></span>compact_ids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::compact_ids </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compact the node ID space to [1, num_nodes] according the indicated order. Every node must be present in the vector exactly one time to be valid. </p>

</div>
</div>
<a id="a82de7c4736713100ba59e8f6f86ac516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82de7c4736713100ba59e8f6f86ac516">&#9670;&nbsp;</a></span>complement_encoded_nucleotide()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::PackedGraph::complement_encoded_nucleotide </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Complement nucleotide encoded as [0, 4]. </p>

</div>
</div>
<a id="a457e1feb2fcdfce59119616183ca956b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457e1feb2fcdfce59119616183ca956b">&#9670;&nbsp;</a></span>create_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::create_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an edge connecting the given handles in the given order and orientations. Ignores existing edges. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a34a5e01f270713ba856a93c55039faf0">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a id="a28bde85caccd04a4bd4a9531d9177033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28bde85caccd04a4bd4a9531d9177033">&#9670;&nbsp;</a></span>create_handle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> bdsg::PackedGraph::create_handle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new node with the given sequence and return the handle. The sequence may not be empty. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a8c9d8ca8160a9b94a57000eab3e97aaa">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a id="acf661f0200611fd54c465435d3002248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf661f0200611fd54c465435d3002248">&#9670;&nbsp;</a></span>create_handle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> bdsg::PackedGraph::create_handle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new node with the given id and sequence, then return the handle. The sequence may not be empty. The ID must be strictly greater than 0. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#ae844fce457858cd2dc54dde786f79e5c">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a id="ad2a55f1b56d716f79935ff25a554ebfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a55f1b56d716f79935ff25a554ebfc">&#9670;&nbsp;</a></span>create_path_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> bdsg::PackedGraph::create_path_handle </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_circular</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a path with the given name. The caller must ensure that no path with the given name exists already, or the behavior is undefined. Returns a handle to the created empty path. Handles to other paths must remain valid. </p>

</div>
</div>
<a id="a1c47b9fdc2e68f6fd7bb8a7e98669ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c47b9fdc2e68f6fd7bb8a7e98669ee9">&#9670;&nbsp;</a></span>decode_nucleotide()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char bdsg::PackedGraph::decode_nucleotide </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map [0, 4] to nucleotides. </p>

</div>
</div>
<a id="ae14f098d6c3013afcd7a235ea2250a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14f098d6c3013afcd7a235ea2250a57">&#9670;&nbsp;</a></span>decode_path_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string bdsg::PackedGraph::decode_path_name </td>
          <td>(</td>
          <td class="paramtype">const int64_t &amp;&#160;</td>
          <td class="paramname"><em>path_idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the internal representation of a path name and return it as a string. </p>

</div>
</div>
<a id="a05f5a45b2de1f7e25341e8081f31f336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f5a45b2de1f7e25341e8081f31f336">&#9670;&nbsp;</a></span>decode_traversal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp; bdsg::PackedGraph::decode_traversal </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa7edd80968f8d6d2865da20a1307179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7edd80968f8d6d2865da20a1307179">&#9670;&nbsp;</a></span>defragment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::defragment </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if have orphaned enough records in the graph's various linked lists to warrant reallocating and defragmenting them. If so, do it. Optionally, defragment even if we have not deleted many things. </p>

</div>
</div>
<a id="a3c98ea5d42e6ab70fc04d65ac0989af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c98ea5d42e6ab70fc04d65ac0989af8">&#9670;&nbsp;</a></span>defragment_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::defragment_path </td>
          <td>(</td>
          <td class="paramtype">const int64_t &amp;&#160;</td>
          <td class="paramname"><em>path_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if have orphaned enough records in the linked list of the path to warrant reallocating and defragmenting it. If so, do it. Optionally, defragment even if we have not deleted many things. WARNING: invalidates step_handle_t's to this path. </p>

</div>
</div>
<a id="a0f2f00e2a89ad95c07c23892daaf02c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f2f00e2a89ad95c07c23892daaf02c3">&#9670;&nbsp;</a></span>deserialize_members()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::deserialize_members </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the graph from an in stream (called from the inherited 'deserialize' method) </p>

<p>Implements <a class="el" href="classhandlegraph_1_1SerializableHandleGraph.html#ab33e6ceec2d8af4eb90607fa271cb7fb">handlegraph::SerializableHandleGraph</a>.</p>

</div>
</div>
<a id="aa707e831fb29c6427d0f38adf756961e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa707e831fb29c6427d0f38adf756961e">&#9670;&nbsp;</a></span>destroy_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::destroy_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove the edge connecting the given handles in the given order and orientations. Ignores nonexistent edges. Does not update any stored paths. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#a285ac35e805eab548c4106ee534d79f2">handlegraph::DeletableHandleGraph</a>.</p>

</div>
</div>
<a id="af299fbb72bf0e424756d673990f51d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af299fbb72bf0e424756d673990f51d59">&#9670;&nbsp;</a></span>destroy_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::destroy_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove the node belonging to the given handle and all of its edges. Destroys any paths in which the node participates. Invalidates the destroyed handle. May be called during serial for_each_handle iteration <b>ONLY</b> on the node being iterated. May <b>NOT</b> be called during parallel for_each_handle iteration. May <b>NOT</b> be called on the node from which edges are being followed during follow_edges. May <b>NOT</b> be called during iteration over paths, if it would destroy a path. May <b>NOT</b> be called during iteration along a path, if it would destroy that path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#a06d4d3ecda0694d5045c457f3eecd8e3">handlegraph::DeletableHandleGraph</a>.</p>

</div>
</div>
<a id="ade4984d8fbd73d4661173cd8ae773a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4984d8fbd73d4661173cd8ae773a87">&#9670;&nbsp;</a></span>destroy_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::destroy_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroy the given path. Invalidates handles to the path and its node steps. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a05a7303ef2f259c6384b0b9b1f9d3f56">handlegraph::MutablePathHandleGraph</a>.</p>

</div>
</div>
<a id="afcf885bc104efc729931c960d708cb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf885bc104efc729931c960d708cb24">&#9670;&nbsp;</a></span>divide_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; bdsg::PackedGraph::divide_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a handle's underlying node at the given offsets in the handle's orientation. Returns all of the handles to the parts. Other handles to the node being split may be invalidated. The split pieces stay in the same local forward orientation as the original node, but the returned handles come in the order and orientation appropriate for the handle passed in. Updates stored paths. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#aca166406fa2000778552ed77c41a5e4c">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a id="a4b6b2e4d2f72aa541e04e21fabeaec89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6b2e4d2f72aa541e04e21fabeaec89">&#9670;&nbsp;</a></span>eject_deleted_paths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::eject_deleted_paths </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If we've deleted any paths, remove them from the paths vector and reassign path IDs. </p>

</div>
</div>
<a id="a7c60e2c48e1b656edf89c2b338308871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c60e2c48e1b656edf89c2b338308871">&#9670;&nbsp;</a></span>encode_and_assign_path_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PackedVector bdsg::PackedGraph::encode_and_assign_path_name </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a path name into an integer vector, assigning new chars as necessary. </p>

</div>
</div>
<a id="a1016444a5f5ffd73c0cfbd3fb9375359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1016444a5f5ffd73c0cfbd3fb9375359">&#9670;&nbsp;</a></span>encode_nucleotide()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::PackedGraph::encode_nucleotide </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>nt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience functions to translate between encodings in the vectors. </p>
<p>Map nucleotides into [0, 4] </p>

</div>
</div>
<a id="a0bd861560dbc8f5f3e36f0554892e580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd861560dbc8f5f3e36f0554892e580">&#9670;&nbsp;</a></span>encode_path_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PackedVector bdsg::PackedGraph::encode_path_name </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a path name into an integer vector using only existing char assignments If the path name contains previously unseen characters, returns an empty vector. </p>

</div>
</div>
<a id="a435427441951ae3816cf6376f4ca3451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a435427441951ae3816cf6376f4ca3451">&#9670;&nbsp;</a></span>encode_traversal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint64_t &amp; bdsg::PackedGraph::encode_traversal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1bfe9d375da81afe833dde436d4fd4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1bfe9d375da81afe833dde436d4fd4f">&#9670;&nbsp;</a></span>extract_encoded_path_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PackedVector bdsg::PackedGraph::extract_encoded_path_name </td>
          <td>(</td>
          <td class="paramtype">const int64_t &amp;&#160;</td>
          <td class="paramname"><em>path_idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the internal representation of a path name, but do not decode it. </p>

</div>
</div>
<a id="a70d6ff30cfee43a4775f193cb4be7b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d6ff30cfee43a4775f193cb4be7b65">&#9670;&nbsp;</a></span>flip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> bdsg::PackedGraph::flip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invert the orientation of a handle (potentially without getting its ID) </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#aaa3f94ae7e884408ef6e8ca8fd45c7d7">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="ad4ffc74c329a625ee889a26d0ec805ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ffc74c329a625ee889a26d0ec805ca">&#9670;&nbsp;</a></span>follow_edges_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::PackedGraph::follow_edges_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>go_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loop over all the handles to next/previous (right/left) nodes. Passes them to a callback which returns false to stop iterating and true to continue. Returns true if we finished and false if we stopped early. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a89bbc118fe1e8e1acb162c14be33e8b5">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a069cacf9a8547b92ceffe0eb308570a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a069cacf9a8547b92ceffe0eb308570a7">&#9670;&nbsp;</a></span>for_each_handle_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::PackedGraph::for_each_handle_impl </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loop over all the nodes in the graph in their local forward orientations, in their internal stored order. Stop if the iteratee returns false. Can be told to run in parallel, in which case stopping after a false return value is on a best-effort basis and iteration order is not defined. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#af48ba081fcb810267dc50e3a3e7ad391">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a6a62949f7ae3e0e4ea23bde66febc1e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a62949f7ae3e0e4ea23bde66febc1e1">&#9670;&nbsp;</a></span>for_each_path_handle_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::PackedGraph::for_each_path_handle_impl </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a function on each path in the graph. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a79f48793555f6be311f6df6603324e7b">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a9d430c401baf707511c35e9f21e391b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d430c401baf707511c35e9f21e391b0">&#9670;&nbsp;</a></span>for_each_step_on_handle_impl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::PackedGraph::for_each_step_on_handle_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the given function for each step of the given handle on a path. </p>

</div>
</div>
<a id="acb15feea2045b0f8e44893af1f4a1bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb15feea2045b0f8e44893af1f4a1bdb">&#9670;&nbsp;</a></span>get_assignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::PackedGraph::get_assignment </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the integer assignment of a char, or numeric_limits&lt;uint64_t&gt;::max() if no assignment has been made </p>

</div>
</div>
<a id="ae0689098db10d3a299d0da887b3ac3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0689098db10d3a299d0da887b3ac3e4">&#9670;&nbsp;</a></span>get_base()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char bdsg::PackedGraph::get_base </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns one base of a handle's sequence, in the orientation of the handle. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1HandleGraph.html#a64d58c3e26e9e7954dd25c3eff7af521">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a4be6ecd4ae5805a72c5a6856f7ef2ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be6ecd4ae5805a72c5a6856f7ef2ed6">&#9670;&nbsp;</a></span>get_char()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char bdsg::PackedGraph::get_char </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>assignment</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the char assigned to an integer (must be already assigned) </p>

</div>
</div>
<a id="a47a29e8af8100512e741664c1b02f723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a29e8af8100512e741664c1b02f723">&#9670;&nbsp;</a></span>get_edge_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t bdsg::PackedGraph::get_edge_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of edges in the graph. If not overridden, counts them all in linear time. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1HandleGraph.html#a20ff62014d7f0f0c01ada8a3d40a278d">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a1d073358f58fe721cd9585697341e440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d073358f58fe721cd9585697341e440">&#9670;&nbsp;</a></span>get_edge_target()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::PackedGraph::get_edge_target </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>edge_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adca60a15f8e345f4e1d768242d4ea467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca60a15f8e345f4e1d768242d4ea467">&#9670;&nbsp;</a></span>get_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> bdsg::PackedGraph::get_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> &amp;&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up the handle for the node with the given ID in the given orientation. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a6dd9d70931835f5c75518b23a780b744">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a468a71289a32bc7d2389457896c581f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a468a71289a32bc7d2389457896c581f8">&#9670;&nbsp;</a></span>get_handle_of_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> bdsg::PackedGraph::get_handle_of_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a node handle (node ID and orientation) from a handle to an step on a path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a339e690ce3e2bb8280dd1f3ea45abe42">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a512c710d04d1c149509e42ad8ca398a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512c710d04d1c149509e42ad8ca398a6">&#9670;&nbsp;</a></span>get_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> bdsg::PackedGraph::get_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ID from a handle. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#adb7f6e144bf2a59679f7b2eddad934eb">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="ae614ce491ea677b086ef323cef123013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae614ce491ea677b086ef323cef123013">&#9670;&nbsp;</a></span>get_is_circular()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::PackedGraph::get_is_circular </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up whether a path is circular. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a9391c34d9f0c16b21d5bb3bb7ec772e4">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a0fe45fa6049feccdb2483480c933c18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe45fa6049feccdb2483480c933c18c">&#9670;&nbsp;</a></span>get_is_reverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::PackedGraph::get_is_reverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the orientation of a handle. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a92773f90eb58f18adb9418a4440223c1">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a9e362150d842d5d41dc45862b22d3678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e362150d842d5d41dc45862b22d3678">&#9670;&nbsp;</a></span>get_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t bdsg::PackedGraph::get_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of a node. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a569ff35fb85c725b0b6b6933ed303e49">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="aa21ccd2b60369a6375d33d0f51073a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa21ccd2b60369a6375d33d0f51073a89">&#9670;&nbsp;</a></span>get_magic_number()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t bdsg::PackedGraph::get_magic_number </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a static high-entropy number to indicate the class. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1SerializableHandleGraph.html#a9a599d81c23e4f13e4a94f7252e8351d">handlegraph::SerializableHandleGraph</a>.</p>

</div>
</div>
<a id="a21ac15735f507befa1c31fdcecc565c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ac15735f507befa1c31fdcecc565c0">&#9670;&nbsp;</a></span>get_membership_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::PackedGraph::get_membership_path </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>membership_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a306dc538bd192d5798d3fb6d2ab4a126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306dc538bd192d5798d3fb6d2ab4a126">&#9670;&nbsp;</a></span>get_membership_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::PackedGraph::get_membership_step </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>membership_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6348575901320aff5c13dfc5d4a983e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6348575901320aff5c13dfc5d4a983e">&#9670;&nbsp;</a></span>get_next_edge_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::PackedGraph::get_next_edge_index </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>edge_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af8b13eb9f4ad3c3fa44719fb5de07b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b13eb9f4ad3c3fa44719fb5de07b11">&#9670;&nbsp;</a></span>get_next_membership()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::PackedGraph::get_next_membership </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>membership_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4b91251e9cb6cbfd8388d4268217c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b91251e9cb6cbfd8388d4268217c45">&#9670;&nbsp;</a></span>get_next_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> bdsg::PackedGraph::get_next_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a handle to the next step on the path. If the given step is the final step of a non-circular path, returns the past-the-last step that is also returned by path_end. In a circular path, the "last" step will loop around to the "first" (i.e. the one returned by path_begin). Note: to iterate over each step one time, even in a circular path, consider for_each_step_in_path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a209786f5c9e2c0210b383f2022ee221f">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a08d810c3086dd53670ca6ece7808869f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d810c3086dd53670ca6ece7808869f">&#9670;&nbsp;</a></span>get_node_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t bdsg::PackedGraph::get_node_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of nodes in the graph. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a9f95108e6c3f68f404fa93bd3306e4c6">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a1cfc43082e5b17115f9a66fd216f37a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cfc43082e5b17115f9a66fd216f37a7">&#9670;&nbsp;</a></span>get_or_make_assignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::PackedGraph::get_or_make_assignment </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the integer assignment of a char, assigning a new one if necessary. </p>

</div>
</div>
<a id="ac7fb8307d18f2dc78756d8430a705a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7fb8307d18f2dc78756d8430a705a93">&#9670;&nbsp;</a></span>get_path_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t bdsg::PackedGraph::get_path_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of paths stored in the graph. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#acd5df753593ecdfb7aa8c411b98ebad9">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a3ceae162ab93a6cece2d222cb32aee60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ceae162ab93a6cece2d222cb32aee60">&#9670;&nbsp;</a></span>get_path_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> bdsg::PackedGraph::get_path_handle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Look up the path handle for the given path name. The path with that name must exist. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a5d6059d716882a80e3982de17011866e">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="acbc6e38517f00e4e61bd9e3a5af1a962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbc6e38517f00e4e61bd9e3a5af1a962">&#9670;&nbsp;</a></span>get_path_handle_of_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> bdsg::PackedGraph::get_path_handle_of_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a handle to the path that an step is on. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a1d1ca9865da585257709f54769f5d6a9">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a41bd8484de5fedfd126eb6be86f277e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41bd8484de5fedfd126eb6be86f277e7">&#9670;&nbsp;</a></span>get_path_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string bdsg::PackedGraph::get_path_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up the name of a path from a handle to it. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a565f4312a42dfe77ae14c1ee9ed9f2ba">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a43eef1990fdfd67c34f44894a89bfeda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43eef1990fdfd67c34f44894a89bfeda">&#9670;&nbsp;</a></span>get_previous_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> bdsg::PackedGraph::get_previous_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a handle to the previous step on the path. If the given step is the first step of a non-circular path, this method has undefined behavior. In a circular path, it will loop around from the "first" step (i.e. the one returned by path_begin) to the "last" step. Note: to iterate over each step one time, even in a circular path, consider for_each_step_in_path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a71040226b29aa5046f4cc04c8c9aa9fb">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="ae1442d05ca10695703721089632313e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1442d05ca10695703721089632313e7">&#9670;&nbsp;</a></span>get_sequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string bdsg::PackedGraph::get_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the sequence of a node, presented in the handle's local forward orientation. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a8cc2ab8a1292e30ba5e167a823f66d92">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a51ec5ffe54100d8ce84aa41ea666f694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ec5ffe54100d8ce84aa41ea666f694">&#9670;&nbsp;</a></span>get_step_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t bdsg::PackedGraph::get_step_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of node steps in the path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#add91075c3490f8dc5acf667f2b26832c">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a0e5e6d5fc977a25196b38b854e4720ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e5e6d5fc977a25196b38b854e4720ae">&#9670;&nbsp;</a></span>get_step_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::PackedGraph::get_step_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbdsg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>step_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7fa43f7ff31b78890940c43c93c1c1e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa43f7ff31b78890940c43c93c1c1e2">&#9670;&nbsp;</a></span>get_step_prev()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::PackedGraph::get_step_prev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbdsg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>step_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d8c62ed8289ad8a4fb96dc208e33a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8c62ed8289ad8a4fb96dc208e33a44">&#9670;&nbsp;</a></span>get_step_trav()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::PackedGraph::get_step_trav </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbdsg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>step_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acdea91d8bd3743cbd15fca819bf3cdea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdea91d8bd3743cbd15fca819bf3cdea">&#9670;&nbsp;</a></span>get_subsequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string bdsg::PackedGraph::get_subsequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a substring of a handle's sequence, in the orientation of the handle. If the indicated substring would extend beyond the end of the handle's sequence, the return value is truncated to the sequence's end. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1HandleGraph.html#a74c6fcda357516b1160996c63ed40d63">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="ac3f8b11cd024d595f443d667bb51686c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3f8b11cd024d595f443d667bb51686c">&#9670;&nbsp;</a></span>get_total_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t bdsg::PackedGraph::get_total_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total length of all nodes in the graph, in bp. If not overridden, loops over all nodes in linear time. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1HandleGraph.html#a4c98da99e0d32ebcc9fd31be4b779e29">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a77f8e3be2f3193775661754abde2ac8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f8e3be2f3193775661754abde2ac8e">&#9670;&nbsp;</a></span>graph_index_to_node_member_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::PackedGraph::graph_index_to_node_member_index </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>graph_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8678b4d2c1b2b4327218fbb32dd6a57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8678b4d2c1b2b4327218fbb32dd6a57b">&#9670;&nbsp;</a></span>graph_index_to_seq_len_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::PackedGraph::graph_index_to_seq_len_index </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>graph_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a43758247e9cf4dde965134d300527d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43758247e9cf4dde965134d300527d1c">&#9670;&nbsp;</a></span>graph_index_to_seq_start_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::PackedGraph::graph_index_to_seq_start_index </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>graph_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a370b82704992635d03210f033f65d688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370b82704992635d03210f033f65d688">&#9670;&nbsp;</a></span>graph_iv_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t bdsg::PackedGraph::graph_iv_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8141214b86c13f99d5105fd0479b25af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8141214b86c13f99d5105fd0479b25af">&#9670;&nbsp;</a></span>has_next_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::PackedGraph::has_next_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the step is not the last step in a non-circular path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a81bf54cb4d07a0d47c84862ecebc349d">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a7294b78c97f997722b16b63e44f3097b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7294b78c97f997722b16b63e44f3097b">&#9670;&nbsp;</a></span>has_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::PackedGraph::has_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to check if a node exists by ID. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a6e58a79001cd7d839ac1f1adaff34dfb">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a6f833ac365097e97efe196eaf46e37a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f833ac365097e97efe196eaf46e37a7">&#9670;&nbsp;</a></span>has_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::PackedGraph::has_path </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if a path name exists and is legal to get a path handle for. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#ab7de11c1e994bc104378c4b798013430">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="ab5e6944d161770bafd7aeaa8508ef93a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e6944d161770bafd7aeaa8508ef93a">&#9670;&nbsp;</a></span>has_previous_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bdsg::PackedGraph::has_previous_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the step is not the first step in a non-circular path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a93a1ee451e750cb82f1711fd6c3db8cc">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="aab3c1c0c184ce781b1f792149331cbfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3c1c0c184ce781b1f792149331cbfb">&#9670;&nbsp;</a></span>increment_node_ids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::increment_node_ids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a>&#160;</td>
          <td class="paramname"><em>increment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add the given value to all node IDs </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a902b211a1f86645818b3da1cb64af0be">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a id="a66e3e50eb06c106445f975a9f9f64bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e3e50eb06c106445f975a9f9f64bdb">&#9670;&nbsp;</a></span>max_node_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> bdsg::PackedGraph::max_node_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the largest ID in the graph, or some larger number if the largest ID is unavailable. Return value is unspecified if the graph is empty. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a5a2e2b1ea6a29b3f4b34a6abcb6dbc50">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a4666ae932f6847857c9cb625829bb0db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4666ae932f6847857c9cb625829bb0db">&#9670;&nbsp;</a></span>min_node_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> bdsg::PackedGraph::min_node_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the smallest ID in the graph, or some smaller number if the smallest ID is unavailable. Return value is unspecified if the graph is empty. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a85c52fe4b5f483504ed142d0ad94a969">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a96c4113ab7366834d2dbce6ee3f4bf96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c4113ab7366834d2dbce6ee3f4bf96">&#9670;&nbsp;</a></span>new_node_record()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t bdsg::PackedGraph::new_node_record </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize all of the data corresponding with a new node and return it's 1-based offset </p>

</div>
</div>
<a id="a3cb1c32597c3d92b956333fe5d1b7eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb1c32597c3d92b956333fe5d1b7eb3">&#9670;&nbsp;</a></span>optimize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::optimize </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_id_reassignment</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adjust the representation of the graph in memory to improve performance. Optionally, allow the node IDs to be reassigned to further improve performance. Note: Ideally, this method is called one time once there is expected to be few graph modifications in the future. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a195c81fa446b62d94fda8841eaa3bb85">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a id="acd30df6ea1bce48e05bf6254655ccf25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd30df6ea1bce48e05bf6254655ccf25">&#9670;&nbsp;</a></span>path_back()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> bdsg::PackedGraph::path_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a handle to the last step, which will be an arbitrary step in a circular path that we consider "last" based on our construction of the path. If the path is empty then the implementation must return the same value as <a class="el" href="classbdsg_1_1PackedGraph.html#af4bb4bbfad090dc16fe0bfd4d6717bed">path_front_end()</a>. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a31bb33a87ad8efd68876fc5ae1deeb09">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a74c61530afad057172fcff0a65fc9547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c61530afad057172fcff0a65fc9547">&#9670;&nbsp;</a></span>path_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> bdsg::PackedGraph::path_begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a handle to the first step, or in a circular path to an arbitrary step considered "first". If the path is empty, returns the past-the-last step returned by path_end. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a815759484087ed92214c2c1c6b9d1a11">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="ae4dc11493d3c114370f0cf2c82fefd81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4dc11493d3c114370f0cf2c82fefd81">&#9670;&nbsp;</a></span>path_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> bdsg::PackedGraph::path_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a handle to a fictitious position past the end of a path. This position is return by get_next_step for the final step in a path in a non-circular path. Note that get_next_step will <em>NEVER</em> return this value for a circular path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a5c3a5e04838d9e4a0a0ddf574c4de827">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="af4bb4bbfad090dc16fe0bfd4d6717bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4bb4bbfad090dc16fe0bfd4d6717bed">&#9670;&nbsp;</a></span>path_front_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> bdsg::PackedGraph::path_front_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a handle to a fictitious position before the beginning of a path. This position is return by get_previous_step for the first step in a path in a non-circular path. Note: get_previous_step will <em>NEVER</em> return this value for a circular path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#ad7412bf19084f2b38ffec42517a6a9e9">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a5c0a7f1579a8c18cf1de1a5690cd1ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0a7f1579a8c18cf1de1a5690cd1ed4">&#9670;&nbsp;</a></span>prepend_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> bdsg::PackedGraph::prepend_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to_prepend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prepend a visit to a node to the given path. Returns a handle to the new first step on the path which is appended. If the path is cirular, the new step is placed between the steps considered "last" and "first" by the method path_begin. Handles to later steps on the path, and to other paths, must remain valid. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#aed17038a0104017d37ff74e15f7f436a">handlegraph::MutablePathHandleGraph</a>.</p>

</div>
</div>
<a id="af7f213978cb671f8e9586901321b79e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f213978cb671f8e9586901321b79e2">&#9670;&nbsp;</a></span>reassign_node_ids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::reassign_node_ids </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; <a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a>(const <a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>get_new_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reassign all node IDs as specified by the old-&gt;new mapping function. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a4805d276a83a1dad2462e6b8dd2443dc">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a id="a47754701687bd025df96798b22ad9f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47754701687bd025df96798b22ad9f44">&#9670;&nbsp;</a></span>remove_edge_reference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::remove_edge_reference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find and edge on given handle, to a given handle, and remove it from the edge list. </p>

</div>
</div>
<a id="a78de6cdf98b68b77a0d44eb843571d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78de6cdf98b68b77a0d44eb843571d8c">&#9670;&nbsp;</a></span>report_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::report_memory </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>individual_paths</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Debugging function, measures memory and prints a report to an ostream. Optionally reports memory usage for every path individually. </p>

</div>
</div>
<a id="af2297321ff0f8a0f8dafcfc79e85a899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2297321ff0f8a0f8dafcfc79e85a899">&#9670;&nbsp;</a></span>rewrite_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; bdsg::PackedGraph::rewrite_segment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>segment_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>segment_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_segment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete a segment of a path and rewrite it as some other sequence of steps. Returns a pair of step_handle_t's that indicate the range of the new segment in the path. The segment to delete should be designated by the first (begin) and past-last (end) step handles. If the step that is returned by path_begin is deleted, path_begin will now return the first step from the new segment or, in the case that the new segment is empty, the step used as segment_end. Empty ranges consist of two copies of the same step handle. Empty ranges in empty paths consist of two copies of the end sentinel handle for the path. Rewriting an empty range inserts before the provided end handle. </p>

</div>
</div>
<a id="abebaf484e5f8ca064aa30cc3fba38d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abebaf484e5f8ca064aa30cc3fba38d1f">&#9670;&nbsp;</a></span>serialize_members()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::serialize_members </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the graph to an out stream (called from the inherited 'serialize' method) </p>

<p>Implements <a class="el" href="classhandlegraph_1_1SerializableHandleGraph.html#a4d33bf8cbf4fb0d5e81df696be177057">handlegraph::SerializableHandleGraph</a>.</p>

</div>
</div>
<a id="aaa756f1d4671ea6a22382f1753c1bd17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa756f1d4671ea6a22382f1753c1bd17">&#9670;&nbsp;</a></span>set_circularity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::set_circularity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>circular</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a path circular or non-circular. If the path is becoming circular, the last step is joined to the first step. If the path is becoming linear, the step considered "last" is unjoined from the step considered "first" according to the method path_begin. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a9172694447503e35d50093d55e845eb8">handlegraph::MutablePathHandleGraph</a>.</p>

</div>
</div>
<a id="a612b299b52d1a53359f16bbdec0886ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612b299b52d1a53359f16bbdec0886ce">&#9670;&nbsp;</a></span>set_edge_target()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::set_edge_target </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>edge_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a265258f9e9ea78a96e86f594e11224ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265258f9e9ea78a96e86f594e11224ad">&#9670;&nbsp;</a></span>set_id_increment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::set_id_increment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> &amp;&#160;</td>
          <td class="paramname"><em>min_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set a minimum id to increment the id space by, used as a hint during construction. May have no effect on a backing implementation. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#ab844ab426cd9f289414aca4d8b892ca9">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a id="a692302b97529bc3ef3a6423d84efa6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692302b97529bc3ef3a6423d84efa6cc">&#9670;&nbsp;</a></span>set_membership_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::set_membership_path </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>membership_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a933958da682703e613cd9cbb233d79a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933958da682703e613cd9cbb233d79a9">&#9670;&nbsp;</a></span>set_membership_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::set_membership_step </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>membership_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e10bae6fc4504b557a9b72e217c0f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e10bae6fc4504b557a9b72e217c0f1b">&#9670;&nbsp;</a></span>set_next_membership()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::set_next_membership </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>membership_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acc68c23fd4d161a26dc17c65216c83fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc68c23fd4d161a26dc17c65216c83fb">&#9670;&nbsp;</a></span>set_step_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::set_step_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdsg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>step_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>next_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4038aba29d614501d927c81d3002d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4038aba29d614501d927c81d3002d38">&#9670;&nbsp;</a></span>set_step_prev()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::set_step_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdsg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>step_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>prev_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a85d9748a1599137ceace5b11561779f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d9748a1599137ceace5b11561779f9">&#9670;&nbsp;</a></span>set_step_trav()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::set_step_trav </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdsg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>step_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>trav</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af1dc6acc90fe7e14046bc22844b36991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1dc6acc90fe7e14046bc22844b36991">&#9670;&nbsp;</a></span>tighten()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bdsg::PackedGraph::tighten </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to compress data into less memory, possibly using more memory temporarily (especially useful before serializing). Node handles remain valid, but path and step handles are invalidated. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9d2759df3bc044d4c70a5c5d435fb99a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2759df3bc044d4c70a5c5d435fb99a">&#9670;&nbsp;</a></span>char_assignment</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hash_map&lt;char, uint64_t&gt; bdsg::PackedGraph::char_assignment</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We will reassign char values from the path names to small integers. </p>

</div>
</div>
<a id="a1a5432d1f092d8acb2d0767386048e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5432d1f092d8acb2d0767386048e82">&#9670;&nbsp;</a></span>defrag_factor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double bdsg::PackedGraph::defrag_factor = .2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defragment data structures when the orphaned records are this fraction of the whole. </p>
<p>Define all of the static class variables. </p>

</div>
</div>
<a id="a68bb5d94df082458102f6dfc34b0301b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bb5d94df082458102f6dfc34b0301b">&#9670;&nbsp;</a></span>deleted_bases</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::PackedGraph::deleted_bases = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a03c43fb8d9174124356d1e2c5e0b2631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c43fb8d9174124356d1e2c5e0b2631">&#9670;&nbsp;</a></span>deleted_edge_records</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::PackedGraph::deleted_edge_records = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4785af202afbabd7c308bd3789cb399a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4785af202afbabd7c308bd3789cb399a">&#9670;&nbsp;</a></span>deleted_membership_records</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::PackedGraph::deleted_membership_records = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adf0248e98adea1be14aca2c4649ac1e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf0248e98adea1be14aca2c4649ac1e7">&#9670;&nbsp;</a></span>deleted_node_records</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::PackedGraph::deleted_node_records = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2da6fb453f0fa6b7e5862715c90b024c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da6fb453f0fa6b7e5862715c90b024c">&#9670;&nbsp;</a></span>deleted_reversing_self_edge_records</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::PackedGraph::deleted_reversing_self_edge_records = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a32a1c95f63982dd19386e5b84b69d866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a1c95f63982dd19386e5b84b69d866">&#9670;&nbsp;</a></span>edge_lists_iv</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PagedVector bdsg::PackedGraph::edge_lists_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encodes a series of edges lists of nodes. {ID|orientation (bit-packed), next edge index} </p>

</div>
</div>
<a id="aac3e0c22822e51e8f722be346ce90261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3e0c22822e51e8f722be346ce90261">&#9670;&nbsp;</a></span>EDGE_NEXT_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t bdsg::PackedGraph::EDGE_NEXT_OFFSET = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5f31a32cc1c5822533ce5b1689ab945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f31a32cc1c5822533ce5b1689ab945">&#9670;&nbsp;</a></span>EDGE_RECORD_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t bdsg::PackedGraph::EDGE_RECORD_SIZE = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ace2a13720153efe904d46023ab088bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2a13720153efe904d46023ab088bca">&#9670;&nbsp;</a></span>EDGE_TRAV_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t bdsg::PackedGraph::EDGE_TRAV_OFFSET = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a499c0603b67cc9897bf327839520c0d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a499c0603b67cc9897bf327839520c0d5">&#9670;&nbsp;</a></span>GRAPH_END_EDGES_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t bdsg::PackedGraph::GRAPH_END_EDGES_OFFSET = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9347a79f203cea8dcb2ad718239c0d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9347a79f203cea8dcb2ad718239c0d16">&#9670;&nbsp;</a></span>graph_iv</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PagedVector bdsg::PackedGraph::graph_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encodes the topology of the graph. Consists of fixed width records that represent offsets in edge_lists_iv. {start edge list index, end edge list index} </p>

</div>
</div>
<a id="a3a27b74856d540814936a3ca20b99ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a27b74856d540814936a3ca20b99ba4">&#9670;&nbsp;</a></span>GRAPH_RECORD_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t bdsg::PackedGraph::GRAPH_RECORD_SIZE = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a872d174e49c91d80c8e6525559deead7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a872d174e49c91d80c8e6525559deead7">&#9670;&nbsp;</a></span>GRAPH_START_EDGES_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t bdsg::PackedGraph::GRAPH_START_EDGES_OFFSET = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aff0351002c89d050c36827fc18bcc6da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0351002c89d050c36827fc18bcc6da">&#9670;&nbsp;</a></span>inverse_char_assignment</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string bdsg::PackedGraph::inverse_char_assignment</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The inverse mapping from integer to the char value. </p>

</div>
</div>
<a id="aca3c119c31f6ad25d9d047d06c2d8c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3c119c31f6ad25d9d047d06c2d8c08">&#9670;&nbsp;</a></span>max_id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> bdsg::PackedGraph::max_id = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum ID in the graph. </p>

</div>
</div>
<a id="ac8ba89e4f0d2ef8e0770e97d2864a14d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ba89e4f0d2ef8e0770e97d2864a14d">&#9670;&nbsp;</a></span>MEMBERSHIP_ID_RECORD_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t bdsg::PackedGraph::MEMBERSHIP_ID_RECORD_SIZE = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a64fa18235e375ce5cfc68a04045d1e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64fa18235e375ce5cfc68a04045d1e72">&#9670;&nbsp;</a></span>MEMBERSHIP_NEXT_RECORD_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t bdsg::PackedGraph::MEMBERSHIP_NEXT_RECORD_SIZE = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac464a78936660bed504ae84cc79701c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac464a78936660bed504ae84cc79701c1">&#9670;&nbsp;</a></span>MEMBERSHIP_OFFSET_RECORD_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t bdsg::PackedGraph::MEMBERSHIP_OFFSET_RECORD_SIZE = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af642ed4edfaf4f16c99a822d54a6da28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af642ed4edfaf4f16c99a822d54a6da28">&#9670;&nbsp;</a></span>min_id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a> bdsg::PackedGraph::min_id = std::numeric_limits&lt;<a class="el" href="namespacebdsg.html#aff7379503bb3493f556fdc1f8111c3e1">nid_t</a>&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The minimum ID in the graph. </p>

</div>
</div>
<a id="a833f4f878a79f6af95d41f3ae9505ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833f4f878a79f6af95d41f3ae9505ff3">&#9670;&nbsp;</a></span>NARROW_PAGE_WIDTH</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t bdsg::PackedGraph::NARROW_PAGE_WIDTH = 256</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We use standard page widths for page-compressed vectors. </p>

</div>
</div>
<a id="ae228b7077774e863c7125eb7f7b5708d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae228b7077774e863c7125eb7f7b5708d">&#9670;&nbsp;</a></span>nid_to_graph_iv</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PackedDeque bdsg::PackedGraph::nid_to_graph_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encodes the 1-based offset of an ID in graph_iv in units of GRAPH_RECORD_SIZE. If no node with that ID exists, contains a 0. The index of a given ID is computed by (ID - min ID). </p>

</div>
</div>
<a id="ab8bfacdd4b3d36f7ccf07082929fbe81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8bfacdd4b3d36f7ccf07082929fbe81">&#9670;&nbsp;</a></span>NODE_MEMBER_RECORD_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t bdsg::PackedGraph::NODE_MEMBER_RECORD_SIZE = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a787243dcdc9092e1ab13560c407309cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a787243dcdc9092e1ab13560c407309cd">&#9670;&nbsp;</a></span>path_deleted_steps_iv</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PackedVector bdsg::PackedGraph::path_deleted_steps_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of steps that have have deleted from the path at the same index. </p>

</div>
</div>
<a id="ab5b755f6f91328e95f4f6cfccc7fdeaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b755f6f91328e95f4f6cfccc7fdeaf">&#9670;&nbsp;</a></span>path_head_iv</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PagedVector bdsg::PackedGraph::path_head_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The 1-based index of the head of the linked list in steps_iv of the path with the same index in paths </p>

</div>
</div>
<a id="a7806e6bfb0ddb6ca4e45e58284afc651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7806e6bfb0ddb6ca4e45e58284afc651">&#9670;&nbsp;</a></span>path_id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string_hash_map&lt;PackedVector, int64_t&gt; bdsg::PackedGraph::path_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map from path names to index in the paths vector. </p>

</div>
</div>
<a id="ac60a6dce2b61c71c35c02be42f4e9aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60a6dce2b61c71c35c02be42f4e9aff">&#9670;&nbsp;</a></span>path_is_circular_iv</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PackedVector bdsg::PackedGraph::path_is_circular_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit-vector that marks whether the path at the same index is circular. </p>

</div>
</div>
<a id="af5961387ed0eaf83549314c9896be054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5961387ed0eaf83549314c9896be054">&#9670;&nbsp;</a></span>path_is_deleted_iv</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PackedVector bdsg::PackedGraph::path_is_deleted_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit-vector that marks whether the path at the same index has been deleted. </p>

</div>
</div>
<a id="a4a2622d00d64d548bc30f42aece23179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2622d00d64d548bc30f42aece23179">&#9670;&nbsp;</a></span>path_membership_id_iv</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PagedVector bdsg::PackedGraph::path_membership_id_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encodes a series of linked lists of the memberships within paths. The nodes in the linked list are split over three separate vectors, with the entry at the same index in each vector corresponding to the same linked list node. Path ID (0-based index) </p>

</div>
</div>
<a id="a7cd372ed020a12d43bcd857897d2e20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd372ed020a12d43bcd857897d2e20b">&#9670;&nbsp;</a></span>path_membership_next_iv</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PagedVector bdsg::PackedGraph::path_membership_next_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>1-based offset of the next occurrence of this node on a path within this vector (or 0 if there is none) </p>

</div>
</div>
<a id="ae899936e18848adca0be6be3dbf055ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae899936e18848adca0be6be3dbf055ea">&#9670;&nbsp;</a></span>path_membership_node_iv</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PagedVector bdsg::PackedGraph::path_membership_node_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encodes the membership of a node in all paths. In the same order as graph_iv. Consists of 1-based offset to the corresponding heads of linked lists in path_membership_value_iv, which contains the actual pointers into the paths. </p>

</div>
</div>
<a id="a5ae31379968a57af07badb00bff7c201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae31379968a57af07badb00bff7c201">&#9670;&nbsp;</a></span>path_membership_offset_iv</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PagedVector bdsg::PackedGraph::path_membership_offset_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>1-based offset of the occurrence of the node in the corresponding <a class="el" href="structbdsg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a> vector. </p>

</div>
</div>
<a id="ab1fed5a13cbd083d895a147a21d735bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1fed5a13cbd083d895a147a21d735bc">&#9670;&nbsp;</a></span>path_name_length_iv</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PackedVector bdsg::PackedGraph::path_name_length_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The length of the path's name for the path with the same index in paths. </p>

</div>
</div>
<a id="a86fe04dbf96248b43407ffeae86c56fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86fe04dbf96248b43407ffeae86c56fd">&#9670;&nbsp;</a></span>path_name_start_iv</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PagedVector bdsg::PackedGraph::path_name_start_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The starting index of the path's name in path_names_iv for the path with the same index in paths </p>

</div>
</div>
<a id="af4e3b5c2c3f05fece654faf6f06fc426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e3b5c2c3f05fece654faf6f06fc426">&#9670;&nbsp;</a></span>path_names_iv</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PackedVector bdsg::PackedGraph::path_names_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>All path names, encoded according to the char assignments and concatenated in a single vector </p>

</div>
</div>
<a id="a3baa830d54746f47c0ac02abc057002a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3baa830d54746f47c0ac02abc057002a">&#9670;&nbsp;</a></span>PATH_NEXT_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t bdsg::PackedGraph::PATH_NEXT_OFFSET = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a977ed5f554dc950591e4cc731c3b2697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977ed5f554dc950591e4cc731c3b2697">&#9670;&nbsp;</a></span>PATH_PREV_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t bdsg::PackedGraph::PATH_PREV_OFFSET = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f6d769063a91f4cbeecf9955ab86001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f6d769063a91f4cbeecf9955ab86001">&#9670;&nbsp;</a></span>PATH_RECORD_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t bdsg::PackedGraph::PATH_RECORD_SIZE = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c6320e9cd5104ae878dfe13bb80c33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c6320e9cd5104ae878dfe13bb80c33a">&#9670;&nbsp;</a></span>PATH_RESIZE_FACTOR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double bdsg::PackedGraph::PATH_RESIZE_FACTOR = 1.25</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a057c4666cfa393873d4af73a09ec0260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a057c4666cfa393873d4af73a09ec0260">&#9670;&nbsp;</a></span>path_tail_iv</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PagedVector bdsg::PackedGraph::path_tail_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The 1-based index of the tail of the linked list in steps_iv of the path with the same index in paths </p>

</div>
</div>
<a id="aa8c8f7b4d16571cb20bc79af52864d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c8f7b4d16571cb20bc79af52864d72">&#9670;&nbsp;</a></span>paths</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="structbdsg_1_1PackedGraph_1_1PackedPath.html">PackedPath</a>&gt; bdsg::PackedGraph::paths</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector of the embedded paths in the graph. </p>

</div>
</div>
<a id="ad10bc4726865eabba327d590e7f6d62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10bc4726865eabba327d590e7f6d62b">&#9670;&nbsp;</a></span>reversing_self_edge_records</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bdsg::PackedGraph::reversing_self_edge_records = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a354c95f86aad410bb56d23b6bab12f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354c95f86aad410bb56d23b6bab12f55">&#9670;&nbsp;</a></span>seq_iv</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PackedVector bdsg::PackedGraph::seq_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encodes all of the sequences of all nodes in the graph. </p>

</div>
</div>
<a id="a9d9a47b712acd4004b8193fc7d089854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9a47b712acd4004b8193fc7d089854">&#9670;&nbsp;</a></span>seq_length_iv</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PackedVector bdsg::PackedGraph::seq_length_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encodes the length of a node's sequence in seq_iv. Matches the order of graph_iv. </p>

</div>
</div>
<a id="a312418ec8bc32e2b7190f132c2d26197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a312418ec8bc32e2b7190f132c2d26197">&#9670;&nbsp;</a></span>SEQ_LENGTH_RECORD_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t bdsg::PackedGraph::SEQ_LENGTH_RECORD_SIZE = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aff031e9f06dde29714840fbdc7595b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff031e9f06dde29714840fbdc7595b26">&#9670;&nbsp;</a></span>seq_start_iv</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PagedVector bdsg::PackedGraph::seq_start_iv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encodes the start of a node's sequence in seq_iv. Matches the order of graph_iv. </p>

</div>
</div>
<a id="a6a2a3b08add2ff14b0930c2f9b3e8515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2a3b08add2ff14b0930c2f9b3e8515">&#9670;&nbsp;</a></span>SEQ_START_RECORD_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t bdsg::PackedGraph::SEQ_START_RECORD_SIZE = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abf5f597ac6398e6df99dc9d457670d88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5f597ac6398e6df99dc9d457670d88">&#9670;&nbsp;</a></span>STEP_RECORD_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t bdsg::PackedGraph::STEP_RECORD_SIZE = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e6a0778610a6c987e25973a3dc6b063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e6a0778610a6c987e25973a3dc6b063">&#9670;&nbsp;</a></span>WIDE_PAGE_WIDTH</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t bdsg::PackedGraph::WIDE_PAGE_WIDTH = 1024</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>deps/libbdsg/include/bdsg/<a class="el" href="packed__graph_8hpp.html">packed_graph.hpp</a></li>
<li>deps/libbdsg/src/<a class="el" href="packed__graph_8cpp.html">packed_graph.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
